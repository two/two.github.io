<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>go context | oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  
  <meta name="description" content="Contex 的作用在 Go 服务器中, 每个请求都是由一个独立的 goroutine 进行处理的。请求处理程序往往会启动其它的 goroutine 来访问后端，比如数据库和 RPC 服务。 处理请求的goroutine 通常需要访问特定的值，比如用户身份的标识，token, 请求的超时时间。当一个">
  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="go context">

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>go context</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/11/25/go-context/" rel="bookmark">
        <time class="entry-date published" datetime="2019-11-25T10:42:54.000Z">
          2019-11-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Contex-的作用"><a href="#Contex-的作用" class="headerlink" title="Contex 的作用"></a>Contex 的作用</h1><p>在 Go 服务器中, 每个请求都是由一个独立的 goroutine 进行处理的。请求处理程序<br>往往会启动其它的 goroutine 来访问后端，比如数据库和 RPC 服务。 处理请求的<br>goroutine 通常需要访问特定的值，比如用户身份的标识，token, 请求的超时时间。<br>当一个请求被取消或者超时时，处理改请求的所有 goroutine 都应该迅速退出，这样<br>系统就可以回收他们正在使用的资源。</p>
<p>对于 Go 语言，由于是单进程的模式 goroutine 之间内存是共享的，那么 goroutine 是<br>如何获取自己的上下文数据的呢？对于一些多线程模式运行的语言中，比如 Java  可以<br>通过 ThreadLocal 来传递线程间的上下文，但是 Go 语言并不提倡这种模式，Go 语言中<br>你甚至无法知道 goroutine 的编号，一切都是 Go 自己帮你管理的。为了解决这个问题<br>Go 使用的就是传递 Context 参数。</p>
<p>这种方式是 Go 语言比较特殊的地方，也是很多人诟病的地方，如果你要传递上下文正规<br>的方式就是这种，Go 语言甚至规定了它的具体用法：</p>
<ol>
<li>不要把它放到一个结构体中, 而是在需要的地方直接传递它</li>
<li>放到函数的第一个参数中，并且命名为 ctx</li>
</ol>
<p>对于第一个限制，后面会详细讲解其原因。</p>
<h1 id="Context-结构"><a href="#Context-结构" class="headerlink" title="Context 结构"></a>Context 结构</h1><p>Context 本质上是为了传递上下文，这个上下文不止是一些变量，还包括传递事件。<br>下面我们给一个使用的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ctx1 := context.Background()</span><br><span class="line"></span><br><span class="line">        ctx2, _ := context.WithCancel(ctx1)</span><br><span class="line">        ctx3, _ := context.WithCancel(ctx1)</span><br><span class="line"></span><br><span class="line">        ctx4, _ := context.WithCancel(ctx2)</span><br><span class="line">        ctx5, _ := context.WithCancel(ctx2)</span><br><span class="line"></span><br><span class="line">        ctx6, _ := context.WithCancel(ctx3)</span><br><span class="line">        ctx7, _ := context.WithCancel(ctx3)</span><br><span class="line"></span><br><span class="line">        ctx8, _ := context.WithCancel(ctx4)</span><br><span class="line">        ctx9, _ := context.WithCancel(ctx4)</span><br><span class="line"></span><br><span class="line">        ctx10, _ := context.WithCancel(ctx5)</span><br><span class="line">        ctx11, _ := context.WithCancel(ctx5)</span><br><span class="line"></span><br><span class="line">        ctx12, _ := context.WithCancel(ctx6)</span><br><span class="line">        ctx13, _ := context.WithCancel(ctx6)</span><br><span class="line"></span><br><span class="line">        ctx14, _ := context.WithCancel(ctx7)</span><br><span class="line">        ctx15, _ := context.WithCancel(ctx7)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(ctx8)</span><br><span class="line">        <span class="built_in">println</span>(ctx9)</span><br><span class="line">        <span class="built_in">println</span>(ctx10)</span><br><span class="line">        <span class="built_in">println</span>(ctx11)</span><br><span class="line">        <span class="built_in">println</span>(ctx12)</span><br><span class="line">        <span class="built_in">println</span>(ctx13)</span><br><span class="line">        <span class="built_in">println</span>(ctx14)</span><br><span class="line">        <span class="built_in">println</span>(ctx15)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前面这个例子，最终会形成一个 Context 的树形结构，结构如下：</p>
<p><img src="/assets/img/go/context/context_tree.svg" alt></p>
<h2 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h2><p>前面的结构中 <code>ctx1</code> 是根节点, 根节点通过 <code>context.Background()</code>  函数创建的，<br>函数源码如下: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">        todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到根节点是一个 <code>emptyCtx</code> 类型的数据,  这个结构实现了 <code>Context</code> 接口:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line"> Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> Err() error</span><br><span class="line"> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到 <code>emptyCtx</code> 实现很简单，基本都是返回 <code>nil</code>。对于根节点来说它并不能够<br>真正的传递一些信息和事件，其它的 context 则是依赖这个作为根节点来实现的。</p>
<h2 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h2><h3 id="树的建立"><a href="#树的建立" class="headerlink" title="树的建立"></a>树的建立</h3><p>cancelCtx 是一个可以传递 cancel 事件的 context， 通过 <code>WithCancel</code> 函数可以获取<br>一个 cancelCtx 类型的结构，并且还会返回它对应的 cancel 函数，当我们调用这个函数<br>时就会把事件传递到这个结构及他的所有子节点。源码实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">        c := newCancelCtx(parent) <span class="comment">// 新建一个 cancelCtx</span></span><br><span class="line">        propagateCancel(parent, &amp;c) <span class="comment">// 把当前新节点放到 parent 的子节点中</span></span><br><span class="line">        <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125; <span class="comment">// 返回 cancel 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>newCancelCtx</code> 函数我们把当前节点的 <code>Context</code> 字段指向了 <code>parent</code>, 也就是父节点。</p>
<p>通过调用 <code>propagateCancel</code> 函数我们可以把当前新建的节点放到对应的 context 树中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123; <span class="comment">// 对于 parent.Done() == nil 直接返回，</span></span><br><span class="line">                                  <span class="comment">// 因为这个节点是空节点, 没有 children 字段</span></span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">                p.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// parent has already been canceled</span></span><br><span class="line">                        child.cancel(<span class="literal">false</span>, p.err) <span class="comment">// 如果父节点存在错误信息，</span></span><br><span class="line">                                                   <span class="comment">// 证明父节点已经被取消，那么子节点也应该取消</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                        p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 放入子节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                p.mu.Unlock()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">                        <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于根节点，执行到下面这里就会返回:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是根节点是没有 <code>children</code> 字段的, 无法通过根节点查找子节点, 但是子节点<br>可以通过 <code>Context</code> 字段找到父节点。</p>
<p>我们再看另一种情况 <code>ctx4</code> 是如何挂载到 <code>ctx2</code>。前面的操作基本都一致，但是会走到<br>下面这段逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// parent has already been canceled</span></span><br><span class="line">                child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                        p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用 <code>parentCancelCtx</code> 函数判断父节点的类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">                        <span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">                <span class="keyword">case</span> *timerCtx:</span><br><span class="line">                        <span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">                <span class="keyword">case</span> *valueCtx:</span><br><span class="line">                        parent = c.Context</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>cancelCtx</code>, <code>timerCtx</code> 这些类型会返回 true, 然后判断父节点是否已经有错误信息，<br>如果有错误信息表示父节点已经调用了 cancel, 那么为了传播这个事件，子节点也应该调用<br>cancel, 对于没有 cancel 的父节点则把当前节点放到父节点的 children 结构中。</p>
<p>如果 <code>parentCancelCtx</code> 返回 false 呢？也就是不属于前面几种类型。这个跟前面解释的 context<br>的使用原则: “1. 不要把它放到一个结构体中, 而是在需要的地方直接传递它” 相关的，也就是当我们<br>把 context 放到结构体中进行传递则会满足这个条件，走到下面的逻辑: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">        &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>会开起一个新的 goroutine 来监听这个节点，而不会放到树中。 可以看出其实是监听了父节点和<br>本身节点, 因为如果父节点 cancel 了，子节点也需要 cancel ，因为父节点的事件要传播到子节点;<br>本身节点也是需要监听，调用 cancel 后也要结束这个 goroutine，如果不监听则需要依赖父节点，<br>如果父节点不接受这个节点即使调用了 cancel 也无法结束，所以两者缺一不可。</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>前面说 <code>WithCancel</code> 函数会返回一个 <code>cancel</code> 函数，如果我们调用的话会传递这个消息到所有的<br>子节点中。 我们修改一下前面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ctx4, cancel4 := context.WithCancel(ctx2)</span><br><span class="line">cancel4()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当我调用 <code>cancel4()</code>, 其实调用的是 <code>cancel(true, err)</code>, 第一个参数传 true 表示需要从树中<br>删除其子节点，第二个参数传取消的错误信息。 具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">                c.mu.Unlock()</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.err = err</span><br><span class="line">        <span class="comment">// 通过 chan 传递给所有监听的程序</span></span><br><span class="line">        <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">                c.done = closedchan</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">close</span>(c.done)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归传递消息给所有子节点</span></span><br><span class="line">        <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">                child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        c.children = <span class="literal">nil</span></span><br><span class="line">        c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从树中删除子节点</span></span><br><span class="line">        <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">                removeChild(c.Context, c)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cancel</code> 函数主要是有三个作用:</p>
<ol>
<li><p>通过 close(chan) 传递给所有的监听的程序这个消息<br>监听的程序如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">                c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        d := c.done</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息传递个所有子节点，所有监听子节点的程序也收到消息</p>
</li>
<li>把当前子节点机器及其下面的所有节点从树中删除</li>
</ol>
<p>前面可以看出消息传递给子节点的时候调用了 <code>cancel</code> 函数，但是第一个参数传递的是 <code>false</code>,<br>为什么呢? 显然后面把当前节点的子节点已经删除了,  没有必要在对其所有下面的节点执行<br>删除操作了, 否则就是重复删除。</p>
<p>下面用图来表示, 首先是消息的传播，红色表示收到了消息的节点:</p>
<p><img src="/assets/img/go/context/context_tree_cancel.svg" alt></p>
<p>然后把节点从树中删除:</p>
<p><img src="/assets/img/go/context/context_tree_remove.svg" alt></p>
<h2 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h2><p>timerCtx  是跟时间相关的 Contex, 可以通过这个设置过期时间，并且传播消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">        cancelCtx</span><br><span class="line">        timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">        deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想新建一个 timerCtx 需要通过 <code>WithDeadline</code> 函数(也可以通过 <code>WithTimeout</code>， 但这个<br>函数其实是 <code>WithDeadline</code> 的包装调用，无需详细讲解), 第一个参数是父节点，第二个参数是<br>过期时间。 源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">       <span class="comment">// 由于父节点的过期时间比子节点的早，不需要单独设置过期,可以直接返回</span></span><br><span class="line">        <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">                <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">                <span class="keyword">return</span> WithCancel(parent) </span><br><span class="line">        &#125;</span><br><span class="line">        c := &amp;timerCtx&#123;</span><br><span class="line">                cancelCtx: newCancelCtx(parent),</span><br><span class="line">                deadline:  d,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建context 树</span></span><br><span class="line">        propagateCancel(parent, c)</span><br><span class="line">        dur := time.Until(d)</span><br><span class="line">       <span class="comment">// 已经过了过期时间，直接返回, 不需要设置过期时间</span></span><br><span class="line">        <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">                c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">                <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">        <span class="comment">// 设置过期时间，在过期时间会调用 cancel 函数</span></span><br><span class="line">        <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回取消函数</span></span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现由很多优化的地方，首先对于设置的过期时间会和父节点进行比较，如果父节点过期<br>时间比当前节点的过期时间早，则直接返回一个 cancelCtx, 不需要设置过期时间，因为父节点肯定<br>比子节点过期的早，会触发消息的传递，然后传递个子节点，子节点没有机会执行自己的消息传递。<br>其次，计算完时间后，如果发现已经过期了，直接调用子节点的 cancel 函数，这时已经出发了消息<br>传递。 上面两个条件都不满足，则会调用 <code>time.AfterFunc</code> 函数设置一个时间，到这个时间后会<br>主动调用 cancel 函数进行消息的传播。</p>
<p>函数也会返回对应的 cancel 函数，我们也可以主动调用, 这个函数实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">        c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">        <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">                <span class="comment">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class="line">                removeChild(c.cancelCtx.Context, c)</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">                c.timer.Stop()</span><br><span class="line">                c.timer = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际调用了 <code>cancelCtx</code>的 cancel 函数, 还有一点要注意这里调用了<code>c.timer.Stop()</code>,<br>这里是如果主动调用了 cancel 函数，则其对应的计时器就没有作用了，应该提前停止，这样<br>可以主动释放资源。</p>
<h2 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h2><p>前面讲的都是如何利用 context 传递消息，这里讲的是如何通过 context 传递数据。<br>context 的数据传递是通过 <code>valueCtx</code> 来完成的，他的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">        Context</span><br><span class="line">        key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是包含了 一对 key, val</p>
<p>valueCtx 的生成是通过 <code>WithValue</code> 来实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断类型是否可以使用 ==  比较</span></span><br><span class="line">        <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断当前的 key 是否可以使用 == 判断相等(这个定义在 <code>runtime/alg.go</code>中<br>可以看到, 这里不是重点就不介绍了)。 然后返回一个 <code>valueCtx</code> 结构。<code>valueCtx</code><br>的 <code>Context</code> 字段指向的是父节点。</p>
<p><code>valueCtx</code> 实现的也是一个树结构, 但是跟前面的 <code>cancelCtx</code> 不同，这里的 <code>valueCtx</code><br>没有指向子节点的指针，只有指向父节点的指针，也就是说只能子节点访问父节点，父节点<br>无法方位子节点。</p>
<p>通过 <code>WithValue</code> 可以给一个 <code>valueCtx</code> 设置 key 和 value, 这样就能携带一些信息。<br>构建的树如下：</p>
<img src="http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuN9AJCvEByelpKjHiD7LLIXBp2bDTIwfCCGbOSG5Lu8YRen3t0GkReGYRef3t8oBApyfApMvH07XW6gkMfWWmf9gBkVyl9BKYXAkxDHAY66Ooeo8KsPCd38JufIP4gVC38SoXzIy563C0000">
<p>对于 valueCtx, 我们通过 <code>Value</code> 函数来获取这个信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">                <span class="keyword">return</span> c.val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到如何当前的 key 匹配到了,则返回对应的值，如果没有找打则会寻找父节点，这样递归的往上找，<br>直到不是 <code>valueCtx</code> 的节点, 返回 nil。 可见 value 的查找是非常低效的。最重要的是当你使用 context<br>传递数据时，可能会滥用，比如在过渡依赖 context, 在各个地方都会设置值:</p>
<ol>
<li>查找的时候不一定会从哪个节点开始，如果从父节点查找，而值存在子节点你是查找不到的</li>
<li>如果 key 一致可能会无意中覆盖原来的值</li>
<li>如果多个几点都有查找的 key, 那么查找的结果不一定会是哪一个</li>
</ol>
<p>对于 key 的限制，golint 有一条规则 : <code>should not use basic type %s as key in context.WithValue</code><br>哪些是基本类型呢？golint 中定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicTypeKinds = <span class="keyword">map</span>[types.BasicKind]<span class="keyword">string</span>&#123;</span><br><span class="line">    types.UntypedBool:    <span class="string">"bool"</span>,</span><br><span class="line">    types.UntypedInt:     <span class="string">"int"</span>,</span><br><span class="line">    types.UntypedRune:    <span class="string">"rune"</span>,</span><br><span class="line">    types.UntypedFloat:   <span class="string">"float64"</span>,</span><br><span class="line">    types.UntypedComplex: <span class="string">"complex128"</span>,</span><br><span class="line">    types.UntypedString:  <span class="string">"string"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是因为对于基本类型而言，复制会出现覆盖，查找出现不确定的情况。一般情况下建议<br>使用一些自定义类型作为 key, 避免与其他的key冲突。</p>
<h1 id="数据结构之间的关系："><a href="#数据结构之间的关系：" class="headerlink" title="数据结构之间的关系："></a>数据结构之间的关系：</h1><p>前面讲了 context 中好几种数据结构及其实现，其实他们之间是有这非常紧密的联系的，<br>为了更加直观的看出的他们的关系，这里用一张图来表示：</p>
<img src="http://www.plantuml.com/plantuml/svg/TT513i8W40NGFQTWgIRr0CPTzGGcxWaTbOHIGz3KnCDBfKC_67VqGVxCT8mBv2zAaso7U1o3C5cqSfeiUI74V2btya3AMkDejKOSAZXwNtoVbNrCBmHdHal7Y61paA3-7bvj62ETWZVk6X4Cca0TQabj0EG-Wkd9vx1k3WFDPS5Ie_7yYyjiHIz8gHcKN0EHzu2cRyPsdbo9kV1pcggA1EEXWRW8h7R_tcub_wfbm4tJmDnvLT_NYnSXVvZBLo5SINm0">
<p>这些结构体基本上都实现了 Context 接口，但是一般每个结构的侧重不一样，对于一些<br>接口的函数都是默认的实现。 比如 <code>cancelCtx</code> 并没有定义 <code>Value</code> 函数, <code>valueCtx</code><br>也没有具体实现 <code>Done</code>, 这些函数是什么都不做的。</p>
<h1 id="context-使用举例"><a href="#context-使用举例" class="headerlink" title="context 使用举例"></a>context 使用举例</h1><p> 对于 context 的使用 context 包里有说明：</p>
<ul>
<li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li>
<li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li>
<li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。<br>例如：登陆的 session、cookie 等。</li>
<li>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</li>
</ul>
<p>context 的使用常见主要有以下几个。下面分别做一下介绍。</p>
<h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><p>在 web 开发中，我们为了串联整个请求的路径，会在日志中记录每条请求的唯一 id, 并且在访问下游服务<br>的时候把这个 id 传递下去。通过这个 id, 我们就能够对本次请求的路径进行了解，并且在遇到问题的时候<br>很好的定位在哪一步出现了问题。下面我们使用 context 来传递这个数据:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> traceType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ctx := context.Background()</span><br><span class="line">        ctx = context.WithValue(ctx, traceType(<span class="string">"traceId"</span>), rand.Int())</span><br><span class="line">        process(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        traceID, ok := ctx.Value(traceType(<span class="string">"traceId"</span>)).(<span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"traceType traceID=%d\n"</span>, traceID)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"no traceType tranceID"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceID, ok = ctx.Value(<span class="string">"traceId"</span>).(<span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"string type traceID=%d\n"</span>, traceID)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"no string type tranceID"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意一点，<code>WithValue</code> 的 key 使用的是自定义的类型 <code>traceType</code> 而不是基本类型 <code>string</code>,<br>避免了查找冲突和覆盖的问题。所以输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traceType traceID=5577006791947779410</span><br><span class="line">no string type tranceID</span><br></pre></td></tr></table></figure></p>
<p>在实际的开发中我们要需要在 server 端给每个请求都加上这个 ID, 这个数据优先是从 HEADER 里传过来。<br>所以一般实际业务中我们这么写：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> requestType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> traceID = requestType(<span class="string">"traceID"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        h := hand&#123;&#125;</span><br><span class="line">        http.HandleFunc(<span class="string">"/hi"</span>, hi)</span><br><span class="line">        http.ListenAndServe(<span class="string">":8000"</span>, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hand)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        v := req.Header.Get(<span class="string">"X-TRACE-ID"</span>)</span><br><span class="line">        ctx := context.WithValue(req.Context(), traceID, v)</span><br><span class="line">        reqCtx := req.WithContext(ctx)</span><br><span class="line"></span><br><span class="line">        http.DefaultServeMux.ServeHTTP(rw, reqCtx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hi</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        v := req.Context().Value(traceID).(<span class="keyword">string</span>)</span><br><span class="line">        resp := fmt.Sprintf(<span class="string">"traceID = %s\n"</span>, v)</span><br><span class="line">        fmt.Fprintf(rw, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="防止-goroutine-泄露"><a href="#防止-goroutine-泄露" class="headerlink" title="防止 goroutine 泄露"></a>防止 goroutine 泄露</h2><p>参考文献中的例子:<br>有一个 goroutine 往 chan 发送信息:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gen is a broken generator that will leak a goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ch &lt;- n</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用这个函数，当信息发送次数等于 5 就停止运行:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The call site of gen doesn't have a </span></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen() &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>停止运行后有一个问题，就是 gen 函数里的 goroutine 会一直存在，不会退出。<br>这样就照成了 goroutine 泄露，下面我们利用 context 改进一下这个程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gen is a generator that can be cancellable by cancelling the ctx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// avoid leaking of this goroutine when ctx is done.</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">                n++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入了 context 参数，for 循环利用 select 监听取消的消息。调用的程序也改进了。<br>当 接收5次消息后会调用  cancel 函数发送消息，这样前面的 gen 就能够及时退出了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// make sure all paths cancel the context to avoid context leak</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">        cancel()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>超时控制也是用的比较多的场景。在实际的工作场景中，我们对外提供服务要保证服务的可用性，<br>可用性的一个指标是响应时间。 一般上游访问我们都会有一个超时时间，当过了这个超时时间<br>上游就会结束访问，认为这次请求失败了，这时如果我们的服务还在处理响应的请求已经没有必要<br>了，所以我们应该及时退出，尽快回收资源，提高程序的性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        http.HandleFunc(<span class="string">"/hi"</span>, hi)</span><br><span class="line">        http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hi</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        ctx, cancel := context.WithTimeout(req.Context(), time.Millisecond*<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">defer</span> cancel()</span><br><span class="line">        reqCtx := req.WithContext(ctx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-reqCtx.Context().Done():</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">                        <span class="comment">// do something</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，如果已经进入了业务的处理内部，无法再回到 select 的阶段是无法取消这个<br>goroutine 的，也就是只有提前检查，或者周期性的检测才能使用。 </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.golang.org/context" target="_blank" rel="noopener">Go Concurrency Patterns: Context</a><br><a href="https://mp.weixin.qq.com/s/GpVy1eB5Cz_t-dhVC6BJNw" target="_blank" rel="noopener">深度解密Go语言之context</a><br><a href="https://rakyll.org/leakingctx/" target="_blank" rel="noopener">Using contexts to avoid leaking goroutines</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>