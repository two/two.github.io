<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>go modules | oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  
  <meta name="description" content="依赖的发展历史
相关的依赖管理方案 :PackageManagementTools
GOPATHGo 语言在设计之初就设计了 GOPATH 这个东西，这个表示的是 Go 语言的工作环境，相关介绍可以从GOPATH and workspaces 查看。关于 GO 最早的依赖管理相关的介绍可以从这个文档">
  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="go modules">

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>go modules</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/12/10/go-modules/" rel="bookmark">
        <time class="entry-date published" datetime="2019-12-10T06:39:02.000Z">
          2019-12-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="依赖的发展历史"><a href="#依赖的发展历史" class="headerlink" title="依赖的发展历史"></a>依赖的发展历史</h1><p><img src="/assets/img/go/modules/roadmap.jpeg" alt></p>
<p>相关的依赖管理方案 :<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="noopener">PackageManagementTools</a></p>
<h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>Go 语言在设计之初就设计了 GOPATH 这个东西，这个表示的是 Go 语言的工作环境，相关介绍可以从<br><a href="https://go.googlesource.com/go/+/refs/tags/go1/doc/code.html" target="_blank" rel="noopener">GOPATH and workspaces</a> 查看。<br>关于 GO 最早的依赖管理相关的介绍可以从这个文档中看到:</p>
<blockquote>
<p>One of Go’s design goals is to make writing software easier. To that end, the go command doesn’t use Makefiles or other configuration files to guide program construction. Instead, it uses the source code to find dependencies and determine build conditions. This means your source code and build scripts are always in sync; they are one and the same.</p>
</blockquote>
<p>大致意思是: Go 的设计目标是使写代码变得更加容易。 所以 Go 命令不使用 Makefiles 或者其他配置文件来指导程序的构建。Go 使用源代码来查找依赖关系并确定构建的条件。(后来发现这样不行，所以才有了这篇文章)</p>
<p>关于 GOPATH 的其他相关知识可以查看 <a href="https://golang.org/cmd/go/#hdr-GOPATH_environment_variable" target="_blank" rel="noopener">GOPATH environment variable</a></p>
<p>从Go1.8开始 GOPATH 就不需要自己设定，而是给了一个<a href="https://golang.org/doc/go1.8#gopath" target="_blank" rel="noopener">默认值</a>: It defaults to $HOME/go on Unix and %USERPROFILE%/go on Windows。</p>
<p>GOPATH 的问题: Go程序通常由来自许多不同来源的程序包组成。 这些来源中的每一个都可以从GOPATH或标准库中获取。 但是，只有他们的项目受其自己的源代码管理。 依赖的包不受他们的管理和控制，如果依赖包发生更改或消失时就会影响项目的编译。 通常为了避免这些问题，有以下几种做法:</p>
<ol>
<li>将依赖包复制到项目目录中，并重写引用它的导入。</li>
<li>将相关程序包复制到项目代码库中，并修改GOPATH变量以包括项目特定的子目录。</li>
<li>将依赖包版本写到一个文件中，然后将现有的GOPATH软件包更新为该版本。</li>
</ol>
<p>但是这些做的后果同样会产生对应的问题:</p>
<ol>
<li>需要修改导入路径，还会存在包名冲突的问题, 分不清自己的和依赖的包。</li>
<li>存在多个 GOPATH, 而且是嵌套的，很容易出现查找不准等问题。</li>
<li>在正常的GOPATH中修改程序包要求每个项目都具有唯一的GOPATH。 否则不同项目就会产生相互干扰。</li>
</ol>
<h2 id="开源管理软件的繁荣发展"><a href="#开源管理软件的繁荣发展" class="headerlink" title="开源管理软件的繁荣发展"></a>开源管理软件的繁荣发展</h2><p>由于 GOPATH 的众所周知的问题，社区出了很多开源的管理方案</p>
<table>
<thead>
<tr>
<th>软件</th>
<th>发布日期</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tools/godep" target="_blank" rel="noopener">godep</a></td>
<td>2013.05</td>
</tr>
<tr>
<td><a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">glide</a></td>
</tr>
<tr>
<td><a href="https://github.com/jingweno/nut" target="_blank" rel="noopener">nut</a></td>
<td>2015.01</td>
</tr>
</tbody>
</table>
<p>开源的依赖管理工具就不一一介绍了，主要功能有面几个:</p>
<ol>
<li>记录所有依赖的包的地址及版本号</li>
<li>把所有的依赖下载到一个特定的目录中(例如 godep 的 workspance, nut 的 vendor)</li>
<li>把这个特定的目录加到 $GOPATH 中，并且放到最前面</li>
</ol>
<p>通过上面的方式，就可以解决依赖的特定版本的功能，及不同项目之间的环境和依赖不相互干扰，可以放心的开发。</p>
<p>这个开源软件的问题是每个软件的使用方式不同，不同的第三方包依赖方式也不同，导致依赖的使用很混乱。</p>
<h2 id="增加-vendor"><a href="#增加-vendor" class="headerlink" title="增加 vendor"></a>增加 vendor</h2><p>为了解决混乱的依赖问题 Go 官方在 2016年6月发布的 Go 1.5 版本中加入了一个新的特性 <em>vendor</em> 关于 vendor 的设计可以参考: <a href="https://go.googlesource.com/proposal/+/master/design/25719-go15vendor.md" target="_blank" rel="noopener">Go 1.5 Vendor Experiment</a>。<br>在项目根目录下新增了一个 vendor 目录，当项目编译时会首先从 vendor 目录下查找相关依赖，找不到的情况下再去 GOPATH 下查找。这个特性出了之后很多开源的依赖管理工具也进行了跟进，这样开源依赖管理软件就不用自己设置特定的目录来存放依赖，也不用设置GOPATH 就可以完成依赖的查找。</p>
<p>vendor 的加入是为了解决 GOPATH 的不足， 开发者可以把依赖放到 vendor 中而不影响其它项目，也可以防止依赖的变更和丢失。对于第二个作用也会产生一个副作用：代码库依赖太庞大，照成存储上的浪费。</p>
<p>vendor 还有一个问题是版本不明确，无法通过 vendor 很好的进行版本管理。</p>
<p>鉴于以上各种问题和开源依赖的混乱，官方决定自己做一个依赖管理工具: dep</p>
<h2 id="官方实验项目-dep"><a href="#官方实验项目-dep" class="headerlink" title="官方实验项目: dep"></a>官方实验项目: dep</h2><p>前面说开源工具比较混乱，是因为大家使用不同的依赖管理工具，有一个问题就是你的间接依赖的版本如何确定？ 因为某些间接依赖的版本根据依赖管理工具的使用来标明的，如果使用不同的依赖管理工具就无法获取你的间接依赖版本，或者需要兼容你得依赖管理工具，这样做太难了。最好的方式当然是统一依赖管理工具，这样能够很好的进行依赖的分析。</p>
<p>2016 年 GopherCon 大会后， 一个计划改善 Go 依赖管理的<a href="https://docs.google.com/document/d/18tNd8r5DV0yluCR7tPvkMTsWD_lYcRO7NhpNSDymRr8/edit" target="_blank" rel="noopener">民间组织</a>成立了。这个组织的目的就是为了开发一个能够完善的解决包依赖管理问题的方案。这个方案就是: <a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a> 。这个小组甚至邀请了一些开源的依赖管理工具的作者: </p>
<ul>
<li>Daniel Theophanes (govendor)</li>
<li>Dave Cheney (gb)</li>
<li>Matt Farina (Glide)</li>
<li>Steve Francia (Hugo, Cobra)</li>
</ul>
<p>作为顾问。</p>
<p>dep 工具和开源的依赖管理工具思路是一样的:</p>
<ol>
<li>依赖 GOPATH 判断包的依赖地址和版本</li>
<li>依赖 vendor 下载依赖到项目下，保证编译版本一致</li>
</ol>
<p>为了让你能够从其它依赖管理工具迁移到 dep, dep 还会分析已经项目中已经存在的常见的依赖管理文件，并在初始化的时候与里面的依赖版本保持一致。</p>
<h2 id="gopkg-in"><a href="#gopkg-in" class="headerlink" title="gopkg.in"></a>gopkg.in</h2><p>跟使用依赖管理工具的思路不同，gopkg.in 的思路是让你的包版本化，例如： <code>gopkg.in/yaml.v1</code>。在包后面加上版本的信息，这样能够明确要引用的包的版本，当然这个版本信息你要写到自己的 import 语句当中，如果你引用的包版本发生了变化，你也要修改你自己的 import 语句。 这个前面的思路不同，前面的思路是引用者确定版本信息，而这个思路是包的提供者要明确版本信息。</p>
<h2 id="go-modules"><a href="#go-modules" class="headerlink" title="go modules"></a>go modules</h2><blockquote>
<p>This proposal keeps the best parts of go get, adds reproducible builds, adopts semantic versioning, eliminates vendoring, deprecates GOPATH in favor of a project-based workflow, and provides for a smooth migration from dep and its predecessors. </p>
</blockquote>
<p><a href="https://www.hyrumslaw.com/" target="_blank" rel="noopener">Hyrum’s law</a>:</p>
<blockquote>
<p>With a sufficient number of users of an API, it does not matter what you promise in the contract. All observable behaviors of your system will be depended on by somebody.<br>当接口的使用者数量达到一定数量后，你指定的规则就不重要了，所有的表现都取决于他的使用者。</p>
</blockquote>
<blockquote>
<p>While Hyrum’s law is empirically true, semantic versioning is still a useful way to frame expectations about the relationships between releases. Updating from 1.2.3 to 1.2.4 should not break your code, while updating from 1.2.3 to 2.0.0 may. If your code stops working after an update to 1.2.4, the author is likely to welcome a bug report and issue a fix in 1.2.5. If your code stops working (or even compiling) after an update to 2.0.0, that change has a much greater chance of being intentional and a correspondingly lesser chance of being fixed to your code’s liking in 2.0.1.<br>语义版本控制仍然是一种构架对发布之间关系的期望的有用方法。 小版本的更新不会破坏你的代码（向后兼容）, 如果出现了错误你应该报告给作者，让他进行修改；大版本的更新可能会让你的代码无法编译，因为大版本可能不是向后兼容的，但是这种改变可能正式作者期望的。</p>
</blockquote>
<blockquote>
<p>More fundamentally, vendoring is an incomplete solution to the package versioning problem. It only provides reproducible builds. It does nothing to help understand package versions and decide which version of a package to use. Package managers like glide and dep add the concept of versioning onto Go builds implicitly, without direct toolchain support, by setting up the vendor directory a certain way. As a result, the many tools in the Go ecosystem cannot be made properly aware of versions. It’s clear that Go needs direct toolchain support for package versions.<br>从根本上讲，供应商是软件包版本控制问题的不完整解决方案。它仅提供可复制的版本。它无助于了解软件包的版本以及决定使用哪个版本的软件包。软件包管理器（例如glide和dep）通过以某种方式设置供应商目录，将版本控制的概念隐式地添加到Go构建中，而无需直接的工具链支持。结果，无法正确地了解Go生态系统中的许多工具的版本。显然，Go需要针对软件包版本的直接工具链支持。</p>
</blockquote>
<p>对上面的论述优点以为，为什么『无法正确地了解 Go 生态系统中许多工具的版本』</p>
<h3 id="Go-依赖管理的三个原则"><a href="#Go-依赖管理的三个原则" class="headerlink" title="Go 依赖管理的三个原则"></a>Go 依赖管理的三个原则</h3><p>这是Go中版本控制的三项原则，这是Go模块设计偏离Dep，Cargo，Bundler等设计的原因。</p>
<h4 id="1-兼容性"><a href="#1-兼容性" class="headerlink" title="1 兼容性"></a>1 兼容性</h4><p>程序中名称的含义不应随时间改变。 对于兼容性主要有一些异议:</p>
<ol>
<li>美学: 对于 Go 来说良好的软件工程性比一些主观上的美学更加重要。 除了视觉美学，我们会习惯它们，并且会重视它们带来的精确性和简单性。<br>1.1 Go 语言去掉 export 关键字而使用首字母大小写代替是否可导出，从编程习惯是需要适应，但是也能够一眼看出哪些调用是可导出的。<br>1.2 导入路径看上去有点儿长，但是能够更加精细的表示导入的模块，从而避免了不必要的重复。</li>
<li>需要修改导入路径<br>我们使导入路径在语义上保持精确。另一个好处是，当您从软件包的v2升级到v3时，您可以逐步，分阶段地（一次可能一个软件包）逐步更新程序</li>
<li>构建中的多个主要版本<br>其它依赖管理工具不允许同一个代码库的不同版本同时被依赖, 这样能够降低开发者的复杂性，但是对用户来说则可能会更加复杂，而且时间情况中无法避免同一个项目的代码在他的所有依赖文件中出现不同的版本。</li>
</ol>
<h4 id="2-可重复性"><a href="#2-可重复性" class="headerlink" title="2 可重复性"></a>2 可重复性</h4><p>当您构建特定版本的程序包时，构建应以可重复的方式决定要使用的依赖项版本，该依赖关系不会随着时间的推移而改变。 对这个原则的主要异议在于，很多人认为使用最新的版本是一项基本的诉求，很多人希望能够使用最新的版本到达更新一些 bug 的修复和性能的提升等。但是同时大家都会认为构建的可重复性是更加重要的，因为这能够保证程序的稳定性，这是最基本的要求。一些依赖工具例如 Dep 会优先使用最新版本，但是为了保持稳定性还有一个 lock 文件保证某些依赖的版本不变。Dep 的 lock 文件问题在于只会对当前代码库生效，如果这个代码库是其他库的一部分，那么就无法保证这种稳定性。所以 Go Modules 通过最小版本依赖原则来优先保证构建的稳定性。</p>
<h4 id="3-合作"><a href="#3-合作" class="headerlink" title="3 合作"></a>3 合作</h4><p>为了维护Go软件包生态系统，我们必须共同努力, 致力于保证兼容性。工具无法解决缺乏合作的问题。<br>无论是基于 <a href="https://research.swtch.com/version-sat" target="_blank" rel="noopener">SAT</a> 算法的 Dep 还是基于最小版本原则的 Go Modules 都无法保证兼容性。但是最小版本选择比 SAT 更加具有稳定性( 证明可以看这里: <a href="https://research.swtch.com/vgo-principles#sat-example" target="_blank" rel="noopener">Go Modules 与 SAT 解决方案对比</a>)</p>
<h3 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h3><p><img src="https://research.swtch.com/impver@2x.png" alt></p>
<p>三位版本号:</p>
<ol>
<li>第一位版本号(major version): 一些不兼容的修改</li>
<li>第二位版本号(minor version): 一些新特性的增加</li>
<li>第三位版本号(patch version): 一些 bug 的修复</li>
</ol>
<blockquote>
<p>A year ago, I believed that putting versions in import paths like this was ugly, undesirable, and probably avoidable. But over the past year, I’ve come to understand just how much clarity and simplicity they bring to the system. In this post I hope to give you a sense of why I changed my mind. @Russ Cox</p>
</blockquote>
<blockquote>
<p>Packages intended for public use should try to maintain backwards compatibility as they evolve. The Go 1 compatibility guidelines are a good reference here: don’t remove exported names, encourage tagged composite literals, and so on. If different functionality is required, add a new name instead of changing an old one. If a complete break is required, create a new package with a new import path. @Russ Cox</p>
</blockquote>
<h3 id="最小版本原则"><a href="#最小版本原则" class="headerlink" title="最小版本原则"></a>最小版本原则</h3><p>应该是最小满足版本的原则。</p>
<ol>
<li>满足: 如果依赖中存在版本的指名，则选择所有依赖中指名得版本的最大版本。</li>
<li>最小: 如果当前没有指名依赖版本，则以满足为条件选择，而不是选择当前代码库得最新版本。</li>
</ol>
<p>初始依赖关系:<br><img src="https://research.swtch.com/version-select-1@2x.png" alt></p>
<ol>
<li>构建需求清单</li>
</ol>
<p><img src="https://research.swtch.com/version-select-list@2x.png" alt="算法演进"><br><img src="https://research.swtch.com/version-select-2@2x.png" alt="最终选择"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.2.0</span><br><span class="line">github.com/two/c v1.2.0</span><br><span class="line">github.com/two/d v1.4.0</span><br><span class="line">github.com/two/e v1.2.0</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>升级所有模块</li>
</ol>
<p>go module 暂未发现此功能<br><img src="https://research.swtch.com/version-select-3@2x.png" alt="升级所有模块"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> get -u</span><br><span class="line"><span class="variable">$go</span> list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.2.0</span><br><span class="line">github.com/two/c v1.3.0</span><br><span class="line">github.com/two/d v1.4.0</span><br><span class="line">github.com/two/e v1.3.0</span><br><span class="line">github.com/two/f v1.1.0</span><br><span class="line">github.com/two/g v1.2.0</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>计算最小需求列表</li>
</ol>
<p>升级所有模块有的 go.mod 文件长这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module github.com/two/a</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/two/b v1.2.0</span><br><span class="line">        github.com/two/c v1.3.0</span><br><span class="line">        github.com/two/d v1.4.0 // indirect</span><br><span class="line">        github.com/two/e v1.3.0 // indirect</span><br><span class="line">        github.com/two/g v1.2.0 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里只是列出了必须的模块的依赖, 例如 <code>github.com/two/f</code> 模块可以通过 <code>github.com/two/c</code>模块的依赖表示，就没有必要写进去。<br>但是 <code>github.com/two/f</code> 引用的是 <code>github.com/two/g</code> 的 <code>v1.1.0</code>, 这里由于需要的是 <code>v1.2.0</code>, 所以回单独列出来。</p>
<ol start="4">
<li><p>升级单个模块<br><img src="https://research.swtch.com/version-select-4@2x.png" alt><br>保证已经存在的依赖不能降级</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.2.0</span><br><span class="line">github.com/two/c v1.3.0</span><br><span class="line">github.com/two/d v1.4.0</span><br><span class="line">github.com/two/e v1.2.0</span><br><span class="line">github.com/two/f v1.1.0</span><br><span class="line">github.com/two/g v1.1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>降级</p>
</li>
</ol>
<p><img src="https://research.swtch.com/version-select-5@2x.png" alt="降级"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/two/d@v1.2.0</span><br><span class="line">go list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.1.0</span><br><span class="line">github.com/two/c v1.1.0</span><br><span class="line">github.com/two/d v1.2.0</span><br><span class="line">github.com/two/e v1.2.0</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module github.com/two/a</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/two/b v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">        github.com/two/c v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">        github.com/two/d v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">        github.com/two/e v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>排除模块</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module github.com/two/a</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require github.com/two/b v1.2.0</span><br><span class="line"></span><br><span class="line">exclude github.com/two/d v1.3.0</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.2.0</span><br><span class="line">github.com/two/d v1.4.0</span><br><span class="line">github.com/two/e v1.2.0</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/issues/24098" target="_blank" rel="noopener">循环依赖</a></p>
<h3 id="引入-go-module-概念"><a href="#引入-go-module-概念" class="headerlink" title="引入 go module 概念"></a>引入 go module 概念</h3><ol>
<li>module 是公共引用前缀，是版本控制的单位。</li>
<li>引入代理的概念, 不依赖各种版本控制工具下载，防止碎片化，都改为使用 HTTP 协议, 代码库都是以 zip  的形式存在。</li>
<li>不再需要 vendor</li>
<li>提供原生得工具链支持 go mod</li>
<li>不再需要 GOPATH</li>
</ol>
<h3 id="再现性，可验证性和经过验证的构建方式"><a href="#再现性，可验证性和经过验证的构建方式" class="headerlink" title="再现性，可验证性和经过验证的构建方式"></a>再现性，可验证性和经过验证的构建方式</h3><ol>
<li>通过最低版本原则保证每次构建下载的都是同一版本的代码</li>
<li>通过 hash 值保证每个版本代码都有一个唯一的标识</li>
<li>通过 hash 对比保证每个依赖的版本与 hash 对应，防止篡改</li>
</ol>
<h3 id="Go-Modules-的定义"><a href="#Go-Modules-的定义" class="headerlink" title="Go Modules 的定义"></a>Go Modules 的定义</h3><ol>
<li>提倡使用明确的发行版本而不是某个提交的 ID，可以清楚地表明预期。</li>
<li>通过 GOPROXY 解决版本控制的碎片化</li>
<li>通过独立的版本控制在单个代码库中开发多个模块<br> 有两种方式:<ol>
<li>使用单独的分支表示不同的版本<br><img src="https://research.swtch.com/gitmod-1@2x.png" alt></li>
<li>通过子目录表示不同的版本<br><img src="https://research.swtch.com/gitmod-2@2x.png" alt><br>vgo 两种都支持，但是第二种能够更加平滑</li>
</ol>
</li>
<li>通过 GOPROXY 缓存依赖，保证可用性(可重复下载)和安全性(安全检测)</li>
<li>将来引入共享代理，可以默认使用共享代理(类似其它语言的集中式管理)</li>
<li>去掉 vendor 目录，提高依赖的可重复性和可用性。<br>vendor 目录有两个作用。首先，他们通过其内容指定要在期间使用的依赖项的确切版本。其次，即使原始副本消失了，它们也可以确保这些依赖项的可用性。<br>但是 vendor 也有一个弊端就是代码的副本太多了，每个代码库都要提交依赖，占用了大量的存储库的信息。vgo 已经解决了 vendor 所带来的两个好处，所以它就没有存在的必要性了。<br>在编译时 vgo 会忽略 vendor 目录的存在，如果你还想强制使用 vendor 可以使用: <code>go build -mod=vendor</code></li>
</ol>
<h1 id="使用问题及方案"><a href="#使用问题及方案" class="headerlink" title="使用问题及方案"></a>使用问题及方案</h1><h2 id="如何判断是否使用"><a href="#如何判断是否使用" class="headerlink" title="如何判断是否使用"></a>如何判断是否使用</h2><h2 id="如何设置-GOPROXY"><a href="#如何设置-GOPROXY" class="headerlink" title="如何设置 GOPROXY"></a>如何设置 GOPROXY</h2><h2 id="如何-Debug"><a href="#如何-Debug" class="headerlink" title="如何 Debug"></a>如何 Debug</h2><ol>
<li>replace 到本地</li>
<li>使用 vendor 编译</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">Semantic Import Versioning</a></li>
<li><a href="https://blog.golang.org/versioning-proposal" target="_blank" rel="noopener">A Proposal for Package Versioning in Go</a></li>
<li><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">Using Go Modules</a></li>
<li><a href="https://blog.golang.org/migrating-to-go-modules" target="_blank" rel="noopener">Migrating to Go Modules</a></li>
<li><a href="https://blog.golang.org/publishing-go-modules" target="_blank" rel="noopener">Publishing Go Modules</a></li>
<li><a href="https://blog.golang.org/v2-go-modules" target="_blank" rel="noopener">Go Modules: v2 and Beyond </a></li>
<li><a href="https://semver.org/" target="_blank" rel="noopener">Semantic Versioning 2.0.0</a></li>
<li><a href="https://research.swtch.com/deps" target="_blank" rel="noopener">Our Software Dependency Problem</a></li>
<li><a href="https://go.googlesource.com/proposal/+/master/design/25719-go15vendor.md" target="_blank" rel="noopener">Go 1.5 Vendor Experiment</a></li>
<li><a href="https://divan.dev/posts/gopath/" target="_blank" rel="noopener">I still love you , GOPATH</a></li>
<li><a href="https://go.googlesource.com/go/+refs" target="_blank" rel="noopener">Go source code</a></li>
<li><a href="https://medium.com/@freeformz/go-1-5-s-vendor-experiment-fd3e830f52c3" target="_blank" rel="noopener">Go 1.5’s vendor/ experiment</a></li>
<li><a href="https://blog.gopheracademy.com/advent-2015/vendor-folder/" target="_blank" rel="noopener">Understanding and using the vendor folder</a></li>
<li><a href="https://github.com/golang/go/wiki/vgo" target="_blank" rel="noopener">vgo</a></li>
<li><a href="https://groups.google.com/forum/#!msg/go-package-management/a55P0_FU_jA/Y9t_mBroBwAJ" target="_blank" rel="noopener">Dependency Management session at GopherCon</a></li>
<li><a href="https://docs.google.com/document/d/18tNd8r5DV0yluCR7tPvkMTsWD_lYcRO7NhpNSDymRr8/edit" target="_blank" rel="noopener">Go Packaging Proposal Process</a></li>
<li><a href="https://github.com/golang/go/issues/24301" target="_blank" rel="noopener">add package version support to Go toolchain</a></li>
<li><a href="https://docs.google.com/document/d/1xMJ0c-YxvcgNglzjbALzncs5_Acr0MST29oMf9TkgQI/edit" target="_blank" rel="noopener">Vendoring discussion at GopherCon</a></li>
<li><a href="https://www.hyrumslaw.com/" target="_blank" rel="noopener">Hyrum’s law</a>:</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>