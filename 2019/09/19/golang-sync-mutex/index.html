<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>golang sync.mutex | oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  
  <meta name="description" content="##
##
##
1234567const (    mutexLocked = 1 &amp;lt;&amp;lt; iota     // 1 = 0b001    mutexWoken                  // 2 = 0b010    mutexStarving               /">
  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="golang sync.mutex">

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>golang sync.mutex</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/09/19/golang-sync-mutex/" rel="bookmark">
        <time class="entry-date published" datetime="2019-09-19T07:58:18.000Z">
          2019-09-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>##</p>
<p>##</p>
<p>##</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// 1 = 0b001</span></span><br><span class="line">    mutexWoken                  <span class="comment">// 2 = 0b010</span></span><br><span class="line">    mutexStarving               <span class="comment">// 4 = 0b100</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>     <span class="comment">// 3  用来屏蔽低三位，取数量</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 10^6 ns = 1 ms</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// state</span><br><span class="line">   +-----------------------------+---+---+---+                          </span><br><span class="line">   |00000000000000000000000000000|0/1|0/1|0/1|                          </span><br><span class="line">   +-----------------------------+---+---+---+                          </span><br><span class="line">                  |                |   |   |                            </span><br><span class="line">                  |                |   |   |        +-----------+       </span><br><span class="line">                  |                |   |   +-------&gt;|mutexLocked|       </span><br><span class="line">                  |                |   |            +-----------+       </span><br><span class="line">                  |                |   |            +----------+        </span><br><span class="line">                  |                |   +-----------&gt;|mutexWoken|        </span><br><span class="line">                  |                |                +----------+        </span><br><span class="line">                  |                |                +-------------+     </span><br><span class="line">                  |                +---------------&gt;|mutexStarving|     </span><br><span class="line">                  |                                 +-------------+     </span><br><span class="line">                  |                                 +------------------+</span><br><span class="line">                  +--------------------------------&gt;| wait list count  |</span><br><span class="line">                                                    +------------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="keyword">int64</span> <span class="comment">// 开始等待锁的时间点</span></span><br><span class="line">    starving := <span class="literal">false</span> <span class="comment">// 当前 goroutine 是否处于饥饿状态</span></span><br><span class="line">    awoke := <span class="literal">false</span>    <span class="comment">// 当前 goroutine 是否被唤醒</span></span><br><span class="line">    iter := <span class="number">0</span>         <span class="comment">//</span></span><br><span class="line">    old := m.state    <span class="comment">// 当前锁的状态</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// Don't spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">        <span class="comment">// so we won't be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">// 饥饿模式不要自旋， 因为锁的所有权回直接交给 waiters, 所以我们不会获取到锁</span></span><br><span class="line">        <span class="comment">// 条件翻译为伪代码: isLocked() &amp;&amp; isNotStarving() &amp;&amp; canSpin() </span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// Active spinning makes sense.</span></span><br><span class="line">            <span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">            <span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">            <span class="comment">//  尝试设置 mutexWoken  标志来通知 Unlock 不唤醒其它被阻塞的 goroutine</span></span><br><span class="line">            <span class="comment">//  条件可以转换为: 当前 goroutine 没有被唤醒     &amp;&amp; </span></span><br><span class="line">                                锁状态没有被唤醒              &amp;&amp; </span><br><span class="line">                                等待获取锁的 goroutine 不为 <span class="number">0</span> &amp;&amp; </span><br><span class="line">                                锁的状态改从未唤醒更新为 被唤醒</span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span> <span class="comment">// 设置当前 goroutine 为唤醒状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime_doSpin() <span class="comment">// 进入自旋</span></span><br><span class="line">            iter++</span><br><span class="line">            old = m.state <span class="comment">// 更新锁状态</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 经过上一步后，锁和状态的组合有下面几个:</span></span><br><span class="line">        <span class="comment">// 获取锁   + 正常模式</span></span><br><span class="line">        <span class="comment">// 获取锁   + 饥饿模式</span></span><br><span class="line">        <span class="comment">// 未获取锁 + 正常模式</span></span><br><span class="line">        <span class="comment">// 未获取锁 + 饥饿模式</span></span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// Don't try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">// 正常模式: 期望设置为获取锁</span></span><br><span class="line">        <span class="comment">// 如果是饥饿模式, 新来的 goroutine 必须放到锁队列尾部排队</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (锁被获取 || 饥饿模式): 等待锁的 goroutine 数量 +1</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">        <span class="comment">// But if the mutex is currently unlocked, don't do the switch.</span></span><br><span class="line">        <span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">        <span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">// 当前 gorutine 是（饥饿状态 &amp;&amp; 锁被获取): 期望设置锁状态为饥饿模式</span></span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 goroutine 处于被唤醒状态</span></span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">            <span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">            <span class="comment">// 如果锁状态为被唤醒状态，证明存在冲突</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  new 期望设置为非被唤醒状态</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新锁状态为  从 old 变为 new</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// old 原来锁状态不是被获取 &amp;&amp; 锁状态不是饥饿状态</span></span><br><span class="line">            <span class="comment">// 根据前面的条件 new 现在是获取锁状态</span></span><br><span class="line">            <span class="comment">// old 和 new 交换成功，所以当前 goroutine 获取到了锁, 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到这里: old 是被获取 || old 是饥饿状态</span></span><br><span class="line">            <span class="comment">// waitStartTime != 0 证明等待过, 否则未等待过</span></span><br><span class="line">            <span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span> <span class="comment">// true or false</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果等待过则放到锁队列头</span></span><br><span class="line">            <span class="comment">// 否则放到锁队列尾部</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 如果等待时间超过了 starvationThresholdNs (1ms), 则设置当前 goroutine 为饥饿模式</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">// 如果原来处于饥饿模式</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">                <span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">                <span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">                <span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">                <span class="comment">// 如果当前 goroutine 处于饥饿模式, 但是 mutex出一些冲突的状态: mutexLocked 状态没有设置，当前 goroutine 仍处于 waiter 中</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">// 当前 goroutine 不是饥饿状态 || 等待的 gorouine == 1, 退出饥饿模式</span></span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="comment">// 退出饥饿模式</span></span><br><span class="line">                    <span class="comment">// Exit starvation mode.</span></span><br><span class="line">                    <span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">                    <span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">                    <span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">                    <span class="comment">// to starvation mode.</span></span><br><span class="line">                    delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  等待队列数量 -1 &amp;&amp;  获取锁</span></span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            old = m.state <span class="comment">// 更新 state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">        race.Acquire(unsafe.Pointer(m))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// Lock locks m.</span><br><span class="line">// If the lock is already in use, the calling goroutine</span><br><span class="line">// blocks until the mutex is available.</span><br><span class="line">func (m *Mutex) Lock() &#123;</span><br><span class="line">	// Fast path: grab unlocked mutex.</span><br><span class="line">	if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) &#123;</span><br><span class="line">		if race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var waitStartTime int64 // 用来存当前goroutine等待的时间</span><br><span class="line">	starving := false       // 用来存当前goroutine是否饥饿</span><br><span class="line">	awoke := false          // 用来存当前goroutine是否已唤醒</span><br><span class="line">	iter := 0               // 用来存当前goroutine的循环次数(想一想一个goroutine如果循环了2147483648次咋办……)</span><br><span class="line">	old := m.state          // 复制一下当前锁的状态</span><br><span class="line">	for &#123; // 自旋</span><br><span class="line">		// 如果是饥饿情况之下，就不要自旋了，因为锁会直接交给队列头部的goroutine</span><br><span class="line">		// 如果锁是被获取状态，并且满足自旋条件（canSpin见后文分析），那么就自旋等锁</span><br><span class="line">		// 伪代码：if isLocked() &amp;&amp; isNotStarving() &amp;&amp; canSpin()</span><br><span class="line">        // old&amp;(mutexLocked|mutexStarving) == mutexLocked  满足的条件为: (0x1) &amp; (101) ; 不满足的条件为: (1xx) &amp; (101) 或 (0x1) &amp;&amp; (101)</span><br><span class="line">		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			// 将自己的状态以及锁的状态设置为唤醒，这样当Unlock的时候就不会去唤醒其它被阻塞的goroutine了</span><br><span class="line">            // 自己为未唤醒状态, 锁状态为未唤醒, 等待锁的goroutine 数量不为0, 将锁状态从未唤醒更新为唤醒</span><br><span class="line">			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = true // 当前 goroutine 状态更新为唤醒</span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin() // 进行自旋(分析见后文)</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state // 更新锁的状态(有可能在自旋的这段时间之内锁的状态已经被其它goroutine改变)</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 当走到这一步的时候，可能会有以下的情况：</span><br><span class="line">		// 1. 锁被获取+ 饥饿</span><br><span class="line">		// 2. 锁被获取+ 正常</span><br><span class="line">		// 3. 锁空闲 + 饥饿</span><br><span class="line">		// 4. 锁空闲 + 正常</span><br><span class="line">		</span><br><span class="line">		// goroutine的状态可能是唤醒以及非唤醒</span><br><span class="line">		</span><br><span class="line">		// 复制一份当前的状态，目的是根据当前状态设置出期望的状态，存在new里面，</span><br><span class="line">		// 并且通过CAS来比较以及更新锁的状态</span><br><span class="line">		// old用来存锁的当前状态</span><br><span class="line">		new := old</span><br><span class="line"></span><br><span class="line">		// 如果说锁不是饥饿状态，就把期望状态设置为被获取(获取锁)</span><br><span class="line">		// 也就是说，如果是饥饿状态，就不要把期望状态设置为被获取</span><br><span class="line">		// 新到的goroutine乖乖排队去</span><br><span class="line">		// 伪代码：if isNotStarving()</span><br><span class="line">		if old&amp;mutexStarving == 0 &#123;</span><br><span class="line">			// 伪代码：newState = locked</span><br><span class="line">			new |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果锁是被获取状态，或者饥饿状态</span><br><span class="line">		// 就把期望状态中的等待队列的等待者数量+1(实际上是new + 8)</span><br><span class="line">		// (会不会可能有三亿个goroutine等待拿锁……)</span><br><span class="line">		if old&amp;(mutexLocked|mutexStarving) != 0 &#123;</span><br><span class="line">			new += 1 &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果说当前的goroutine是饥饿状态，并且锁被其它goroutine获取</span><br><span class="line">		// 那么将期望的锁的状态设置为饥饿状态</span><br><span class="line">		// 如果锁是释放状态，那么就不用切换了</span><br><span class="line">		// Unlock期望一个饥饿的锁会有一些等待拿锁的goroutine，而不只是一个</span><br><span class="line">		// 这种情况下不会成立</span><br><span class="line">		if starving &amp;&amp; old&amp;mutexLocked != 0 &#123;</span><br><span class="line">			// 期望状态设置为饥饿状态</span><br><span class="line">			new |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果说当前goroutine是被唤醒状态，我们需要reset这个状态</span><br><span class="line">		// 因为goroutine要么是拿到锁了，要么是进入sleep了</span><br><span class="line">		if awoke &#123;</span><br><span class="line">			// 如果说期望状态不是woken状态，那么肯定出问题了</span><br><span class="line">			// 这里看不懂没关系，wake的逻辑在下面</span><br><span class="line">			if new&amp;mutexWoken == 0 &#123;</span><br><span class="line">				throw(&quot;sync: inconsistent mutex state&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">			// 这句就是把new设置为非唤醒状态</span><br><span class="line">			// &amp;^的意思是and not</span><br><span class="line">			new &amp;^= mutexWoken</span><br><span class="line">		&#125;</span><br><span class="line">		// 通过CAS来尝试设置锁的状态</span><br><span class="line">		// 这里可能是设置锁，也有可能是只设置为饥饿状态和等待数量</span><br><span class="line">		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) &#123;</span><br><span class="line">			// 如果说old状态不是饥饿状态也不是被获取状态</span><br><span class="line">			// 那么代表当前goroutine已经通过CAS成功获取了锁</span><br><span class="line">			// (能进入这个代码块表示状态已改变，也就是说状态是从空闲到被获取)</span><br><span class="line">			if old&amp;(mutexLocked|mutexStarving) == 0 &#123;</span><br><span class="line">				break // locked the mutex with CAS</span><br><span class="line">			&#125;</span><br><span class="line">			// 如果之前已经等待过了，那么就要放到队列头</span><br><span class="line">			queueLifo := waitStartTime != 0</span><br><span class="line">			// 如果说之前没有等待过，就初始化设置现在的等待时间</span><br><span class="line">			if waitStartTime == 0 &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">			// 既然获取锁失败了，就使用sleep原语来阻塞当前goroutine</span><br><span class="line">			// 通过信号量来排队获取锁</span><br><span class="line">			// 如果是新来的goroutine，就放到队列尾部</span><br><span class="line">			// 如果是被唤醒的等待锁的goroutine，就放到队列头部</span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line">			</span><br><span class="line">			// 这里sleep完了，被唤醒</span><br><span class="line">			</span><br><span class="line">			// 如果当前goroutine已经是饥饿状态了</span><br><span class="line">			// 或者当前goroutine已经等待了1ms（在上面定义常量）以上</span><br><span class="line">			// 就把当前goroutine的状态设置为饥饿</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			// 再次获取一下锁现在的状态</span><br><span class="line">			old = m.state</span><br><span class="line">			// 如果说锁现在是饥饿状态，就代表现在锁是被释放的状态，当前goroutine是被信号量所唤醒的</span><br><span class="line">			// 也就是说，锁被直接交给了当前goroutine</span><br><span class="line">			if old&amp;mutexStarving != 0 &#123;</span><br><span class="line">				// 如果说当前锁的状态是被唤醒状态或者被获取状态，或者说等待的队列为空</span><br><span class="line">				// 那么是不可能的，肯定是出问题了，因为当前状态肯定应该有等待的队列，锁也一定是被释放状态且未唤醒</span><br><span class="line">				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 &#123;</span><br><span class="line">					throw(&quot;sync: inconsistent mutex state&quot;)</span><br><span class="line">				&#125;</span><br><span class="line">				// 当前的goroutine获得了锁，那么就把等待队列-1</span><br><span class="line">				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)</span><br><span class="line">				// 如果当前goroutine非饥饿状态，或者说当前goroutine是队列中最后一个goroutine</span><br><span class="line">				// 那么就退出饥饿模式，把状态设置为正常</span><br><span class="line">				if !starving || old&gt;&gt;mutexWaiterShift == 1 &#123;</span><br><span class="line">					// Exit starvation mode.</span><br><span class="line">					// Critical to do it here and consider wait time.</span><br><span class="line">					// Starvation mode is so inefficient, that two goroutines</span><br><span class="line">					// can go lock-step infinitely once they switch mutex</span><br><span class="line">					// to starvation mode.</span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				// 原子性地加上改动的状态</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			// 如果锁不是饥饿模式，就把当前的goroutine设为被唤醒</span><br><span class="line">			// 并且重置iter(重置spin)</span><br><span class="line">			awoke = true</span><br><span class="line">			iter = 0</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 如果CAS不成功，也就是说没能成功获得锁，锁被别的goroutine获得了或者锁一直没被释放</span><br><span class="line">			// 那么就更新状态，重新开始循环尝试拿锁</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>