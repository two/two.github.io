<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>golang http client 连接池 | OohCode | ooh my code</title>

  
  <meta name="author" content="sean chen">
  

  
  <meta name="description" content="golang标准库net/http做为client时有哪些细节需要注意呢，这里做一个详细的分析。

net/http client工作流程首先分析一下client的工作流程。 下面是一般我们进行一个请求时的代码事例:
123456789101112131415161718192021func DoR">
  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="golang http client 连接池">

  <meta property="og:site_name" content="OohCode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="OohCode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">OohCode</a>
    </h1>
    <p class="site-description">ooh my code</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>golang http client 连接池</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/01/golang-http-client-connection-pool/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-01T02:44:03.000Z">
          2018-06-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>golang标准库<code>net/http</code>做为<code>client</code>时有哪些细节需要注意呢，这里做一个详细的分析。</p>
</blockquote>
<h2 id="net-http-client工作流程"><a href="#net-http-client工作流程" class="headerlink" title="net/http client工作流程"></a>net/http client工作流程</h2><p>首先分析一下<code>client</code>的工作流程。 下面是一般我们进行一个请求时的代码事例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoRequest</span><span class="params">(req *http.Request)</span> <span class="params">(MyResponse, error)</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response := MyResponse&#123;&#125;</span><br><span class="line">    response.Header = resp.Header</span><br><span class="line">    ...</span><br><span class="line">    response.Body = body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们首先创建一个<code>http.Client</code>, 所有的值都是默认值，然后调用<code>client.Do</code>发请求，<code>req</code>是我们请求的结构体。这里我们也可以用<code>client.Get</code>, <code>client.Post</code>等函数来调用，从他们的源码来看都是调用的<code>client.Do</code>。<br><code>client.Do</code>的实现在<code>net/http</code>包的<code>go/src/net/http/client.go</code>源文件中。可以看到函数内部主要是实现了一些参数检查，默认值设置，以及对于多跳请求的处理，最为核心的就是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// c.send() always closes req.Body</span></span><br><span class="line">            reqBodyClosed = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">                err = &amp;httpError&#123;</span><br><span class="line">                    err:     err.Error() + <span class="string">" (Client.Timeout exceeded while awaiting headers)"</span>,</span><br><span class="line">                    timeout: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shouldRedirect <span class="keyword">bool</span></span><br><span class="line">redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !shouldRedirect &#123;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里真正发请求的函数就是<code>c.send</code>, 这个函数的实现也比较简单, 主要是调用了<code>send</code>函数，这个函数的实现主要如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// didTimeout is non-nil only if err != nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send issues an HTTP request.</span></span><br><span class="line"><span class="comment">// Caller should close resp.Body when done reading from it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line">    ...</span><br><span class="line">        resp, err = rt.RoundTrip(req)</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里真正进行网络交互的定位到的函数是<code>rt.RoundTrip</code>,这个函数的定义是一个<code>interface</code>，从其注释也可以看出他的主要作用是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// RoundTrip executes a single HTTP transaction, returning</span><br><span class="line">// a Response for the provided Request.`</span><br></pre></td></tr></table></figure></p>
<p>由于这个函数是一个<code>interface</code>我们需要知道是谁实现了这个函数，看一下<code>send</code>的参数就可以找到，实现这个函数的是<code>c.transport()</code>的返回值，这个函数的实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到，返回的对象是<code>c.Transport</code>或者<code>DefaultTransport</code>, 由于我们创建<code>client</code>的时候没有设置<code>c.Transport</code>参数，所以这里返回的应该是<code>DefaultTransport</code>对象, 这个对象对<code>RoundTripper</code>函数的实现大概如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip implements the RoundTripper interface.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For higher-level HTTP client support (such as handling of cookies</span></span><br><span class="line"><span class="comment">// and redirects), see Get, Post, and the Client type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">                pconn, err := t.getConn(treq, cm)</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// HTTP/2 path.</span></span><br><span class="line">                    t.setReqCanceler(req, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">                        resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp, err = pconn.roundTrip(treq)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面具体的细节我们先不关系，对于<code>HTTP/2</code>的处理我们也先不关心。这里需要重点关注的是<code>t.getConn</code>这个函数。<code>t.getConn</code>的作用是获取一个链接，这个链接该怎么获取，是一个值得深究的问题。下面看一下这个函数的关键实现细节:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getConn dials and creates a new persistConn to the target as</span></span><br><span class="line"><span class="comment">// specified in the connectMethod. This includes doing a proxy CONNECT</span></span><br><span class="line"><span class="comment">// and/or setting up TLS.  If this doesn't return an error, the persistConn</span></span><br><span class="line"><span class="comment">// is ready to write requests to.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">req := treq.Request</span><br><span class="line">         trace := treq.trace</span><br><span class="line">         ctx := req.Context()</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GetConn(cm.addr())</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">if</span> pc, idleSince := t.getIdleConn(cm); pc != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GotConn(pc.gotIdleConnTrace(idleSince))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// set request canceler to some non-nil function so we</span></span><br><span class="line">         <span class="comment">// can detect whether it was cleared between now and when</span></span><br><span class="line">         <span class="comment">// we enter roundTrip</span></span><br><span class="line">         t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;&#125;)</span><br><span class="line">             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">         handlePendingDial := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             testHookPrePendingDial()</span><br><span class="line">                 <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> v := &lt;-dialc; v.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                         t.putOrCloseIdleConn(v.pc)</span><br><span class="line">                     &#125;</span><br><span class="line">                     testHookPostPendingDial()</span><br><span class="line">                 &#125;()</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">cancelc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">             t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123; cancelc &lt;- err &#125;)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                 pc, err := t.dialConn(ctx, cm)</span><br><span class="line">                     dialc &lt;- dialRes&#123;pc, err&#125;</span><br><span class="line">             &#125;()</span><br><span class="line">idleConnCh := t.getIdleConnCh(cm)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> v := &lt;-dialc:</span><br><span class="line">                            <span class="comment">// Our dial finished.</span></span><br><span class="line">                            <span class="keyword">if</span> v.pc != <span class="literal">nil</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &amp;&amp; v.pc.alt == <span class="literal">nil</span> &#123;</span><br><span class="line">                                    trace.GotConn(httptrace.GotConnInfo&#123;Conn: v.pc.conn&#125;)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> v.pc, <span class="literal">nil</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Our dial failed. See why to return a nicer error</span></span><br><span class="line">                            <span class="comment">// value.</span></span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                    <span class="comment">// It was an error due to cancelation, so prioritize that</span></span><br><span class="line">                                    <span class="comment">// error value. (Issue 16049)</span></span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                                <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                                          <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                              err = errRequestCanceledConn</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                              <span class="comment">// It wasn't an error due to cancelation, so</span></span><br><span class="line">                                              <span class="comment">// return the original error message:</span></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">nil</span>, v.err</span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="keyword">case</span> pc := &lt;-idleConnCh:</span><br><span class="line">                             <span class="comment">// Another request finished first and its net.Conn</span></span><br><span class="line">                             <span class="comment">// became available before our dial. Or somebody</span></span><br><span class="line">                             <span class="comment">// else's dial that they didn't use.</span></span><br><span class="line">                             <span class="comment">// But our dial is still going, so give it away</span></span><br><span class="line">                             <span class="comment">// when it finishes:</span></span><br><span class="line">                             handlePendingDial()</span><br><span class="line">                                 <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">                                     trace.GotConn(httptrace.GotConnInfo&#123;Conn: pc.conn, Reused: pc.isReused()&#125;)</span><br><span class="line">                                 &#125;</span><br><span class="line">                             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                 handlePendingDial()</span><br><span class="line">                                     <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                     handlePendingDial()</span><br><span class="line">                                         <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                    <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                              handlePendingDial()</span><br><span class="line">                                  <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                      err = errRequestCanceledConn</span><br><span class="line">                                  &#125;</span><br><span class="line">                              <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是这个过程的流程图:<br><img src="http://www.plantuml.com/plantuml/svg/NP3DYi8m58NNvYcohA-WIv-as5I39HbCD-vcm9_IHHsm54P1Pa2NC-fcb2deopHf-XRUDjQ1XcnoxpddVhd2jyS-eYwsiZJIjwsAzkhqgQEpN2R5wWhFDlQ7X65hGaGROJWTVOlbPckwNKGyGR35UDbq-NY4MXqPR6JwfvAZ2UmQcmf3ur7nLGR7_EUhU5ivrFRwsUNxeG68kc8O_XFAR6mFRCfW0kYCdpeUwN76UiE6HGPhkCKYX6dvUbhJrYG0PoYXz_XsHVLSWGeI_JhhUroGnlGgGiv-ipGfuWzzECZTD7-Vboh27BC3KE36cfX3NIHy_d87"><br>从上面可以看到，获取链接会优先从连接池中获取，如果连接池中没有可用的连接，则会创建一个连接或者从刚刚释放的连接中获取一个，这两个过程时同时进行的，谁先获取到连接就用谁的。<br>当新创建一个连接, 创建连接的函数定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error)</span><br></pre></td></tr></table></figure></p>
<p>最后这个函数会通过goroutine调用两个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go pconn.readLoop()</span><br><span class="line">go pconn.writeLoop()</span><br></pre></td></tr></table></figure></p>
<p>其中<code>readLoop</code>主要是读取从server返回的数据,<code>writeLoop</code>主要发送请求到server,在<code>readLoop</code>函数中有这么一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Put the idle conn back into the pool before we send the response</span><br><span class="line">// so if they process it quickly and make another request, they&apos;ll</span><br><span class="line">// get this same conn. But we use the unbuffered channel &apos;rc&apos;</span><br><span class="line">// to guarantee that persistConn.roundTrip got out of its select</span><br><span class="line">// potentially waiting for this persistConn to close.</span><br><span class="line">// but after</span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">    pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br></pre></td></tr></table></figure></p>
<p>这里可以看出，在处理完请求后，会立即把当前连接放到连接池中。</p>
<p>上面说到连接池，每个<code>client</code>的连接池结构是这样的:<code>idleConn   map[connectMethodKey][]*persistConn</code>。其中<code>connectMethodKey</code>的值就是<code>client</code>连接的server的<code>host</code>值, map的值是一个<code>*persistConn</code>类型的<code>slice</code>结构，这里就是存放连接的地方，<code>slice</code>的长度由<code>MaxIdleConnsPerHost</code>这个值指定的，当我们不设置这个值的时候就取默认的设置:<code>const DefaultMaxIdleConnsPerHost = 2</code>。</p>
<p>另外这里我们插一个知识点，对于HTTP协议，有一个header值”Connections”, 这个值的作用就是<code>client</code>向<code>server</code>端发请求的时候，告诉<code>server</code>是否要保持连接。具体的可以参考<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank" rel="noopener">rfc2616</a>。 这个协议头的值有两种可能(参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">MDN文档</a>):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p>
<p>当值为<code>keep-alive</code>时，<code>server</code>端会保持连接，一直到连接超时。当值为<code>close</code>时,<code>server</code>端会在传输完<code>response</code>后主动断掉<code>TCP</code>连接。在<code>HTTP/1.1</code>之前，这个值默认是<code>close</code>, 之后是默认<code>keep-alive</code>, 而<code>net/http</code>默认的协议是<code>HTTP/1.1</code>也就是默认<code>keep-alive</code>, 这个值可以通过<code>DisableKeepAlives</code>来设置。</p>
<p>从上面的介绍我们可以看出，<code>net/http</code>默认是连接复用的，对于每个server会默认的连接池大小是2。<br>接下来我们看一下连接是如何放进连接池的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">putOrCloseIdleConn</span><span class="params">(pconn *persistConn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span></span><br><span class="line"><span class="comment">// a new request.</span></span><br><span class="line"><span class="comment">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span></span><br><span class="line"><span class="comment">// an error explaining why it wasn't registered.</span></span><br><span class="line"><span class="comment">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errKeepAlivesDisabled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.isBroken() &#123;</span><br><span class="line">        <span class="keyword">return</span> errConnBroken</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errNotCachingH2Conn</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.markReused()</span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line"></span><br><span class="line">    t.idleMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> t.idleMu.Unlock()</span><br><span class="line">    waitingDialer := t.idleConnCh[key]</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> waitingDialer &lt;- pconn:</span><br><span class="line">        <span class="comment">// We're done with this pconn and somebody else is</span></span><br><span class="line">        <span class="comment">// currently waiting for a conn of this type (they're</span></span><br><span class="line">        <span class="comment">// actively dialing, but this conn is ready</span></span><br><span class="line">        <span class="comment">// first). Chrome calls this socket late binding. See</span></span><br><span class="line">        <span class="comment">// https://insouciant.org/tech/connection-management-in-chromium/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> waitingDialer != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// They had populated this, but their dial won</span></span><br><span class="line">            <span class="comment">// first, so we can clean up this map entry.</span></span><br><span class="line">            <span class="built_in">delete</span>(t.idleConnCh, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.wantIdle &#123;</span><br><span class="line">        <span class="keyword">return</span> errWantIdle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.idleConn == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.idleConn = <span class="built_in">make</span>(<span class="keyword">map</span>[connectMethodKey][]*persistConn)</span><br><span class="line">    &#125;</span><br><span class="line">    idles := t.idleConn[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(idles) &gt;= t.maxIdleConnsPerHost() &#123;</span><br><span class="line">        <span class="keyword">return</span> errTooManyIdleHost</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, exist := <span class="keyword">range</span> idles &#123;</span><br><span class="line">        <span class="keyword">if</span> exist == pconn &#123;</span><br><span class="line">            log.Fatalf(<span class="string">"dup idle pconn %p in freelist"</span>, pconn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    t.idleLRU.add(pconn)</span><br><span class="line">    <span class="keyword">if</span> t.MaxIdleConns != <span class="number">0</span> &amp;&amp; t.idleLRU.<span class="built_in">len</span>() &gt; t.MaxIdleConns &#123;</span><br><span class="line">        oldest := t.idleLRU.removeOldest()</span><br><span class="line">        oldest.<span class="built_in">close</span>(errTooManyIdle)</span><br><span class="line">        t.removeIdleConnLocked(oldest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IdleConnTimeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pconn.idleTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">            pconn.idleTimer.Reset(t.IdleConnTimeout)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.idleAt = time.Now()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会尝试把连接放入到连接池中，如果不成功则<code>关闭连接</code>,大致流程如下:<br><img src="http://www.plantuml.com/plantuml/svg/XP5FJy8m6CRl-nGzmispauEHWyQO-1LgU8UDIsVMuf-4WqOM5rHYuX914m864gC1528I8F9brcux-HMS82Cxg3sqJVi-lxvF7yQnoHMYeKIQCBoZmoR0_gfE3e2XL0fnCmSedqTR-6WZeyEQGIdR1dFTO1ojeAKauhj0KU8OM591uLWMLY-uRVcJgYmrLGLq1YX1ZVcbVIz6GtTmuWwUl7OzEBqvn8GJcaqJh8FfEO_ki1GAfTFtdY_4LIyuBqhdmxih-6y5ERnMqPIZ6URUT3E5kkEoi6nPBCuU3Uk5rHJsImpj3bhgGX9lSduCD1FX4SvYGXUA36WuftDXru9A8qRs9vN8pUVuCYXtPUiXA8z4lQh-YXDMNxJF0gVYTpgXwEz-mZLo_1tKZy_NcdZlob7zlmnYg7WUix-AU54jqPHe_W80"><br>如果<code>DisableKeepAlives</code>为<code>true</code>表示不使用连接复用，所以请求完后会把连接关掉，但是这里需要注意的是，同时发请求的时候我们会设置<code>Connections: close</code>, 所以<code>server</code>端发送完数据后就会自动断开，所以这种情况的连接其实是<code>server</code>端发起的。</p>
<h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>前面我们已经讲过<code>net/http</code>默认使用<code>HTTP/1.1</code>协议，也就是默认发送<code>Connections: keep-alive</code>的头，让服务端保持连接，就是所谓的长连接。<br>再看<code>DefaultTransport</code>的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// DefaultTransport is the default implementation of Transport and is</span><br><span class="line">// used by DefaultClient. It establishes network connections as needed</span><br><span class="line">// and caches them for reuse by subsequent calls. It uses HTTP proxies</span><br><span class="line">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and</span><br><span class="line">// $no_proxy) environment variables.</span><br><span class="line">var DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment, //代理使用</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   30 * time.Second, //连接超时时间</span><br><span class="line">        KeepAlive: 30 * time.Second, //连接保持超时时间</span><br><span class="line">        DualStack: true, //</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    MaxIdleConns:          100, //client对与所有host最大空闲连接数总和</span><br><span class="line">    IdleConnTimeout:       90 * time.Second, //空闲连接在连接池中的超时时间</span><br><span class="line">    TLSHandshakeTimeout:   10 * time.Second, //TLS安全连接握手超时时间</span><br><span class="line">    ExpectContinueTimeout: 1 * time.Second, //发送完请求到接收到响应头的超时时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用<code>DefaultTransport</code>时，就是默认使用的长连接。但是默认的连接池<code>MaxIdleConns</code>为100， <code>MaxIdleConnsPerHost</code>为2，当超出这个范围时，客户端会主动关闭到连接。<br>如果我们想设置为短连接，有几种方法:</p>
<ol>
<li>设置<code>DisableKeepAlives = true</code>: 这时就会发送<code>Connections:close</code>给server端，在server端响应后就会主动关闭连接。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>: 当<code>MaxIdleConnsPerHost &lt; 0</code>时，连接池是无法放置空闲连接的，所以无法复用,连接直接会在<code>client</code>端被关闭。</li>
</ol>
<h2 id="Server端出现大量的TIME-WAIT"><a href="#Server端出现大量的TIME-WAIT" class="headerlink" title="Server端出现大量的TIME_WAIT"></a>Server端出现大量的<code>TIME_WAIT</code></h2><p>当我们在实际使用时，会发现<code>Server</code>端出现了大量的<code>TIME_WAIT</code>,要想深入了解其原因，我们首先先回顾一下<code>TCP</code>三次握手和四次分手的过程:<br><img src="/assets/img/golang/tcp_3_handshake.png" alt><br><img src="/assets/img/golang/tcp_4_handshake.png" alt><br>图中可以看出，<code>TIME_WAIT</code>只会出现在主动关闭连接的一方,也就是<code>server</code>端出现了大量的主动关闭行为。<br>默认我们是使用长连接的，只有在超时的情况下<code>server</code>端才会主动关闭连接。前面也讲到，如果超出连接池的部分就会在<code>client</code>端主动关闭连接，连接池的连接会复用，看着似乎没有什么问题。问题出在我们每次请求都会<code>new</code>一个新的<code>client</code>,这样每个<code>client</code>的连接池里的连接并没有得到复用，而且这时<code>client</code>也不会主动关闭这个连接，所以<code>server</code>端出现了大量的<code>keep-alive</code>但是没有请求的连接，就会主动发起关闭。</p>
<p>todo:补充tcpdump的分析结果</p>
<p>要解决这个问题以下几个方案:</p>
<ol>
<li><code>client</code>复用，也就是我们尽量复用<code>client</code>，来保证<code>client</code>连接池里面的连接得到复用，而减少出现超时关闭的情况。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>：这样每次请求后都会由<code>client</code>发起主动关闭连接的请求，<code>server</code>端就不会出现大量的<code>TIME_WAIT</code></li>
<li><p>修改<code>server</code>内核参数: 当出现大量的<code>TIME_WAIT</code>时危害就是导致<code>fd</code>不够用,无法处理新的请求。我们可以通过设置<code>/etc/sysctl.conf</code>文件中的</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>
<p> 达到快速回收和重用的效果，不影响其对新连接的处理。</p>
</li>
</ol>
<p>另外需要注意的是，虽然<code>DisableKeepAlives = true</code>也能满足连接池中不放空闲连接，但是这时候会发送<code>Connections: close</code>，这时<code>server</code>端还是会主动关闭连接，导致大量的<code>TIME_WAIT</code>出现，所以这种方法行不通。</p>
<p>以上就是我总结的关于<code>net/http</code>中连接池相关的知识。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>