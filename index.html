<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>OohCode | ooh my code</title>

  
  <meta name="author" content="sean chen">
  

  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="OohCode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="OohCode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">OohCode</a>
    </h1>
    <p class="site-description">ooh my code</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/06/Dependency-inversion-principle-in-Go/"><span>Dependency inversion principle in Go</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/06/Dependency-inversion-principle-in-Go/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-06T06:54:25.000Z">
          2019-06-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="依赖反转原则在Go中使用"><a href="#依赖反转原则在Go中使用" class="headerlink" title="依赖反转原则在Go中使用"></a>依赖反转原则在Go中使用</h1><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a>有五个，分别是:</p>
<table>
<thead>
<tr>
<th>首字母</th>
<th>指代</th>
<th>概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>单一功能原则</td>
<td>认为对象应该仅具有一种单一功能的概念。</td>
</tr>
<tr>
<td>O</td>
<td>开闭原则</td>
<td>认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>
</tr>
<tr>
<td>L</td>
<td>里氏替换原则</td>
<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。  参考契约式设计。</td>
</tr>
<tr>
<td>I</td>
<td>接口隔离原则</td>
<td>认为“多个特定客户端接口要好于一个宽泛用途的接口” 的概念。</td>
</tr>
<tr>
<td>D</td>
<td>依赖反转原则</td>
<td>认为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。 依赖注入是该原则的一种实现方式。</td>
</tr>
</tbody>
</table>
<p>这五个原则简称: <code>SOLID</code>。<br>在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。<br>该原则规定：</p>
<ul>
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li>
</ul>
<p>该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。</p>
<p>在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。这种对于低层次组件的依赖限制了高层次组件被重用的可行性。</p>
<p>依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和低层组件划分到不同的包/库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。众多的设计模式，比如插件，服务定位器或者依赖反转，则被用来在运行时把指定的低层组件实现提供给高层组件。</p>
<p>应用依赖反转原则同样被认为是应用了<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">适配器模式</a>，例如：高层的类定义了它自己的适配器接口（高层类所依赖的抽象接口）。被适配的对象同样依赖于适配器接口的抽象（这是当然的，因为它实现了这个接口），同时它的实现则可以使用它自身所在低层模块的代码。通过这种方式，高层组件则不依赖于低层组件，因为它（高层组件）仅间接的通过调用适配器接口多态方法使用了低层组件，而这些多态方法则是由被适配对象以及它的低层模块所实现的。</p>
<blockquote>
<p><strong>前面一大堆其实都是从wiki上copy过来的，自己的理解有以下几点:</strong></p>
<ul>
<li>上层指<strong>调用者</strong>, 下层指<strong>被调用者</strong></li>
<li>原来的编程方式是上层调用下层的时候依赖下层具体的实现方式</li>
<li>依赖反转（或叫:依赖倒置)是指下层的实现依赖上层调用的需求</li>
<li>最终的解决方式是: 把上层的需求抽象成接口，上层依赖接口的抽象进行调用，下层依赖接口的抽象进行实现(下面要介绍的<strong>面相接口编程</strong>)</li>
</ul>
</blockquote>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a>是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</p>
<blockquote>
<p><strong>上面这段也是wiki上的, 自己理解:</strong></p>
<ul>
<li>依赖注入就是: 把下层依赖注入(或叫传递)到上层调用</li>
<li>要把提供服务的一方(也就是前面说的: 下层)作为实例传递给客户端(即:上层)</li>
<li>不要客户端在内部自己实现服务端的实例化。</li>
<li>这种方式的好处是: 可以通过传递不同的实例化对象来实现多态。</li>
</ul>
</blockquote>
<h3 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a>是前面实现依赖反转原则的具体方式。<br>基于接口的编程将应用程序定义为组件的集合，其中组件间的应用程序接口（API）调用可能只通过抽象化接口完成，而没有具体的类。类的实例化一般通过使用如<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener">工厂模式</a>等技术的其他接口完成。</p>
<blockquote>
<p><strong>这里也说一点自己的理解:</strong><br>上面说到要通过依赖注入方式传递实例，这个实例如何生成呢？如果每次都生成一个，如果这个实例是有状态的，那么每个拿到的可能都是不一样的，这样就<strong>无法共享</strong>。所以一般都是通过工厂模式产生一个实例，其他调用方要共享的话都通过这个工厂拿到<strong>同一个实例</strong>。</p>
</blockquote>
<p>另一种定义描述: 在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类</p>
<h4 id="面向接口编程和面向对象编程是什么关系"><a href="#面向接口编程和面向对象编程是什么关系" class="headerlink" title="面向接口编程和面向对象编程是什么关系:"></a>面向接口编程和面向对象编程是什么关系:</h4><p>首先，面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。</p>
<h4 id="接口的本质"><a href="#接口的本质" class="headerlink" title="接口的本质"></a>接口的本质</h4><h5 id="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"><a href="#接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念" class="headerlink" title="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"></a>接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念</h5><p>例如，在自然界中，人都能吃饭，即“如果你是人，则必须能吃饭”。那么模拟到计算机程序中，就应该有一个Person接口，并有一个方法叫Eat()，然后我们规定，每一个表示“人”的类，必须实现Person接口，这就模拟了自然界“如果你是人，则必须能吃饭”这条规则。</p>
<p>从这里，我想各位也能看到些许面向对象思想的东西。面向对象思想的核心之一，就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。</p>
<h5 id="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"><a href="#接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同" class="headerlink" title="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"></a>接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同</h5><p>例如，在我的眼里，我是一个人，和一头猪有本质区别，我可以接受我和我同学是同类这个说法，但绝不能接受我和一头猪是同类。但是，如果在一个动物学家眼里，我和猪应该是同类，因为我们都是动物，他可以认为“人”和“猪”都实现了Animal这个接口，而他在研究动物行为时，不会把我和猪分开对待，而会从“动物”这个较大的粒度上研究，但他会认为我和一棵树有本质区别。</p>
<h4 id="面相接口编程的优点"><a href="#面相接口编程的优点" class="headerlink" title="面相接口编程的优点"></a>面相接口编程的优点</h4><ul>
<li>首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。</li>
<li>使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工。</li>
</ul>
<blockquote>
<p><strong>关于面相接口编程的归纳:</strong></p>
<ul>
<li>面相接口是面向对象编程的重要部分</li>
<li>接口本质上是一组规则的集合，是一定粒度上有相同特指的对象的的抽象</li>
<li>面相接口编程可以提高编程的灵活性, 可以并行开发。</li>
</ul>
</blockquote>
<h2 id="Go-中的应用"><a href="#Go-中的应用" class="headerlink" title="Go 中的应用"></a>Go 中的应用</h2><h3 id="Go-中的接口"><a href="#Go-中的接口" class="headerlink" title="Go 中的接口"></a>Go 中的接口</h3><p>Go语言中，接口(interface)有其特殊的地方, 其他的语言一般要实现一个接口都需要显示的说明<br>例如<code>PHP</code>(这里没有贬低PHP的意思，大多数语言也是这种实现方式例如<code>C++</code>, <code>Python</code>, <code>Rust</code>等):<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare the interface 'iTemplate'</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the interface</span></span><br><span class="line"><span class="comment">// This will work</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span> <span class="keyword">implements</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $vars = <span class="keyword">array</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vars[$name] = $var;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;vars <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">            $template = str_replace(<span class="string">'&#123;'</span> . $name . <span class="string">'&#125;'</span>, $value, $template);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> $template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用到关键字 <code>implements</code>。<br>todo: 对比优缺点</p>
<p>而<code>Go</code>语言中，<code>interface</code>是<code>duck typing</code>(鸭子类型: If it looks like a duck, and it quacks like a duck, then it is a duck), 也就是如果一个对象实现了某个接口的方法，那么这个对象就是这个接口类型了，不需要显示说明是否实现了某个接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Speaker types can say things.</span></span><br><span class="line"><span class="keyword">type</span> Speaker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Say(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person is a strut with filed name</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Say funciton is defined by Speaker and implement by Person</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Say</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  log.Println(p.name+<span class="string">":"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>Person</code>实现了函数<code>Say</code>, 所以<code>Person</code>就是<code>Speaker</code>类型了。</p>
<h3 id="Go-中面相接口编程"><a href="#Go-中面相接口编程" class="headerlink" title="Go 中面相接口编程"></a>Go 中面相接口编程</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="自己的实现"><a href="#自己的实现" class="headerlink" title="自己的实现"></a>自己的实现</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a><br><a href="https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html" target="_blank" rel="noopener">面向接口编程详解（一）——思想基础</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://gocn.vip/article/1764" target="_blank" rel="noopener">使用Golang的interface接口设计原则</a><br><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d" target="_blank" rel="noopener">Duck typing in Go</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/05/28/go-scheduler-preemption/"><span>Go 调度器抢占方式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/05/28/go-scheduler-preemption/" rel="bookmark">
        <time class="entry-date published" datetime="2019-05-28T02:35:56.000Z">
          2019-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="OS-调度"><a href="#OS-调度" class="headerlink" title="OS 调度"></a>OS 调度</h2><h2 id="Go-调度"><a href="#Go-调度" class="headerlink" title="Go 调度"></a>Go 调度</h2><p>被抢占后把 g 状态从 <code>_Grunning</code> 改为 <code>_Grunnable</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">"bad g status"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">    dropg()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    globrunqput(gp)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Go-调度的问题"><a href="#Go-调度的问题" class="headerlink" title="Go 调度的问题"></a>Go 调度的问题</h2><h3 id="deadloop"><a href="#deadloop" class="headerlink" title="deadloop"></a>deadloop</h3><p>Go的抢占需要依赖函数的调用，只有在函数调用(准确的说是函数调用产生morestack调用的时候)的时候才会进行真正的强占，那么对于下面的这个方式:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个死循环，而且里面没有任何函数调用，也不会进行栈的扩张，所以这个goroutine永远不会被抢占。<br>参考<a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a> 这篇文档的说明，我们看一下具体的问题及解决方案。<br>// todo: 继续完善上篇文章中的例子</p>
<h3 id="deadloop-amp-GC"><a href="#deadloop-amp-GC" class="headerlink" title="deadloop &amp; GC"></a>deadloop &amp; GC</h3><p>还有这样一个<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">88</span> &#123;</span><br><span class="line">                runtime.GC()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// the wrong part</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">                sum += &lt;-ch</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序也会hang死。</p>
<p>下面这段代码在主goroutine中运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// the wrong part</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">            sum += &lt;-ch</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序由于没有函数的调用和<code>Goshced()</code>的主动调用所以会通过<code>阻塞监控</code>的方式被动弃权。</p>
<h4 id="runtime-GC"><a href="#runtime-GC" class="headerlink" title="runtime.GC"></a>runtime.GC</h4><p>当执行 <code>runtime.GC()</code>的时候都发生了什么？我们来看一下<br>通过<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">dlv</a>这个工具我们可以对这个程序进行断点调试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv debug go run gc.go</span><br></pre></td></tr></table></figure></p>
<p>函数会执行到 <code>stopTheWorldWithSema</code> 这个函数，这个函数主要作用是停止所有的P，然后进行垃圾回收，我们通过一步一步调试发现, 这个函数会下面这个循环中无法出来:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么会在这个地方无法出来？下面分析一下具体原因。</p>
<p>GC种一个步骤是要把所有的 p 都设置为<code>_Pgcstop</code> 状态后才能继续进行。 下面看看这个步骤是否能够完成。</p>
<p><code>stopTheWorldWithSema</code>函数更加详细的执行过程如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we hold a lock, then we won't be able to stop another M</span></span><br><span class="line">    <span class="comment">// that is blocked trying to acquire the lock.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"stopTheWorld: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.stopwait = gomaxprocs <span class="comment">// 设置stopwait的初始值为最大的 p 的个数</span></span><br><span class="line">    atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>) <span class="comment">// 设置 gcwaiting = 1, 表示正在进入GC状态</span></span><br><span class="line">    preemptall() <span class="comment">// 给所有的 p 发送抢占信号，如果成功，则对应的 p 进入 idle 状态</span></span><br><span class="line">    <span class="comment">// stop current P</span></span><br><span class="line">    _g_.m.p.ptr().status = _Pgcstop <span class="comment">// Pgcstop is only diagnostic.</span></span><br><span class="line">    sched.stopwait-- <span class="comment">// 给他当前的设置状态后，stopwait个数减一 </span></span><br><span class="line">    <span class="comment">// try to retake all P's in Psyscall status</span></span><br><span class="line">    <span class="comment">// 遍历所有的 p 如果满足条件(p的状态为 _Psyscall)则释放这个 p , 并且把 p 的状态都设置成 _Pgcstop ; 然后stopwait--</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := p.status</span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                traceGoSysBlock(p)</span><br><span class="line">                traceProcStop(p)</span><br><span class="line">            &#125;</span><br><span class="line">            p.syscalltick++</span><br><span class="line">            sched.stopwait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stop idle P's</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := pidleget() <span class="comment">//获取idle 状态的 p, 从 _Pidle list 获取</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        p.status = _Pgcstop <span class="comment">// 把 p 状态设置为 _Pgcstop</span></span><br><span class="line">        sched.stopwait-- <span class="comment">// 计数 stopwait --</span></span><br><span class="line">    &#125;</span><br><span class="line">    wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                noteclear(&amp;sched.stopnote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再次给所有的 p 发送 抢占信号</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面函数把所有非<code>_Prunning</code>状态的 p 都设置为了 <code>_Pgcstop</code> 状态，对于 <code>_Prunning</code> 状态的 p 如何设置其为 <code>_Pgcstop</code> 状态呢? 主要是通过 <code>preemptall()</code>函数给每个 p 发送抢占信号<br><code>preemptall()</code> 其实时调用了 <code>preemptone()</code> 前面我们已经讲了具体的原理。被抢占后 p 重新进入调度阶段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        stoplockedm()</span><br><span class="line">        execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不应该调度一个正在执行 cgo 调用的 g</span></span><br><span class="line">    <span class="comment">// 因为 cgo 在使用当前 m 的 g0 栈</span></span><br><span class="line">    <span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line">    <span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">        throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果还在等待 gc，则</span></span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top <span class="comment">// 循环执行</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面说调度器会会把 <code>gcwaiting</code>设置为<code>1</code>, 所以这里会进入 <code>gcstopm()</code>, 直到所有的 m 都被<code>stop</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcstopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"gcstopm: not waiting for gc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// OK to just drop nmspinning here,</span></span><br><span class="line">        <span class="comment">// startTheWorld will unpark threads as necessary.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"gcstopm: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _p_ := releasep()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    _p_.status = _Pgcstop <span class="comment">//设置 p 状态为 _Pgcstop</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">        notewakeup(&amp;sched.stopnote)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>gcstopm()</code> 会把 p 的状态置为 <code>_Pgcstop</code>。</p>
<p><strong>但是死循环的 g 不会被抢占，所以其 p 状态会一直是  Prunning 无法被设置为 Pgcstop</strong></p>
<p>再回到前面进入死循环的地方:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里进入死循环的原因是条件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) == <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>不满足<br><code>notetsleep</code>函数内部每隔一段时间就会返回:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> atomic.Load(key32(&amp;n.key)) != <span class="number">0</span> <span class="comment">// n.key 为参数 &amp;shced.stopnote.key的值</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数意思是<code>&amp;sched.stopnote.key != 0</code><br>如果要想让返回值为 <code>true</code> 就需要满足上面的条件。 <code>stopnote.key</code>的值有两个函数可以控制:</p>
<ul>
<li><code>notewakeup</code> 把 <code>stopnote</code> 设置为 1</li>
<li><code>noteclear 把</code>stopnote<code>设置为 0
所以我们需要调用</code>notewakeup<code>才行。而这个函数我们可以看到是在</code>gcstopm()`种有调用:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sched.stopwait--</span><br><span class="line"><span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">    notewakeup(&amp;sched.stopnote)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于存在 g 无法被抢占，所以其对应的 p 不会释放, <code>stopwait</code>也就不能为<code>0</code>, 所以也就无法执行<code>notewakeup</code>,最终导致上面的循环无法出来。</p>
<p>死锁状态的发生:</p>
<ul>
<li>GC: 要想进行<code>GC</code>就需要所有的P都转为空闲状态，而主<code>goroutine</code>无法被抢占，对应的<code>P</code>也无法进入空闲。所以<code>GC</code>会一直阻塞。</li>
<li>新启动的<code>goroutine</code>: 由于新启动的<code>goroutine</code>也进入了空闲状态</li>
<li>主<code>goroutine</code>: 由于新启动的<code>goroutine</code>进入了空闲状态,无法再给<code>chan</code>发信号，所以主<code>goroutine</code>也无法退出。<br>由于上面三个都进入了阻塞状态，导致了整个程序进入了死锁状态。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html" target="_blank" rel="noopener">scheduling-in-go-part1</a><br><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html" target="_blank" rel="noopener">scheduling-in-go-part2</a><br><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html" target="_blank" rel="noopener">scheduling-in-go-part3</a><br><a href="https://github.com/two/go-under-the-hood/blob/master/book/part2runtime/ch06sched/preemptive.md" target="_blank" rel="noopener">go-under-the-hood</a><br><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">non-cooperative-preemption</a><br><a href="https://gocn.vip/article/441" target="_blank" rel="noopener">如何定位 golang 进程 hang 死的 bug</a><br><a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/"><span>【译】 Go 语言机制之栈和指针 (1)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-04T05:29:19.000Z">
          2019-03-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列的文章主要是帮助你理解指针，栈，堆，逃逸分析和值/指针语义的设计和机制。本系列一共有四篇，这是第一篇。本篇主要是介绍栈和指针。</p>
<p>本系列文章索引:<br>1) Go 语言机制之栈和指针<br>2) Go 语言机制之逃逸分析<br>3) Go 语言机制之内存性能分析<br>4) Go 语言机制之数据和语义的使用原则</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我并不打算美化指针，因为指针真的很难理解。如果我们使用不当，指针能够产生很难理解的 bug 甚至影响性能。 在写并发程序或者多线程程序时这种问题更为明显。这也难怪很多语言试图对开发者隐藏指针的使用。尽管如此，如果你是用 Go 来开发程序，你是没有办法避免使用指针的。相对于深入的理解指针，你更应该关注如何写出干净，简单并且有效的代码。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/01/golang-http-client-connection-pool/"><span>golang http client 连接池</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/01/golang-http-client-connection-pool/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-01T02:44:03.000Z">
          2018-06-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>golang标准库<code>net/http</code>做为<code>client</code>时有哪些细节需要注意呢，这里做一个详细的分析。</p>
</blockquote>
<h2 id="net-http-client工作流程"><a href="#net-http-client工作流程" class="headerlink" title="net/http client工作流程"></a>net/http client工作流程</h2><p>首先分析一下<code>client</code>的工作流程。 下面是一般我们进行一个请求时的代码事例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoRequest</span><span class="params">(req *http.Request)</span> <span class="params">(MyResponse, error)</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response := MyResponse&#123;&#125;</span><br><span class="line">    response.Header = resp.Header</span><br><span class="line">    ...</span><br><span class="line">    response.Body = body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们首先创建一个<code>http.Client</code>, 所有的值都是默认值，然后调用<code>client.Do</code>发请求，<code>req</code>是我们请求的结构体。这里我们也可以用<code>client.Get</code>, <code>client.Post</code>等函数来调用，从他们的源码来看都是调用的<code>client.Do</code>。<br><code>client.Do</code>的实现在<code>net/http</code>包的<code>go/src/net/http/client.go</code>源文件中。可以看到函数内部主要是实现了一些参数检查，默认值设置，以及对于多跳请求的处理，最为核心的就是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// c.send() always closes req.Body</span></span><br><span class="line">            reqBodyClosed = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">                err = &amp;httpError&#123;</span><br><span class="line">                    err:     err.Error() + <span class="string">" (Client.Timeout exceeded while awaiting headers)"</span>,</span><br><span class="line">                    timeout: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shouldRedirect <span class="keyword">bool</span></span><br><span class="line">redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !shouldRedirect &#123;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里真正发请求的函数就是<code>c.send</code>, 这个函数的实现也比较简单, 主要是调用了<code>send</code>函数，这个函数的实现主要如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// didTimeout is non-nil only if err != nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send issues an HTTP request.</span></span><br><span class="line"><span class="comment">// Caller should close resp.Body when done reading from it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line">    ...</span><br><span class="line">        resp, err = rt.RoundTrip(req)</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里真正进行网络交互的定位到的函数是<code>rt.RoundTrip</code>,这个函数的定义是一个<code>interface</code>，从其注释也可以看出他的主要作用是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// RoundTrip executes a single HTTP transaction, returning</span><br><span class="line">// a Response for the provided Request.`</span><br></pre></td></tr></table></figure></p>
<p>由于这个函数是一个<code>interface</code>我们需要知道是谁实现了这个函数，看一下<code>send</code>的参数就可以找到，实现这个函数的是<code>c.transport()</code>的返回值，这个函数的实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到，返回的对象是<code>c.Transport</code>或者<code>DefaultTransport</code>, 由于我们创建<code>client</code>的时候没有设置<code>c.Transport</code>参数，所以这里返回的应该是<code>DefaultTransport</code>对象, 这个对象对<code>RoundTripper</code>函数的实现大概如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip implements the RoundTripper interface.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For higher-level HTTP client support (such as handling of cookies</span></span><br><span class="line"><span class="comment">// and redirects), see Get, Post, and the Client type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">                pconn, err := t.getConn(treq, cm)</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// HTTP/2 path.</span></span><br><span class="line">                    t.setReqCanceler(req, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">                        resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp, err = pconn.roundTrip(treq)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面具体的细节我们先不关系，对于<code>HTTP/2</code>的处理我们也先不关心。这里需要重点关注的是<code>t.getConn</code>这个函数。<code>t.getConn</code>的作用是获取一个链接，这个链接该怎么获取，是一个值得深究的问题。下面看一下这个函数的关键实现细节:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getConn dials and creates a new persistConn to the target as</span></span><br><span class="line"><span class="comment">// specified in the connectMethod. This includes doing a proxy CONNECT</span></span><br><span class="line"><span class="comment">// and/or setting up TLS.  If this doesn't return an error, the persistConn</span></span><br><span class="line"><span class="comment">// is ready to write requests to.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">req := treq.Request</span><br><span class="line">         trace := treq.trace</span><br><span class="line">         ctx := req.Context()</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GetConn(cm.addr())</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">if</span> pc, idleSince := t.getIdleConn(cm); pc != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GotConn(pc.gotIdleConnTrace(idleSince))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// set request canceler to some non-nil function so we</span></span><br><span class="line">         <span class="comment">// can detect whether it was cleared between now and when</span></span><br><span class="line">         <span class="comment">// we enter roundTrip</span></span><br><span class="line">         t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;&#125;)</span><br><span class="line">             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">         handlePendingDial := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             testHookPrePendingDial()</span><br><span class="line">                 <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> v := &lt;-dialc; v.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                         t.putOrCloseIdleConn(v.pc)</span><br><span class="line">                     &#125;</span><br><span class="line">                     testHookPostPendingDial()</span><br><span class="line">                 &#125;()</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">cancelc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">             t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123; cancelc &lt;- err &#125;)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                 pc, err := t.dialConn(ctx, cm)</span><br><span class="line">                     dialc &lt;- dialRes&#123;pc, err&#125;</span><br><span class="line">             &#125;()</span><br><span class="line">idleConnCh := t.getIdleConnCh(cm)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> v := &lt;-dialc:</span><br><span class="line">                            <span class="comment">// Our dial finished.</span></span><br><span class="line">                            <span class="keyword">if</span> v.pc != <span class="literal">nil</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &amp;&amp; v.pc.alt == <span class="literal">nil</span> &#123;</span><br><span class="line">                                    trace.GotConn(httptrace.GotConnInfo&#123;Conn: v.pc.conn&#125;)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> v.pc, <span class="literal">nil</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Our dial failed. See why to return a nicer error</span></span><br><span class="line">                            <span class="comment">// value.</span></span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                    <span class="comment">// It was an error due to cancelation, so prioritize that</span></span><br><span class="line">                                    <span class="comment">// error value. (Issue 16049)</span></span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                                <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                                          <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                              err = errRequestCanceledConn</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                              <span class="comment">// It wasn't an error due to cancelation, so</span></span><br><span class="line">                                              <span class="comment">// return the original error message:</span></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">nil</span>, v.err</span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="keyword">case</span> pc := &lt;-idleConnCh:</span><br><span class="line">                             <span class="comment">// Another request finished first and its net.Conn</span></span><br><span class="line">                             <span class="comment">// became available before our dial. Or somebody</span></span><br><span class="line">                             <span class="comment">// else's dial that they didn't use.</span></span><br><span class="line">                             <span class="comment">// But our dial is still going, so give it away</span></span><br><span class="line">                             <span class="comment">// when it finishes:</span></span><br><span class="line">                             handlePendingDial()</span><br><span class="line">                                 <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">                                     trace.GotConn(httptrace.GotConnInfo&#123;Conn: pc.conn, Reused: pc.isReused()&#125;)</span><br><span class="line">                                 &#125;</span><br><span class="line">                             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                 handlePendingDial()</span><br><span class="line">                                     <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                     handlePendingDial()</span><br><span class="line">                                         <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                    <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                              handlePendingDial()</span><br><span class="line">                                  <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                      err = errRequestCanceledConn</span><br><span class="line">                                  &#125;</span><br><span class="line">                              <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是这个过程的流程图:<br><img src="http://www.plantuml.com/plantuml/svg/NP3DYi8m58NNvYcohA-WIv-as5I39HbCD-vcm9_IHHsm54P1Pa2NC-fcb2deopHf-XRUDjQ1XcnoxpddVhd2jyS-eYwsiZJIjwsAzkhqgQEpN2R5wWhFDlQ7X65hGaGROJWTVOlbPckwNKGyGR35UDbq-NY4MXqPR6JwfvAZ2UmQcmf3ur7nLGR7_EUhU5ivrFRwsUNxeG68kc8O_XFAR6mFRCfW0kYCdpeUwN76UiE6HGPhkCKYX6dvUbhJrYG0PoYXz_XsHVLSWGeI_JhhUroGnlGgGiv-ipGfuWzzECZTD7-Vboh27BC3KE36cfX3NIHy_d87"><br>从上面可以看到，获取链接会优先从连接池中获取，如果连接池中没有可用的连接，则会创建一个连接或者从刚刚释放的连接中获取一个，这两个过程时同时进行的，谁先获取到连接就用谁的。<br>当新创建一个连接, 创建连接的函数定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error)</span><br></pre></td></tr></table></figure></p>
<p>最后这个函数会通过goroutine调用两个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go pconn.readLoop()</span><br><span class="line">go pconn.writeLoop()</span><br></pre></td></tr></table></figure></p>
<p>其中<code>readLoop</code>主要是读取从server返回的数据,<code>writeLoop</code>主要发送请求到server,在<code>readLoop</code>函数中有这么一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Put the idle conn back into the pool before we send the response</span><br><span class="line">// so if they process it quickly and make another request, they&apos;ll</span><br><span class="line">// get this same conn. But we use the unbuffered channel &apos;rc&apos;</span><br><span class="line">// to guarantee that persistConn.roundTrip got out of its select</span><br><span class="line">// potentially waiting for this persistConn to close.</span><br><span class="line">// but after</span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">    pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br></pre></td></tr></table></figure></p>
<p>这里可以看出，在处理完请求后，会立即把当前连接放到连接池中。</p>
<p>上面说到连接池，每个<code>client</code>的连接池结构是这样的:<code>idleConn   map[connectMethodKey][]*persistConn</code>。其中<code>connectMethodKey</code>的值就是<code>client</code>连接的server的<code>host</code>值, map的值是一个<code>*persistConn</code>类型的<code>slice</code>结构，这里就是存放连接的地方，<code>slice</code>的长度由<code>MaxIdleConnsPerHost</code>这个值指定的，当我们不设置这个值的时候就取默认的设置:<code>const DefaultMaxIdleConnsPerHost = 2</code>。</p>
<p>另外这里我们插一个知识点，对于HTTP协议，有一个header值”Connections”, 这个值的作用就是<code>client</code>向<code>server</code>端发请求的时候，告诉<code>server</code>是否要保持连接。具体的可以参考<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank" rel="noopener">rfc2616</a>。 这个协议头的值有两种可能(参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">MDN文档</a>):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p>
<p>当值为<code>keep-alive</code>时，<code>server</code>端会保持连接，一直到连接超时。当值为<code>close</code>时,<code>server</code>端会在传输完<code>response</code>后主动断掉<code>TCP</code>连接。在<code>HTTP/1.1</code>之前，这个值默认是<code>close</code>, 之后是默认<code>keep-alive</code>, 而<code>net/http</code>默认的协议是<code>HTTP/1.1</code>也就是默认<code>keep-alive</code>, 这个值可以通过<code>DisableKeepAlives</code>来设置。</p>
<p>从上面的介绍我们可以看出，<code>net/http</code>默认是连接复用的，对于每个server会默认的连接池大小是2。<br>接下来我们看一下连接是如何放进连接池的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">putOrCloseIdleConn</span><span class="params">(pconn *persistConn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span></span><br><span class="line"><span class="comment">// a new request.</span></span><br><span class="line"><span class="comment">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span></span><br><span class="line"><span class="comment">// an error explaining why it wasn't registered.</span></span><br><span class="line"><span class="comment">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errKeepAlivesDisabled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.isBroken() &#123;</span><br><span class="line">        <span class="keyword">return</span> errConnBroken</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errNotCachingH2Conn</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.markReused()</span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line"></span><br><span class="line">    t.idleMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> t.idleMu.Unlock()</span><br><span class="line">    waitingDialer := t.idleConnCh[key]</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> waitingDialer &lt;- pconn:</span><br><span class="line">        <span class="comment">// We're done with this pconn and somebody else is</span></span><br><span class="line">        <span class="comment">// currently waiting for a conn of this type (they're</span></span><br><span class="line">        <span class="comment">// actively dialing, but this conn is ready</span></span><br><span class="line">        <span class="comment">// first). Chrome calls this socket late binding. See</span></span><br><span class="line">        <span class="comment">// https://insouciant.org/tech/connection-management-in-chromium/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> waitingDialer != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// They had populated this, but their dial won</span></span><br><span class="line">            <span class="comment">// first, so we can clean up this map entry.</span></span><br><span class="line">            <span class="built_in">delete</span>(t.idleConnCh, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.wantIdle &#123;</span><br><span class="line">        <span class="keyword">return</span> errWantIdle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.idleConn == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.idleConn = <span class="built_in">make</span>(<span class="keyword">map</span>[connectMethodKey][]*persistConn)</span><br><span class="line">    &#125;</span><br><span class="line">    idles := t.idleConn[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(idles) &gt;= t.maxIdleConnsPerHost() &#123;</span><br><span class="line">        <span class="keyword">return</span> errTooManyIdleHost</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, exist := <span class="keyword">range</span> idles &#123;</span><br><span class="line">        <span class="keyword">if</span> exist == pconn &#123;</span><br><span class="line">            log.Fatalf(<span class="string">"dup idle pconn %p in freelist"</span>, pconn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    t.idleLRU.add(pconn)</span><br><span class="line">    <span class="keyword">if</span> t.MaxIdleConns != <span class="number">0</span> &amp;&amp; t.idleLRU.<span class="built_in">len</span>() &gt; t.MaxIdleConns &#123;</span><br><span class="line">        oldest := t.idleLRU.removeOldest()</span><br><span class="line">        oldest.<span class="built_in">close</span>(errTooManyIdle)</span><br><span class="line">        t.removeIdleConnLocked(oldest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IdleConnTimeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pconn.idleTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">            pconn.idleTimer.Reset(t.IdleConnTimeout)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.idleAt = time.Now()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会尝试把连接放入到连接池中，如果不成功则<code>关闭连接</code>,大致流程如下:<br><img src="http://www.plantuml.com/plantuml/svg/XP5FJy8m6CRl-nGzmispauEHWyQO-1LgU8UDIsVMuf-4WqOM5rHYuX914m864gC1528I8F9brcux-HMS82Cxg3sqJVi-lxvF7yQnoHMYeKIQCBoZmoR0_gfE3e2XL0fnCmSedqTR-6WZeyEQGIdR1dFTO1ojeAKauhj0KU8OM591uLWMLY-uRVcJgYmrLGLq1YX1ZVcbVIz6GtTmuWwUl7OzEBqvn8GJcaqJh8FfEO_ki1GAfTFtdY_4LIyuBqhdmxih-6y5ERnMqPIZ6URUT3E5kkEoi6nPBCuU3Uk5rHJsImpj3bhgGX9lSduCD1FX4SvYGXUA36WuftDXru9A8qRs9vN8pUVuCYXtPUiXA8z4lQh-YXDMNxJF0gVYTpgXwEz-mZLo_1tKZy_NcdZlob7zlmnYg7WUix-AU54jqPHe_W80"><br>如果<code>DisableKeepAlives</code>为<code>true</code>表示不使用连接复用，所以请求完后会把连接关掉，但是这里需要注意的是，同时发请求的时候我们会设置<code>Connections: close</code>, 所以<code>server</code>端发送完数据后就会自动断开，所以这种情况的连接其实是<code>server</code>端发起的。</p>
<h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>前面我们已经讲过<code>net/http</code>默认使用<code>HTTP/1.1</code>协议，也就是默认发送<code>Connections: keep-alive</code>的头，让服务端保持连接，就是所谓的长连接。<br>再看<code>DefaultTransport</code>的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// DefaultTransport is the default implementation of Transport and is</span><br><span class="line">// used by DefaultClient. It establishes network connections as needed</span><br><span class="line">// and caches them for reuse by subsequent calls. It uses HTTP proxies</span><br><span class="line">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and</span><br><span class="line">// $no_proxy) environment variables.</span><br><span class="line">var DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment, //代理使用</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   30 * time.Second, //连接超时时间</span><br><span class="line">        KeepAlive: 30 * time.Second, //连接保持超时时间</span><br><span class="line">        DualStack: true, //</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    MaxIdleConns:          100, //client对与所有host最大空闲连接数总和</span><br><span class="line">    IdleConnTimeout:       90 * time.Second, //空闲连接在连接池中的超时时间</span><br><span class="line">    TLSHandshakeTimeout:   10 * time.Second, //TLS安全连接握手超时时间</span><br><span class="line">    ExpectContinueTimeout: 1 * time.Second, //发送完请求到接收到响应头的超时时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用<code>DefaultTransport</code>时，就是默认使用的长连接。但是默认的连接池<code>MaxIdleConns</code>为100， <code>MaxIdleConnsPerHost</code>为2，当超出这个范围时，客户端会主动关闭到连接。<br>如果我们想设置为短连接，有几种方法:</p>
<ol>
<li>设置<code>DisableKeepAlives = true</code>: 这时就会发送<code>Connections:close</code>给server端，在server端响应后就会主动关闭连接。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>: 当<code>MaxIdleConnsPerHost &lt; 0</code>时，连接池是无法放置空闲连接的，所以无法复用,连接直接会在<code>client</code>端被关闭。</li>
</ol>
<h2 id="Server端出现大量的TIME-WAIT"><a href="#Server端出现大量的TIME-WAIT" class="headerlink" title="Server端出现大量的TIME_WAIT"></a>Server端出现大量的<code>TIME_WAIT</code></h2><p>当我们在实际使用时，会发现<code>Server</code>端出现了大量的<code>TIME_WAIT</code>,要想深入了解其原因，我们首先先回顾一下<code>TCP</code>三次握手和四次分手的过程:<br><img src="/assets/img/golang/tcp_3_handshake.png" alt><br><img src="/assets/img/golang/tcp_4_handshake.png" alt><br>图中可以看出，<code>TIME_WAIT</code>只会出现在主动关闭连接的一方,也就是<code>server</code>端出现了大量的主动关闭行为。<br>默认我们是使用长连接的，只有在超时的情况下<code>server</code>端才会主动关闭连接。前面也讲到，如果超出连接池的部分就会在<code>client</code>端主动关闭连接，连接池的连接会复用，看着似乎没有什么问题。问题出在我们每次请求都会<code>new</code>一个新的<code>client</code>,这样每个<code>client</code>的连接池里的连接并没有得到复用，而且这时<code>client</code>也不会主动关闭这个连接，所以<code>server</code>端出现了大量的<code>keep-alive</code>但是没有请求的连接，就会主动发起关闭。</p>
<p>todo:补充tcpdump的分析结果</p>
<p>要解决这个问题以下几个方案:</p>
<ol>
<li><code>client</code>复用，也就是我们尽量复用<code>client</code>，来保证<code>client</code>连接池里面的连接得到复用，而减少出现超时关闭的情况。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>：这样每次请求后都会由<code>client</code>发起主动关闭连接的请求，<code>server</code>端就不会出现大量的<code>TIME_WAIT</code></li>
<li><p>修改<code>server</code>内核参数: 当出现大量的<code>TIME_WAIT</code>时危害就是导致<code>fd</code>不够用,无法处理新的请求。我们可以通过设置<code>/etc/sysctl.conf</code>文件中的</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>
<p> 达到快速回收和重用的效果，不影响其对新连接的处理。</p>
</li>
</ol>
<p>另外需要注意的是，虽然<code>DisableKeepAlives = true</code>也能满足连接池中不放空闲连接，但是这时候会发送<code>Connections: close</code>，这时<code>server</code>端还是会主动关闭连接，导致大量的<code>TIME_WAIT</code>出现，所以这种方法行不通。</p>
<p>以上就是我总结的关于<code>net/http</code>中连接池相关的知识。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/03/the-core-technology-of-high-traffic-website/"><span>亿级流量网站架构核心技术总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/03/the-core-technology-of-high-traffic-website/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-03T05:27:30.000Z">
          2017-08-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近读了《亿级流量网站架构核心技术——跟开涛学搭建高可用高并发系统》这本书，总体感觉这本书很实用，作者根据自己负责的项目经历以及业务的发展过程和业界的理论基础相结合讲解了如何搭建一个具有高并发和高可用特征的电商网站。作者是京东的架构师，进来随着京东业务的不断发展，6.18和双十一活动规模的不断扩大，作者都亲身经历了整个电商网站的发展过程，相对于单纯的理论，这本书更多的是能够在业务中快速应用的经验总结。下面就这两方面我把作者的思维导图搬过来，不断提醒自己要注意的整体思想，并能够深入浅出，根据思维导图的每一项都有一个自己更发散更深入的认识。</p>
</blockquote>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><img src="/assets/img/cthtw/High-availability.png" alt="高可用"></p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="/assets/img/cthtw/High-concurrency.png" alt="高并发"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/java/">java</a><a href="/tags/架构/">架构</a><a href="/tags/高并发/">高并发</a><a href="/tags/高可用/">高可用</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/12/golang-goroutines-1/"><span>golang channels 的串联,扇入扇出及控制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/12/golang-goroutines-1/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-12T02:06:03.000Z">
          2017-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。 一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。 channel之间可以进行串联，并联等组合，组成我们想要的运行方式。 不同goroutine之间需要同步，也需要控制，具体该如何处理这些情况，下面分别进行介绍。</p>
</blockquote>
<h2 id="channel基础"><a href="#channel基础" class="headerlink" title="channel基础"></a>channel基础</h2><p>使用内置的make函数，我们可以创建一个channel:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type 'chan int'</span></span><br></pre></td></tr></table></figure></p>
<p>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。<br>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。<br>一个channel有发送和接受两个主要操作，都是通信行为。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch     <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure></p>
<p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></table></figure></p>
<p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的Channels</h3><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。<br>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。</p>
<p>对于不带缓存的Channels，我们使用的是有必须放到goroutine,因为如果直接调用<code>chanx &lt;- 1</code>时，会报错<code>fatal error: all goroutines are asleep - deadlock!</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chanx &lt;- <span class="number">1</span> <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p>
<p>由于主goroutine调用了 <code>chanx &lt;-1</code>, 但是由于是顺序往下执行，执行时还不存在监听<code>chanx</code>的方法存在，所以数据放入<code>chanx</code>后无法唤醒接收的方法，只能等待下去，所以就产生了deadlock。<br>可以修改为下面的形式，把<code>chanx &lt;- 1</code>放入到一个goroutine里，然后主goroutine监听了这个<code>chanx</code>，当往<code>chanx</code>放数据的时候就会有接收的方法被调用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;chanx &lt;- <span class="number">1</span>&#125;() <span class="comment">//right</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p>
<p><strong>当使用<code>range</code>遍历<code>chan</code>时别忘了close</strong>, 下面当没有使用close时:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>output:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive]:</span><br></pre></td></tr></table></figure></p>
<p><code>range</code>会从<code>channel</code>中接收数据直到<code>channel</code>被<code>close</code>为止，正常情况下<code>close</code>并不是必须的，只有在接收者需要知道没有更多的数据进入的时候才需要，而<code>range</code>正是需要知道这个信息的。所以代码改成下面这样就没问题了:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(chanx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="带缓存的Channels"><a href="#带缓存的Channels" class="headerlink" title="带缓存的Channels"></a>带缓存的Channels</h3><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p>
<p><strong>队列元素为1的带缓存Channels与不带缓存的Channels是不同的</strong>，下面的例子可以看出:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan_nobuffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan_nobuffer &lt;- <span class="number">1</span> <span class="comment">//error 必须放到goroutine中</span></span><br><span class="line">    &lt;-chan_nobuffer</span><br><span class="line"></span><br><span class="line">    chan_buffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    chan_buffer &lt;- <span class="number">1</span> <span class="comment">//right</span></span><br><span class="line">    &lt;-chan_buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><p>channel还有两种语法:<code>&lt;-chan int</code>和<code>chan&lt;- int</code>，其意思是单方向的channel, 当定义为<code>out chan&lt;- int</code>表示<code>out</code>只能被往里面放数据，不允许从out拿数据,否则程序会报错<code>receive from send-only type chan&lt;- int</code>,如果定义为<code>in &lt;-chan int</code>则<code>in</code>只能往外输出数据，不允许往<code>in</code>里面放数据，否则报错<code>send to receive-only type &lt;-chan int</code></p>
<h2 id="channel串联"><a href="#channel串联" class="headerlink" title="channel串联"></a>channel串联</h2><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。 这种串联的Channels就是所谓的管道（pipeline）。下图就是一个串联的channel示意:<br><img src="/assets/img/golang/goroutines_0712_1.png" alt="串联channel"><br>第一个goroutine Counter负责生成一个0,1,2,3,…形式的整数序列,然后把整数序列输入到一个channel中，通过这个channel传递个下一个goroutine Squarer, 负责将从channel接收到的数求平方，然后再把得出的结果通过channel传递给goroutine Printer, Printer负责将从channel接收的数据打印出来。<br>其程序实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> Counter(chan1)</span><br><span class="line">    <span class="keyword">go</span> Squarer(chan2, chan1)</span><br><span class="line">    Printer(chan2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中我们创建了两个chan, 然后调用了<code>Counter</code>和<code>Squarer</code>, 由于上面说:<strong>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。</strong>所以我们对chan1和chan2的修改都是全局的。<br><code>Counter</code>往chan1中陆续放入了<code>0,1,2,3,...</code>等数列，然后同步的<code>Squarer</code>接收到数据对其平方并放入<code>chan2</code>,最后<code>Printer</code>从<code>chan2</code>中输出这些数据。<br>对于串联的Channel还有另外一种实现方法:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    out := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            out &lt;- n*n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>gen</code>函数用到了golang的<strong>可变参数</strong>这个特性，跟上面的<code>Counter</code>不一样的是，这个<code>gen</code>会把<code>chan</code>当做返回值返回，而不是作为参数传入。<code>sq</code>函数也跟<code>Squarer</code>函数不一样了:把上一个函数的chan最为参数，下一个输出的chan作为返回值。</p>
<h2 id="channel扇入扇出"><a href="#channel扇入扇出" class="headerlink" title="channel扇入扇出"></a>channel扇入扇出</h2><p><strong>扇出</strong>：同一个 channel 可以被多个函数读取数据，直到channel关闭。 这种机制允许将工作负载分发到一组worker，以便更好地并行使用 CPU 和 I/O。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    c1 := sq(c)</span><br><span class="line">    c2 := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c1 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"-------------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c2 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是几种输出样式，可以知道当调用两次<code>sq</code>时，其实是对chan的扇出操作，既一个channel被多个函数读取了。每次读取的顺序和个数都不能保证。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span> </span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">9</span></span><br><span class="line">#<span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">------------------</span><br><span class="line">#<span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong>扇入</strong>：多个 channel 的数据可以被同一个函数读取和处理，然后合并到一个 channel，直到所有 channel都关闭。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed, then calls wg.Done.</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            out &lt;- n <span class="comment">//对于每个chan其中的元素都放到out中 </span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done() <span class="comment">//减少一个goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs)) <span class="comment">//要执行的goroutine个数</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        <span class="keyword">go</span> output(c) <span class="comment">//对传入的多个channel执行output</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a goroutine to close out once all the output goroutines are</span></span><br><span class="line">    <span class="comment">// done.  This must start after the wg.Add call.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait() <span class="comment">//等待，直到所有goroutine都完成后</span></span><br><span class="line">        <span class="built_in">close</span>(out) <span class="comment">//所有的都放到out后关闭</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>merge</code>函数的参数也是变长的，类型是<code>chan</code>, 这个函数还用到了<code>sync</code>这个包，这里主要的作用就是对一组goroutines进行同步。首先把传入的cs都通过<code>output</code>调用放入<code>out</code>中，每处理完一个<code>c</code>就调用<code>wg.Done()</code>更新剩余的次数, <code>wg.Wait()</code>等到所有的channels把数据放到<code>out</code>中，然后关闭<code>out</code>。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    out2 := sq(c)</span><br><span class="line">    out1 := sq(c)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> merge(out1, out2) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图就展示了扇入扇出的过程:<br><img src="/assets/img/golang/goroutines_0712_2.png" alt="串联channel"></p>
<h2 id="goroutines控制"><a href="#goroutines控制" class="headerlink" title="goroutines控制"></a>goroutines控制</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">The Go Blog - pipelines</a></li>
<li><a href="https://segmentfault.com/a/1190000006261218" target="_blank" rel="noopener">Go语言并发模型：像Unix Pipe那样使用channel</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-04.html" target="_blank" rel="noopener">Go语言圣经-channels</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-05.html" target="_blank" rel="noopener">Go语言圣经-并发的循环</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch5/ch5-07.html" target="_blank" rel="noopener">Go语言圣经-可变参数</a></li>
<li><a href="https://deepzz.com/post/golang-context-package-notes.html" target="_blank" rel="noopener">快速掌握 Golang context 包</a></li>
<li><a href="https://tour.golang.org/concurrency/4" target="_blank" rel="noopener">A Tour of Go - Range and Close</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goroutines/">goroutines</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/01/how-golang-webserver-work/"><span>golang的webserver是如何工作的</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/01/how-golang-webserver-work/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-01T01:29:38.000Z">
          2017-07-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>我们知道golang实现一个webserver非常简单，但是其内部是如何工作的呢，我们深入探究一下其原理。</p>
</blockquote>
<h2 id="实现一个webserver服务"><a href="#实现一个webserver服务" class="headerlink" title="实现一个webserver服务"></a>实现一个webserver服务</h2><p>下面我们就用golang内置的服务实现一个简单的webserver:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        r.ParseForm()       <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">        fmt.Println(r.Form) <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">        fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">        fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">        fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">                fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">                fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        http.HandleFunc(<span class="string">"/hello"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过<code>go run main.go</code>来开启Server服务, 当我们访问<code>http://localhost:8090/</code>或<code>http://localhost:8090/hello</code>都会得到<code>Hello astaxie!</code>, 也就是都执行了<code>sayhelloName</code>函数。<br>下面让我们来分析一下服务的代码:<br>首先我们从<code>main</code>函数入口进入程序执行，首先执行了<code>http.HandleFunc(&quot;/&quot;, sayhelloName)</code>和<code>http.HandleFunc(&quot;/hello&quot;, sayhelloName)</code>两个方法，这两个方法其实就是设置路由及其对应的处理函数。<br>然后执行<code>http.ListenAndServe(&quot;:8090&quot;, nil)</code>这个函数开始监听8090端口并把用户的请求根据之前设置的路由规则交给特定的函数进行处理。<br>下面我将针对这两个函数进行深入的分析。</p>
<h2 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a>http.HandleFunc</h2><p>这个函数是<code>net/http</code>包中定义的, 第一个参数<code>pattern</code>是<code>string</code>类型，表示匹配的URL, 第二个参数<code>handler</code>这是个函数类型，表示一个处理函数。其定义在<code>net/http/server.go</code>中，第一如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数调用了下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HandelrFunc</code>定义如下, 声明为一个函数类型, <code>HandlerFunc(handler)</code>就是把<code>handler</code>强制类型转化为<code>HandlerFunc</code>类型<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>mux.Handle</code>的定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helpful behavior:</span></span><br><span class="line">    <span class="comment">// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span></span><br><span class="line">    <span class="comment">// It can be overridden by an explicit registration.</span></span><br><span class="line">    n := <span class="built_in">len</span>(pattern)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line">        <span class="comment">// If pattern contains a host name, strip it and use remaining</span></span><br><span class="line">        <span class="comment">// path for redirect.</span></span><br><span class="line">        path := pattern</span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line">            <span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">            path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">        &#125;</span><br><span class="line">        url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">        mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出这个函数会把<code>pattern</code>和<code>handler</code>的对应关系读存储到<code>mux.m</code>这个map里了，<code>mux</code>类型是<code>ServeMux</code>,其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">    hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过上面的处理后通过<code>http.HandleFunc</code>设置的<code>pattern</code>与<code>handler</code>的对应关系都被存储到了<code>DefaultServeMux</code>这个对象的<code>m</code>中。</p>
<h2 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a>http.ListenAndServe</h2><p>这个函数也是在<code>net/http/server.go</code>中定义的，其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面函数最终对调用到下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn(srv, l)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srv.trackListener(l, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">defer</span> srv.trackListener(l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过一个for循环不停的接收请求<code>l.Accept()</code>来得到接收的请求，然后再通过<code>go c.serve(ctx)</code>进行请求的处理。这里用到了协程，也就是每个请求其实是由单独的协程进行处理的，这也是golang作为webserver高效的原因所在。<code>c.serve</code>函数中有一个<code>for</code>循环，会不断读取同一个请求的数据，直到出现问题或者正确读取完毕。读取完请求后会调用<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>这个函数来处理请求。这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="当-handler-为-nil"><a href="#当-handler-为-nil" class="headerlink" title="当 handler 为 nil:"></a>当 handler 为 nil:</h3><p>可以看到当我们不在<code>ListenAndServe</code>中传递<code>handler</code>时，也就是<code>sh.srv.Handler = nil</code>时<code>hanlder=DefaultServeMux</code>，这个 <code>DefaultServeMux</code>正式我们前面通过<code>http.HandleFunc</code>来设置的。 下面调用了<code>hanlder.ServeHTTP</code>，这里也就是调用了<code>DefaultServeMux.ServeHTTP</code>, 这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数中的<code>mux.Handler</code>从请求<code>r</code>中找到请求的URL然后在去<code>mux.m</code>的map结构中找到对应的映射关系从而得出<code>h</code>这个处理函数名。<br>由于上面说过<code>h</code>是转换为类型<code>HandlerFunc</code>, 这个类型定义的<code>ServeHTTP</code>函数如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以调用<code>h.ServeHTTP(w,r)</code>就等于调用<code>h(w,r)</code>，也就是我们调用我们自己的写的处理函数。<br>这些都完成后会执行收尾工作，并把得到的结构返回给请求用户。</p>
<h3 id="当-handler-不为-nil"><a href="#当-handler-不为-nil" class="headerlink" title="当 handler 不为 nil:"></a>当 handler 不为 nil:</h3><p>这时调用<code>h.ServerHTTP(w,r)</code>其实就是调用自己传入的<code>handler</code>的<code>ServerHTTP</code>函数，例如web框架<code>revel</code>的源码<code>github.com/revel/cmd/harness/harness.go</code>中执行<code>revel run app</code>是就会执行下面的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the harness, which listens for requests and proxies them to the app</span></span><br><span class="line"><span class="comment">// server, which it runs and rebuilds as necessary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> paths []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> revel.Config.BoolDefault(<span class="string">"watch.gopath"</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">        gopaths := filepath.SplitList(build.Default.GOPATH)</span><br><span class="line">        paths = <span class="built_in">append</span>(paths, gopaths...)</span><br><span class="line">    &#125;</span><br><span class="line">    paths = <span class="built_in">append</span>(paths, revel.CodePaths...)</span><br><span class="line">    watcher = revel.NewWatcher()</span><br><span class="line">    watcher.Listen(h, paths...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        addr := fmt.Sprintf(<span class="string">"%s:%d"</span>, revel.HTTPAddr, revel.HTTPPort)</span><br><span class="line">        revel.INFO.Printf(<span class="string">"Listening on %s"</span>, addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        <span class="keyword">if</span> revel.HTTPSsl &#123;</span><br><span class="line">            err = http.ListenAndServeTLS(</span><br><span class="line">                addr,</span><br><span class="line">                revel.HTTPSslCert,</span><br><span class="line">                revel.HTTPSslKey,</span><br><span class="line">                h)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = http.ListenAndServe(addr, h)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            revel.ERROR.Fatalln(<span class="string">"Failed to start reverse proxy:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kill the app on signal.</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(ch, os.Interrupt, os.Kill)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    <span class="keyword">if</span> h.app != <span class="literal">nil</span> &#123;</span><br><span class="line">        h.app.Kill()</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这里也调用了`</span>http.ListenAndServe<span class="string">`但是第二个参数`</span>hanlder<span class="string">`传入了`</span>h<span class="string">`，所以最终会调用`</span>h.ServerHTTP<span class="string">`函数, 这个函数`</span>revel<span class="string">`中是这么实现的:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="comment">// ServeHTTP handles all requests.</span></span><br><span class="line"><span class="comment">// It checks for changes to app, rebuilds if necessary, and forwards the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Reverse proxy the request.</span></span><br><span class="line">    <span class="comment">// (Need special code for websockets, courtesy of bradfitz)</span></span><br><span class="line">    <span class="keyword">if</span> strings.EqualFold(r.Header.Get(<span class="string">"Upgrade"</span>), <span class="string">"websocket"</span>) &#123;</span><br><span class="line">        proxyWebsocket(w, r, h.serverHost)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h.proxy.ServeHTTP(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/11/The-Design-and-Implementation-of-Redis-4/"><span>Redis设计与实现总结——独立功能的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/11/The-Design-and-Implementation-of-Redis-4/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-11T02:16:04.000Z">
          2017-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>通过执行<code>SUBSCRIBE</code>命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者(subscriber):每当其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息。<br>除了订阅频道之外，客户端还可以通过执行<code>PSUBSCRIBE</code>命令订阅一个或多个模式，从而成为这些模式的订阅者:每当有其他客户端祥某个频道发送消息时，消息不仅会被发送给这个频道所有订阅者，它还会被发送给所有与这个频道匹配的模式的订阅者。<br>Redis将所有频道的订阅管系都保存在服务器状态的<code>pubsub_channels</code>字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。每当执行订阅命令时服务器都会将客户端与被订阅的频道着<code>pubsub_channels</code>字典中进行关联。如果执行退订命令，那么就会从<code>pubsub_channels</code>中删除这个客户端。<br>模式的订阅则是保存在服务器<code>pubsub_patterns</code>这个属性中，其操作过程与上面相同。<br>发送消息是就会遍历频道的<code>pubsub_channels</code>和<code>pubsub_patterns</code>的客户端，将消息发送给订阅了这些频道和模式的客户端。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过<code>MULTI</code>,<code>EXEC</code>,<code>WATCH</code>等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性，按顺序地执行多个命令的机制，并且在事务执行期间(<strong>当接收到EXEC命令后才开始真正执行, 之前只是命令输入</strong>)，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。<br><code>MULTI</code>命令标识事务的开始，除了<code>EXEC</code>,<code>DISCARD</code>,<code>WATCH</code>,<code>MULTI</code>四个命令外的其他命令都会进入事务的队列中，当接收到<code>EXEC</code>命令时开始执行事务队列中的命令。<br><code>WATCH</code>命令是一个乐观锁(optimistic locking), 它可以在<code>EXEC</code>命令执行之前，监视任意数量的数据库键,并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的回复。 (注意<code>WATCH</code>命令执行的顺序是在<code>MULTI</code>之前)。<br><code>WATCH</code>命令执行的过程是:</p>
<ol>
<li>将监控的键保存到<code>watched_keys</code>字典中，字典的值是所有监视相应数据库键的客户端。</li>
<li>所有对数据库进行修改的命令都会对<code>watched_keys</code>进行检查，如果键被修改了，就会把客户端的<code>REDIS_DIRTY_CAS</code>标识打开。</li>
<li>当接收到<code>EXEC</code>执行命令时，如果判断客户端的<code>REDIS_DIRTY_CAS</code>被打开了，标识客户端提交的事务已经不再安全，服务器拒绝客户端提交的事务。 </li>
</ol>
<p>事务的ACID性质: Redis中，事务总是具有原子性(Atomicity), 一致性(Consistency)和隔离性(Isolation)，并且当Redis运行在某种特定持久化模式下时，事务也具有耐久性(Durability)</p>
<ul>
<li>事务的原子性指的是，数据库将事务中的多个操作当做一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。但是Redis的事务和传统的关系型数据库事务的最大区别在于,<strong>Redis不支持事务回滚机制(rollback)</strong>,即事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，知道将事务队列中的所有命令都执行完毕为止。</li>
<li>事务具有一致性指的是，如果数据库在执行事务之前一致的，那么事务在执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。<strong>一致</strong>指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。</li>
<li>事务的隔离性指的是，即时数据库中有多个事务并发地执行，各个事务之间也不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。因为Redis是使用单线程的方式执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此,Redis中的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</li>
<li>事务的耐久性指的是,当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质里面了，即使服务器在事务执行完毕后停机，，执行事务所得的结果也不会丢失。Redis有<code>RDB</code>和<code>AOF</code>两种持久化方案，但是要持久化方案要和性能进行兼顾。</li>
</ul>
<h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本,直接在服务器端原子地执行多个Redis命令。使用<code>EVAL</code>命令可以直接对输入的脚本进行求值，而<code>EVALSHA</code>命令则可以根据脚本的SHA1校验和来对脚本进行求值。<br>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境，并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成:</p>
<ol>
<li>创建一个基础的 Lua环境(通过调用<code>lua_open</code>函数)</li>
<li>载入函数库(基础库,表格库,字符串库等), 让Lua脚本可以使用这些函数库来进行数据操作。</li>
<li>创建全局表格Redis,这个表格包含了对Redis进行操作的函数，比如用于在 Lua脚本中执行Redis命令的redis.call函数</li>
<li>使用Redis自制的随机函数来替换Lua原有的代有副作用的随机函数,从而避免在脚本中引入副作用。(关于副作用，纯函数的概念参考:<a href="https://zh.wikipedia.org/zh-hk/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">wiki</a></li>
<li>创建排序辅助函数，Lua环境使用这个辅助函数来对一部分Redis命令的结果(比如集合)进行排序,从而消除这些命令的不确定性。</li>
<li>创建<code>redis.pcall</code>函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</li>
<li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本过程中，将额外的全局变量添加到Lua环境中。</li>
<li>将完成修改的Lua环境保存到服务器状态的Lua属性中，等待执行服务器传来的Lua脚本。</li>
</ol>
<p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与 Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的<code>lua_scripts</code>字典。</p>
<ul>
<li>伪客户端: 执行Redis命令必须有响应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。下图是Lua脚本执行Redis命令时的通信步骤:<br><img src="/assets/img/redis/redis_lua.png" alt="redis_lua命令执行步骤"></li>
<li><code>lua_scirpts</code>字典: 这个字典的键为某个Lua脚本的SHA1校验和，而字典的值则是SHA1校验和对应的Lua脚本。<br><code>EVAL</code>命令的执行过程可以分为以下三个步骤:</li>
</ul>
<ol>
<li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。</li>
<li>将客户端给定的脚本保存到<code>lua_scripts</code>字典中,等待将来进一步使用。</li>
<li>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</li>
</ol>
<p>Redis还有四个有关Lua脚本的命令:<code>SCRIPT FLUSH</code>, <code>SCRIPT EXISTS</code>, <code>SCRIPT LOAD</code>和<code>SCRIPT KILL</code>命令。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Redis的<code>SORT</code>命令可以对列表建，集合键或者有序集合键的值进行排序。<br>SORT命令的实现原理是(以<code>SORT numbers</code>为例):</p>
<ol>
<li>创建一个和要排序的对象numbers长度相同的数组，该数组的每个项都是一个<code>redis.h/redisSortObject</code>结构。</li>
<li>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间一对一关系</li>
<li>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面</li>
<li>根据数组项u.score属性的值，对数组进行数字值排序(快速排序算法)，排序后的数组项按u.score属性的值从小到大排列</li>
<li>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端。</li>
</ol>
<p>其他的排序方式，比如按照字母顺序排列，降序排列，通过外部键进行排序等原理都差不多，变化的是排列的顺序，排列的依据<code>u.score</code>不一样。<br>更多<code>SORT</code>命令的具体使用和参数可以参考文档:<a href="http://redisdoc.com/key/sort.html" target="_blank" rel="noopener">Redis SORT命令</a></p>
<h2 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h2><p>Redis提供了<code>SETBIT</code>,<code>GETBIT</code>, <code>BITCOUNT</code>, <code>BITOP</code>四个命令用于处理二进制位数组(bit array, 又称为”位数组”)<br>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。<br>具体使用方法参考官方文档。</p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。<br>服务器有两个和慢查询有关的选项:</p>
<ul>
<li><code>slowlog-log-slower-than</code>选项执行执行时间超过多少微秒的命令请求会被记录到日志上。(可以通过<code>CONFIG SET slowlog-log-slower-than N</code>设置)</li>
<li><code>slowlog-max-len</code>选项执行服务器最多保存多少条慢查询日志。(可以通过<code>CONFIG SET slowlog-max-len N</code>设置)</li>
</ul>
<p>使用<code>SLOWLOG GET</code>命令可以查看服务器所保存的慢查询日志, 使用<code>SLOWLOG LEN</code>可以查看当前日志的数量。</p>
<h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>通过执行<code>MONITOR</code>命令，客户端可以将自己变为一个监视器，实时地接收并打印服务器当前处理的命令请求的相关信息。当一个客户端使用<code>MONITOR</code>向服务器发送命令时，这个客户端的<code>REDIS_MONITOR</code>标识会被打开，并且客户端本身会被服务器添加到<code>monitors</code>链表的表尾。当服务器每次接收到请求时(处理命令之前), 都会调用<code>replicationFeedMonitors</code>函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/06/The-Design-and-Implementation-of-Redis-3/"><span>Redis设计与实现总结——多机数据库的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/06/The-Design-and-Implementation-of-Redis-3/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-06T11:19:41.000Z">
          2017-03-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在Redis中用户可以通过执行<code>SLAVEOF</code>命令或者设置<code>slaveof</code>选项，让一个服务器去复制(repliacte)另一个服务器，被复制的服务器称为主服务器(master),而对服务器进行复制的服务器被称为从服务器(salve)。<br>复制功能分为同步(sync)和命令传播(command propagate)两个操作:</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。(从服务器主动向主服务器请求数据)</li>
<li>命令传播操作用于在主服务器的数据库状态被修改，导致主从服务器数据库状态出现不一致时，让主服务器的数据库重新回到一致状态。</li>
</ul>
<p><img src="/assets/img/redis/redis_sync.png" alt="redis旧版复制"></p>
<ul>
<li>同步过程:<ul>
<li>主服务器接收到从服务器发来的SYNC命令,执行BGSAVE命令,创建RDB文件,并使用缓冲区记录接下来执行的所有写命令。</li>
<li>从服务器接收并载入主服务器发来的RDB文件。</li>
<li>主服务器接着发送缓冲区的写命令到从服务器。</li>
<li>从服务器接收命令。</li>
</ul>
</li>
<li>命令传播:<br>  每当主服务器执行写命令时，主服务器的数据库状态就可能被修改，并导致主从服务器不一致。为了再次回到一致状态，主服务器需要对从服务器执行命令传播操作: 主服务器会将自己执行的写命令发送给从服务器执行，当从服务器执行了相同的写命令后，主从服务器再次回到一致状态。</li>
</ul>
<p>从服务器初次复制主服务器或者从服务器当前要复制的主服务器和上一次不一样时，RDB文件会完整的传输。在处于命令传播阶段的主从服务器因为网络原因而中断了复制，再次连接上时会重头开始复制。但是第二种情况的效率非常低，很多已经复制过的数据需要再次进行复制。这就是旧版复制功能的缺陷。<br>新版复制功能为了解决重复复制的问题，提出了一个<code>PSYNC</code>命令代替之前的<code>SYNC</code>命令。完整的复制与上面的第一种情况初次复制是一样的，部分重同步则用于处理断线后的情况: 断线再连接后，主服务器只发送断线期间的写命令到从服务器。<br>部分重同步的实现是通过<code>复制偏移量</code>:</p>
<ul>
<li>主服务器每次向从服务器转播N个字节的数据时，就将自己的复制偏移量的值+N</li>
<li>从服务器每次收到主服务器传播来的N个字节数据时，就将自己的复制偏移量的值+N</li>
</ul>
<p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态:</p>
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>
<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li>
</ul>
<p>复制积压缓冲区是一个由主服务器维护的固定长度，先进先出队列，默认大小为1MB。当主从断开连接，再次连接时,从服务器会通过<code>PSYNC</code>将自己的复制偏移量<code>offset</code>发送给主服务器:</p>
<ul>
<li>如果<code>offset</code>偏移量之后的数据存在于复制积压缓冲区，那么主服务器将对从服务器执行部分重同步操作。</li>
<li>如果<code>offset</code>偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器会对从服务器执行完整重同步操作。</li>
</ul>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率，祥主服务器发送命令<code>REPLICONF ACK &lt;replication_offset&gt;</code>, 其中<code>replication_offset</code>是当前从服务器的复制偏移量, 这个<code>心跳检测</code>的作用如下:</p>
<ul>
<li><strong>检测主从服务器的网络状态</strong>:如果主服务器超过一秒钟没收到从服务器发送的<code>REPLICONF ACK</code>命令，那么主服务器就知道主从服务器之间的连接出现问题了。</li>
<li><strong>辅助实现min-slaves选项</strong>:Redis的<code>min-slaves-to-write</code>和<code>min-slaves-max-log</code>两个选项可以防止主服务器在不安全的情况下执行写命令。</li>
<li><strong>检测命令丢失</strong>:如果因为网络故障，主服务器传播给从服务器的写命令半路丢失，那么从服务器发送的偏移量就会小于主服务器的偏移量，这时候主服务器会从复制积压缓冲区中重新把命令发送给从服务器。(2.8版本之前没有这个功能，所以会出现丢失的情况)</li>
</ul>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel(哨岗，哨兵)是Redsi的高可用性(high availability)解决方案:由一个或多个Sentinel实例(instance)组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。另外Sentinel还会继续监视已下线的服务器，并在它重新上时，将它设置为新的主服务器的从服务器(降级)。<br>启动Sentinel可以使用命令: <code>redis-sentinel /path/to/your/sentinel.conf</code> 或 <code>redis-server /path/to/your/sentinel.conf --sentinel</code>, 启动时需要执行一下步骤:</p>
<ul>
<li>初始化服务器: Sentinel本质上是一个运行在特殊模式下的Redis服务器，启动初始换与原来有所不同。</li>
<li>将普通Redis服务器使用的代码替换成Sentinel专用代码:初始换Sentinel可以执行的命令，替换之前的默认命令。</li>
<li>初始化Sentinel状态:初始化<code>sentinel.c/sentinelState</code>结构，这个结构保存了服务器中所有Sentinel相关的状态。</li>
<li>根据跟定的配置文件，初始化Sentinel的监视主服务器列表:Sentinel状态中的<code>masters</code>字典记录了所有被Sentinel监视的主服务器的相关信息，其中字典的键是被监视主服务器的名字；而字典的值则是被监视主服务器对应的<code>sentinel.c/sentinelRedisInstance</code>结构。</li>
<li>创建连向主服务器的网络连接: 最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息。对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接:<ul>
<li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li>
<li>另一个是订阅连接，这个链接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么有两个连接?<br>在Redis目前的发布与订阅功能中，被发送的信息不回保存在Redis服务器里，如果发送信息时，接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。<strong>为了不丢失任何信息，必须专门用一个订阅连接来接收该频道的信息</strong>(原理?)。另外除了订阅频道，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接。</p>
</blockquote>
<h3 id="Sentinel网络拓扑"><a href="#Sentinel网络拓扑" class="headerlink" title="Sentinel网络拓扑"></a>Sentinel网络拓扑</h3><p>Sentinel与主服务器，从服务器及其他Sentinel之间都是彼此连接的:</p>
<ul>
<li>首先Sentinel默认<code>每10秒一次</code>向主服务器发送INFO命令，Sentinel可以得到主服务器信息以及主服务器的从服务器信息;</li>
<li>Sentinel会更新自己的主服务器和从服务器信息，还会创建连接到从服务器的命令连接和订阅连接。</li>
<li>Sentinel还会默认<code>每2秒一次</code>通过命令连接向所有被监视的主服务器和从服务器发送命令，这条命令会向服务器的<code>__sentinel__:hello</code>频道发送一条信息</li>
<li>由于Sentinel订阅了主服务器和从服务器的消息，所以所有订阅的Sentinel都会收到上面的信息，接收消息的Sentinel就会感知到发消息的Sentinel存在，并记录到<code>sentinels</code>属性中(可以实现自动发现功能)</li>
</ul>
<h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><h4 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h4><p>默认情况下Sentinel会以<code>每秒一次</code>的频率向所有与它创建了命令连接的实例(包括主服务器，从服务器，其他Sentinel等)发送PING命令, 并通过实例返回的PING命令回复判断是否在线。由于每个Sentinel设置的下线时间标准可能不一样，所以会出现不同的Sentinel认为服务器的状态不一致，所以这种情况称为主观下线状态。</p>
<h4 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h4><p>当Sentinel从其他Sentinel那里接收的足够数量的已下线判断之后，Sentinel就会认为将主服务器判定为客观下线状态，并对主服务器执行故障转移操作。</p>
<h4 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h4><p>当主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头的Sentinel，并由领头Sentinel对下线服务器执行故障转移。<br>选举策略是每个检测到主服务器下线的Sentinel都向其他Sentinel发送想要成为领头的命令，收到命令的Sentinel会将发送命令的Sentinel设置为局部领头，如果一个Sentinel被半数以上的Sentinel设置为局部领头，它就胜出，否则会进行再次选举。</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>选举出领头Sentinel后，领头Sentinel将对已下线的主服务器执行故障转移操作:</p>
<ul>
<li>在已下线服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器: 选择优先级高，复制偏移量大的从服务器，使用命令<code>SLAVE of one</code>使其变为主服务器。</li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器: 领头Sentinel向其他从服务器发送<code>SLAVEOF</code>命令。</li>
<li>将已下线的主服务器设置为心的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p>
<h3 id="节点与槽"><a href="#节点与槽" class="headerlink" title="节点与槽"></a>节点与槽</h3><p>Redis集群通常由多个节点(node)组成，开始每个节点都是图例的，它们都处于一个只包含自己的集群中，当要组建一个真正可工作的集群，我们必须将节点连接起来，构成一个包含多个节点的集群。使用<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>命令来完成。另外Redis服务器启动时也可以根据<code>cluster-enabled</code>配置选项来判断是否开启集群模式。节点信息保存在<code>cluster.h/clusterNode</code>结构中，<code>clusterNode</code>结构保存了一个节点的当前状态，比如节点的创建时间，节点的名等;<code>clusterNode</code>的<code>link</code>属性是一个<code>clusterLink</code>结构，该结构保存了连接节点所需的有关信息,比如套接字描述符，输入缓冲区和输出缓冲区; 每个节点都保存着一个<code>clusterState</code>结构，这个结构记录了当前节点的视角下，集群目前所处的状态，例如机器是在线还是下线，集群包含多少节点等。<br>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为<code>16384</code>(=2048*8)个槽(slot),数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。当数据库中的16384个槽有节点在处理时，集群处于一个上线状态(ok);相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态(fail)。<br>槽指派信息记录在<code>clusterNode.slots[16384/8]</code>属性中, <code>numslots</code>记录了节点负责处理的槽的数量。Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位来判断节点是否负责处理槽i:</p>
<ul>
<li>如果slots数组在索引i上的二进制位值为1，那么表示节点负责处理槽i。</li>
<li>如果slots数组在索引i上的二进制位值为0, 那么表示节点不负责处理槽i。</li>
</ul>
<p>节点会把自己处理的槽信息发送给其他集群中的其他节点，因此集群中的每个节点都会知道数据库中16384个槽分别被指派给了集群中哪些节点。<br><code>clusterState</code>结构中的<code>slots[16384]</code>数组则更上面的正好反过来，它记录了每个槽是由哪个节点在管理的。之所以会有这两种结构是为了在查找节点管理了哪些槽和槽由哪个节点管理的复杂度都降低了。</p>
<h3 id="集群中的执行命令"><a href="#集群中的执行命令" class="headerlink" title="集群中的执行命令"></a>集群中的执行命令</h3><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽(使用crc16(key)&amp;16383算法得出槽位置)，并检查这个槽是否指派给了自己(clusterState.slots[i]是否为自己):</p>
<ul>
<li>如果键所在的槽正好指派给了当前节点，那么节点直接执行这个命令。</li>
<li>如果键所在的槽没有指派给了当前节点，那么节点回向客户端返回一个MOVED错误，指引客户端转向(redirect)至正确的节点，并再次发送之前想要执行的命令。</li>
</ul>
<p>节点与单机服务器在数据库方面的区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制。<br>节点还会使用<code>clusterState</code>结构中的<code>slots_to_keys</code>跳跃表来保存槽和键之间的关系，主要目的是方便节点对属于某个或某些槽的所有数据库键进行批量操作。</p>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目的节点)，并且相关槽所属的键值对也会从源节点移动到目的节点。这个过程可以在线进行，在重新分片过程中，集群不需要下线，并且源节点和目的节点都可以继续处理命令请求。<br>Redis的重新分片操作是由Redis的集群管理软件<code>redis-trib</code>负责执行的。迁移过程如下:<br><img src="/assets/img/redis/redis_trib.png" alt="redis-trib"><br>在执行第四步迁移的过程中，如果客户端向源节点发送一个与数据库键有关的命令，那么:</p>
<ul>
<li>源节点先在自己数据库里查找指定的键，如果找到就直接执行客户端发送的命令.</li>
<li>如果没找到，那么这个键可能已经被迁移到了目标节点，源节点向客户端返回一个ASK错误，指引客户端转向正在导入槽的目的节点，并再次发送之前想要执行的命令。<br>当客户端接收到ASK错误并转向正在执行导入槽节点时，客户端会先向节点发送一个<code>ASKING</code>命令，然后才重新发送想要执行的命令。ASKING命令会打开发送客户端的<code>REDIS_ASKING</code>标识。<br>一般情况下如果客户端向节点发送一个关于槽i的命令，如果节点没有这个槽，那么就会返回<code>MOVED</code>，但是如果节点的<code>clusterState.importing_slots_from[i]</code>显示节点正在导入槽i,并且发送命令的客户端带有<code>REDIS_ASKING</code>（通过<code>ASKING</code>命令打开)标识，那么节点将执行这个关于槽i的命令一次</li>
</ul>
<p>关于ASK错误与MOVED错误的区别:</p>
<ul>
<li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点，客户端收到关于槽i的MOVED错误后，每次遇到槽i请求是，都可以直接将命令发送至MOVED错误所指向的节点。</li>
<li>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施, 不会影响后面命令的发送。</li>
</ul>
<h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分为主节点(master)和从节点(slave),其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。设置从节点的命令:<code>CLUSTER REPLICATE &lt;node_id&gt;</code><br>集群中的每个节点都会定期地祥集群中其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记位疑似下线(probable fail, PFAIL)。如果一个集群里，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线(FAIL), 将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点X标记为下线。<br>当一个从节点发现自己正在复制的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，下面是故障转移执行的步骤:</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中:选举过程和Sentinel差不多。</li>
<li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条PONG消息，可以让集群中其他节点立即知道这个节点从从节点变为了主节点，并且这个主节点已经接管了原本由已下线主节点负责处理的槽。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面主要讲了Redis在多机数据库下的功能特性，其中复制是实现数据备份，数据可靠性的保证。Sentinel实现高可用性的保证。在3.0版本之前的分布式方案都是自己实现的，然后利用Sentinel进行监控。后来Redis自己实现了集群方案，可以用其默认的集群方案来代替之前的自己实现方案。他们之间是相辅相成的，根据自己的需要进行选择。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.zhihu.com/question/21419897" target="_blank" rel="noopener">Redis集群方案应该怎么做?</a></li>
<li><a href="http://rdc.hundsun.com/portal/article/669.html" target="_blank" rel="noopener">如何部署高可用的Redis集群架构</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/05/The-Design-and-Implementation-of-Redis-2/"><span>Redis设计与实现总结——单机数据库的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/05/The-Design-and-Implementation-of-Redis-2/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-05T11:02:37.000Z">
          2017-03-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>一个Redis Server可以有多个Redis数据库，这点类似于MySQL, 从Redis Server的源代码中可以看到,<code>redisDb</code>是Server数据库的指针，指向一个数据库组成的数组，而数据库的数量则由<code>dbnum</code>属性来表示。客户端可以通过<code>SELECT</code>命令选择当前要操作的数据库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库数组指针</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;                      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据库的定义在<code>redis.h/redisDb</code>中，定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以解除阻塞的键</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库号码</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>dict</code>: 是一个字典，保存了数据库中的所有键值对，我们将这个字典称为键空间(key space)。</li>
<li><code>expires</code>: 也是一个字典，保存的是键值与这个键值过期时间的键值对。</li>
</ul>
<p>一个简化的结构图如下:<br><img src="/assets/img/redis/redis_db.png" alt="db结构"><br>设置生存时间和过期时间时，最终都是计算出最后生存时间，然后把这个值存入<code>expires</code>字典中。过期字典中找不到证明没有设置过期时间。过期删除策略Redis主要是使用惰性删除策略与定期删除两种策略。所谓惰性删除策略就是当用户获取键时，先判断其是否过期，如果过期则删除键，返回失败，如果没过期则正常返回。定期删除策略是Redis会周期行的从过期字典中随机出一部分键值，如果过期则删除键，否则保留。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB(redis database)持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中(RDB文件默认的文件名为<code>dump.rdb</code>)。RDB持久化功能锁生成的RDB文件是一个经过压缩的二进制文件，通过该文件还可以还原生成RDB文件时的数据库状态。<br>有两个Redis命令可以用于生成RDB文件，一个是<code>SAVE</code>, 另一个是<code>BGSAVE</code>。<code>SAVE</code>会阻塞Redis服务进程，知道RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何请求。<code>BGSAVE</code>命令会派生出一个子进程,然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求。<br>RDB文件是在服务器启动时自动执行的，只要Redis服务器启动时检测到RDB文件存在，它就会自动载入RDB文件。但是如果服务器开启了AOF持久化功能，就会优先使用AOF文件。因为AOF文件的更新频率通常比RDB文件高，所以数据是最新的可能性高。<br>用户可以通过save选项设置多个保存条件，但只要其中任意一条被满足，服务器就会执行<code>BGSAVE</code>命令。例如配置为下面三个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p>
<p>只要满足900s内至少一次修改，或300s内至少10次修改，或60s内10000次修改就会自动执行<code>BGSAVE</code>命令。<br>服务器维护一个<code>dirty</code>计数器，用于记录距离上次成功执行<code>SAVE</code>或<code>BGSAVE</code>命令之后，服务器对数据库状态进行了多少次修改(包括写入，删除，更新等操作)。<br>服务器还维护一个<code>lastsave</code>属性，记录服务器上一次成功执行<code>SAVE</code>或<code>BGSAVE</code>命令的时间。<br>RDB文件结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----+----------+---------+---+---------+</span><br><span class="line">|     |          |         |   |         |</span><br><span class="line">|REDIS|db_version|databases|EOF|check_sum|</span><br><span class="line">|     |          |         |   |         |</span><br><span class="line">+-----+----------+---------+---+---------+</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>REDIS</code>: RDB文件开头是REDIS部分，这个部分长度为5字节,保存着”REDIS”五个字符。通过五个字符，快速检测是否为RDB文件。</li>
<li><code>db_version</code>: 长度为4字节，它的值是一个字符串表示的整数，记录了RDB文件的版本号。</li>
<li><code>databases</code>: 包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li>
<li><code>EOF</code>: 长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕。</li>
<li><code>check_sum</code>: 8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对前面四部分的内容计算得出的。服务器载入RDB文件时，会将载入数据所计算出的校验和与<code>check_sum</code>所记录的检验和进行对比，以此来检查RDB文件是否出错或者有损坏的情况。<br>可以使用<code>od -c dump.rdb</code>或<code>od -cx dump.rdb</code>命令来对RDB文件内容进行分析。</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF(Append Only File)持久化功能是通过保存Redis服务器所执行的写命令来记录数据库状态的。AOF持久化功能的实现可以分为命令追加(append), 文件写入，文件同步(sync)三个步骤:</p>
<ul>
<li>命令追加: 服务器执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</li>
<li>AOF文件的写入与同步: 服务器的每次时间循环结束之前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里。<br><code>flushAppendOnlyFile</code>函数的行为由服务器配置的<code>appendfsync</code>选项的值来决定:</li>
</ul>
<table>
<thead>
<tr>
<th>appendfsync选项的值</th>
<th>flushAppendOnlyFile函数的行为</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>将aof_buf缓冲区中的所有内容写入并同步到AOF文件</td>
<td>性能最低，但是安全性最高，发生故障停机最多丢失一个循环事件所产生的在缓冲区中的命令</td>
</tr>
<tr>
<td>everysec(默认值)</td>
<td>将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1s,那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的</td>
<td>性能足够快，并且出现故障停机，最多丢失一秒钟的命令数据</td>
</tr>
<tr>
<td>no</td>
<td>将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统决定</td>
<td>性能最好，写入AOF速度最快，但是单次同步时间最长，出现故障丢失的命令最多</td>
</tr>
</tbody>
</table>
<p>由于AOF文件记录了重建数据库所需的所有写命令，所以服务器只要读入并执行一遍AOF文件里么保持的写命令，就可以还原服务器关闭之前的状态。<br>由于AOF持久化是通过保存被执行的写命令来记录数据库状态的，随着时间的推移，写命令越来越多，这时候就需要<code>AOF重写</code>来减轻文件体积的膨胀。<br><code>AOF重写</code>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录的这个键值对的多条命令。但是在重写列表，哈希表，集合，有序集合等多个元素的键时，如果元素的数量超过了<code>redis/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>常量的值，会通过多条命令来记录键的值。<br>一个问题是在AOF重写期间，服务器还需要处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。为了解决这个问题，Redis服务器设置了一个<code>AOF重写缓冲区</code>，这个缓冲区在服务器创建子进程进行重写是开始使用,当Redis服务器执行完一个写命令后，它会同事将这个命令发送给AOF缓冲区和<code>AOF重写缓冲区</code>。当AOF重写工作完成后，向父进程发送信号，父进程就会将<code>AOF重写缓冲区</code>中的所有内容写到新的AOF文件中，对新的AOF文件进行改名，原子地 （atomic)覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>文件事件(file event): Redis服务器通过套接字与客户端(或其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。<br>下图是Redis自己实现的文件事件处理器的四个组成部分:<br><img src="/assets/img/redis/redis_fileevent.png" alt="db结构"></p>
<ul>
<li>文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答(accept),读取(read),写入(write)，关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，着保持了Redis内部单线程设计的简单性。<br>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总会将所有产生事件的套接字都放在一个队列里，然后通过这个队列，以有序(sequentially),同步(synchronously)，每次一个套接字的方式向文件事件分派器传送套接字。<br>Redis的I/O多路复用程序的所有功能都是通过包装常见的<code>select</code>,<code>epoll</code>,<code>evport</code>和<code>kqueue</code>这些I/O多路复用函数库来实现的，编译时会自动选择性能高最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现。</p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件(time event): Redis服务器中的一些操作(如<code>serverCron</code>函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。<br>Redis的时间事件分为两类:</p>
<ul>
<li>定时事件: 让程序在指定的时间之后执行一次。</li>
<li>周期性事件: 让一端程序每隔指定的时间就执行一次。</li>
</ul>
<p>一个时间事件主要由以下三个属性:</p>
<ul>
<li>id: 服务器为时间事件创建的全局唯一ID(标识号)。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li>
<li>when: 毫秒精度的UNIX时间戳，记录了时间事件的到达(arrive)时间。</li>
<li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用响应的处理器来处理事件。</li>
</ul>
<p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p>
<ul>
<li>如果事件处理器返回<code>ae.h/AE_NOMORE</code>，那么这个事件为定时事件:该事件在达到一次之后就会被删除，之后不再到达。</li>
<li>如果事件处理器返回一个非<code>AE_NOMORE</code>的整数值，那么这个事件为周期性时间:当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间后再次到达，并以这种方式一直更新运行下去。</li>
</ul>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责,下面是这个函数的伪代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    // 获取到达时间离当前最接近的时间事件</span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    </span><br><span class="line">    // 计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    </span><br><span class="line">    // 如果事件已到达，那么remaind_ms的值就可能为负数，将它设定为<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    // 根据remaind_ms的值，创建timeval结构</span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    </span><br><span class="line">    // 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class="line">    // 如果remaind_ms的值为<span class="number">0</span>，那么aeApiPoll调用之后马上返回，不阻塞</span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">   </span><br><span class="line">    // 处理所有已产生的文件事件 </span><br><span class="line">    processFileEvents()</span><br><span class="line">    </span><br><span class="line">    // 处理所有已到达的时间事件</span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure></p>
<p>事件的调度和执行规则:</p>
<ol>
<li>aeApiPoll函数的最大阻塞时间由到达时间最接近的当前时间的时间事件决定，这个方法既可以避免服务器对时间事件并行频繁的轮询，可以确保aeApiPoll函数不会阻塞时间过长。</li>
<li>因为文件事件是随机出现的，如果处理完文件事件后时间事件仍未到达，继续等待并处理下一个文件事件。</li>
<li>对文件事件和时间事件的处理都是同步，有序，原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占。因此耗时的事件会影响整个服务的性能。</li>
<li>因为时间事件是在文件事件之后执行，并且事件之间不会抢占，所以时间事件的实际处理时间通常回避时间事件设定的到达时间稍微晚一些。</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>通过使用I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。<br>关于<code>redisClient</code>的定义可以从<code>redis.h</code>中看到，客户端有很多属性。这些属性可以分为两类:</p>
<ul>
<li>比较通用的属性，这些属性很少特定功能相关，无论客户端执行的是什么工作，它都需要这些属性。</li>
<li>和特定功能相关的属性。下重点介绍这些。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>fd(fake client)</code>: 伪客户端的fd属性的值为<code>-1</code>,伪客户端处理的命令请求来自于AOF文件或者lua脚本; 普通客户端fd属性值是大于-1的整数，使用套接字与服务器通信，所以fd用来记录客户端套接字的描述符。</li>
<li><code>name</code>: 默认情况下一个连接到服务器的客户端是没有名字的，但是可以使用<code>CLIENT setnaem</code>命令设置一个名字，可以通过<code>CLIENT list</code>查看。</li>
<li><code>flags</code>: 一部分标志记录了客户端的角色(如REDIS_MASTER代表主服务器, REDIS_SLAVE代表从服务器), 另一部分标志记录了客户端目前所处的状态(REDIS_MONITOR正在执行monitor, REDIS_MULTI标志客户端正在执行事务)。</li>
<li><code>querybuf</code>: 用于保存客户端发送的命令请求。输入缓冲区的大小会根据输入内容动态调整，但是最大不能超过1GB,否则服务器将关闭这个客户端。</li>
<li><code>argv</code>和<code>argc</code>: 服务器将客户端发送的名保存到<code>querybuf</code>后，对命令内容进行分析，得出命令参数及命令的参数个数分别保存到<code>argv</code>和<code>argc</code>中。</li>
<li><code>authenticated</code>: 记录客户端是否通过了身份验证，未通过用0表示，通过用1表示。</li>
<li><code>ctime</code>: 记录创建客户端的时间。</li>
<li><code>lastinteraction</code>: 记录客户端与服务器最后一次进行互动的时间。</li>
<li><code>obuf_soft_limit_reached_time</code>: 记录输出缓冲区第一次到达软性显示的时间。</li>
</ul>
<p>执行命令所得的命令回复会被保存到客户端状态的输出缓冲区里，每个客户端都有两个输出缓冲区可用</p>
<ul>
<li><code>buf</code>和<code>bufpos</code>: 固定的换缓冲区，用于保存那些长度比较小的回复，如:OK, 简短的字符串值，整数值或错误回复等。<code>buf</code>是缓冲区，<code>bufpos</code>记录<code>buf</code>数组目前已经使用的字节数量。</li>
<li><code>reply</code>: 可变大小的缓冲区是一个链表,用于保存比较大的回复，比如一个非常长的字符串值，列表等。</li>
</ul>
<h3 id="创建与关闭"><a href="#创建与关闭" class="headerlink" title="创建与关闭"></a>创建与关闭</h3><ul>
<li><strong>创建不同客户端</strong>: 如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端connect函数连接到服务器时，服务器就会调用连接事件处理器为客户端创建响应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</li>
<li><strong>关闭客户端</strong>: 一个普通客户端被关闭的原因有很多:<ul>
<li>客户端进程退出或被杀死</li>
<li>客户端向服务器发送了带有不符合协议格式的命令请求</li>
<li>客户端成了CLIENT KILL命令的目标</li>
<li>用户为服务器设置了timeout配置选项，客户端空转时间超过timeout选项设置的值</li>
<li>客户端发送的命令请求大小超过了输入缓冲区的限制大小(1GB)</li>
<li>发送给客户端的命令回复超过输出缓冲区的限制大小。按理说输出缓冲区是没有大小限制的，但是为了防止过多占用服务器资源，采用硬性限制和软性限制两种方案限制大小。</li>
</ul>
</li>
<li><strong>Lua脚本的伪客户端</strong>: 服务器在初始化时负责创建Lua脚本中包含的Redis命令的伪客户端，在服务器运行的整个周期中都会存在。</li>
<li><strong>AOF文件的伪客户端</strong>: 服务器载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成后关闭。</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>前面讲了，客户端发送的请求会被放到输入缓冲区，然后服务器对命令进行解析，转换成协议格式，服务器将通过调用命令执行器来完成余下的步骤:</p>
<ul>
<li><strong>查找命令</strong><br>根据上面说的<code>argv[0]</code>参数中对应的命令在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的<code>cmd</code>属性里。<br>命令表是一个字典，字典的键是一个个命令名字，比如”set”,”get”,”del”等;而字典的值则是一个个<code>redisCommand</code>结构，每个<code>redisCommand</code>结构记录了一个Redis命令的实现信息。</li>
</ul>
<p><code>redisCommand</code>结构的主要属性:</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>char *</td>
<td>命令的名字，比如”set”</td>
</tr>
<tr>
<td>proc</td>
<td>redisCommandProc *</td>
<td>函数指针，指向命令的实现函数</td>
</tr>
<tr>
<td>arity</td>
<td>int</td>
<td>命令参数的个数，用于检查命令请求的格式是否正确</td>
</tr>
<tr>
<td>sflags</td>
<td>char *</td>
<td>字符串形式的标识值，这个值记录了命令的属性<br>例如:<br>w:表示写入命令<br>r:只读命令<br>m:可能会占用大量内存的命令<br>a:这是一个管理命令</td>
</tr>
<tr>
<td>flags</td>
<td>int</td>
<td>对sflags标识进行分析得出的二进制标识，由程序自动生成</td>
</tr>
<tr>
<td>calls</td>
<td>long long</td>
<td>服务器总共执行了多少次这个命令</td>
</tr>
<tr>
<td>milliseconds</td>
<td>long long</td>
<td>服务器执行这个民两个所耗费的总时长</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>执行预备操作</strong><br>到目前为止，服务器已经将执行命令所需的命令实现函数,参数等都收集齐了，真正执行命令之前还需要一些预备操作：</p>
<ul>
<li>检查客户端状态的cmd指针是否执行NULL</li>
<li>检查命令请求所给定的参数个数是否正确</li>
<li>检查客户端是否已经通过了身份验证</li>
<li>如果服务器打开了<code>maxmemory</code>功能，需要检查服务器的内存占用情况，在有需要的时候进行内存回收</li>
<li>其他检查和限制执行的操作等</li>
</ul>
</li>
<li><p><strong>调用命令的实现函数</strong><br>当服务器决定要执行命令是<code>client-&gt;cmd-&gt;proc(client);</code>, 执行函数后会把回复保存到客户端的输出缓冲区，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将回复返回给客户端。</p>
</li>
<li><strong>执行后续工作</strong><br>在执行完实现函数后，服务器还需要执行一些后续工作:<ul>
<li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会坚持是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li>
<li>根据刚刚执行命令所耗费的时长，更被执行命令redisCommand结构的milliseconds属性，并将calls计数器加一</li>
<li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里。</li>
<li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器</li>
<li>根据刚刚执行命令所耗费的时长，更被执行命令redisCommand结构的milliseconds属性，并将calls计数器加一</li>
<li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里。</li>
<li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li>
</ul>
</li>
</ul>
<p>回复发送完毕后，回复处理器会清空客户端状态的输出缓冲区，未处理下一个命令请求做好准备。当客户端接收到协议格式的命令回复后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p>
<h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的<code>serverCron</code>函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。<code>serverCron</code>的函数主要功能如下面所列:</p>
<ul>
<li><strong>更新服务器时间缓存</strong>: 为了减少获取服务器时间而进行系统调用的次数，服务器状态中的<code>unixtime</code>和<code>mstime</code>属性被用作当前时间的缓存，serverCron函数默认每100ms的频率更新这两个字段。对于设置键值过期时间，慢查询日志这种需要高精度时间的功能来说，服务器还是会再次执行系统调用。</li>
<li><strong>更新LRU时钟</strong>: 服务器状态中的lruclock属性保存了服务器的LRU时钟;每个Redis对象都会有一个lru属性，保存了对象最后一次被访问的时间。这个值也是用serverCron来更新。</li>
<li><strong>更新服务器每秒执行命令次数</strong>: <code>serverCron</code>函数中的<code>trackOperationsPerSecond</code>函数会以每100ms一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。可以通过<code>INFO stats</code>查看。</li>
<li><strong>更新服务器内存峰值记录</strong>:<code>serverCron</code>每次都会查看服务器当前使用的内存数量，并与<code>stat_peak_memory</code>保持的值进行比较，如果当前的数据比较大就更新这个值。<code>INFO memory</code>命令可以查看具体的数据。</li>
<li><strong>处理SIGTERM信号</strong>:服务器启动时，Redis会为服务器进程的<code>SIGTERM</code>信号关联处理器<code>sigtermHandler</code>函数，这个信号处理器负责在服务器接到<code>SIGTERM</code>信号时，打开服务器状态的<code>shutdown_asap</code>标识。如果不拦截这个信号，可能会造成比如RDB持久化操作时关闭服务器。</li>
<li><strong>管理客户端资源</strong>:<code>serverCron</code>函数每次执行都会调用<code>clientsCron</code>函数，<code>clientsCron</code>函数会对一定数量的客户端进行以下两个检查:<ul>
<li>如果客户端与服务器之间的连接已经超时,那么程序释放这个客户端。</li>
<li>如果客户端在上一次执行命令请求后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</li>
</ul>
</li>
<li><strong>管理数据库资源</strong>: 每次调用<code>databasesCron</code>函数，对服务器中一部分数据库进行检查，删除其中的过期键，并在需要时，对字典进行收缩操作。</li>
<li><strong>执行被延迟的BGREWRITEAOF</strong></li>
<li><strong>检查持久化操作的运行状态</strong></li>
<li><strong>将AOF缓冲区的内容写入到AOF文件</strong></li>
<li><strong>关闭异步客户端</strong></li>
<li><strong>增加cronloops计数器的值</strong>:<code>cronloops</code>记录了<code>serverCron</code>函数执行的次数。</li>
</ul>
<h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程。过程如下:</p>
<ul>
<li><strong>初始化服务器状态结构</strong>:包括设置服务器的运行ID,设置服务器的默认运行频率，设置服务器的默认配置文件路径，设置服务器默认端口号，设置服务器默认持久化条件等。</li>
<li><strong>载入配置选项</strong>: 可以通过给定配置函数或指定配置文件来修改服务器的默认配置。</li>
<li><strong>初始化服务器数据结构</strong>:包括初始化<code>server.clients</code>链表，初始化执Lua脚本的执行环境<code>server.lua</code>等;还进行了创建共享对象，打开服务器的监听端口等操作。</li>
<li><strong>还原数据库状态</strong>: 完成初始化后，服务器需要载入<code>RDB</code>文件或者<code>AOF</code>文件，并根据文件记录的内容来还原服务器的数据库状态。</li>
<li><strong>执行事件循环</strong>: 初始完成后，开始执行服务器的事件循环(loop)。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>