<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Go Interface 源码解析 | oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  
  <meta name="description" content="本文基于go1.12.4源码

源码类型定义:runtime/runtime2.go
不含method的interface1234type eface struct &amp;#123;    _type *_type    data  unsafe.Pointer&amp;#125;
包含method的inter">
  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Go Interface 源码解析">

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Go Interface 源码解析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/09/02/go-interface-implement/" rel="bookmark">
        <time class="entry-date published" datetime="2019-09-02T02:18:00.000Z">
          2019-09-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本文基于<code>go1.12.4</code>源码</p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义:"></a>类型定义:</h3><p><code>runtime/runtime2.go</code></p>
<h4 id="不含method的interface"><a href="#不含method的interface" class="headerlink" title="不含method的interface"></a>不含<code>method</code>的<code>interface</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含method的interface"><a href="#包含method的interface" class="headerlink" title="包含method的interface"></a>包含<code>method</code>的<code>interface</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eface-分析"><a href="#eface-分析" class="headerlink" title="eface 分析"></a><code>eface</code> 分析</h2><p>首先写一个<code>eface</code>的具体<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br><span class="line">    e := *(*eface)(unsafe.Pointer(&amp;inter))</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, e)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *(*<span class="keyword">int</span>)(e.data))</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, &amp;num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    kind       <span class="keyword">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tflag <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// function for hashing objects of this type</span></span><br><span class="line">    <span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">    hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">    // <span class="title">function</span> <span class="title">for</span> <span class="title">comparing</span> <span class="title">objects</span> <span class="title">of</span> <span class="title">this</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">    // <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function">    <span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">nameOff</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">typeOff</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure></p>
<p>对应汇编:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">782</span> args=<span class="number">0x0</span> locals=<span class="number">0x128</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (main.go:<span class="number">8</span>)    TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$296</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0032</span> <span class="number">00050</span> (main.go:<span class="number">9</span>)    LEAQ    type.int(SB), <span class="built_in">AX</span> <span class="comment">;  通过 type.int  把 int 类型 转换为 *_type  类型，并把地址放到寄存器 AX</span></span><br><span class="line">    <span class="number">0x0039</span> <span class="number">00057</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)<span class="comment">; 把 AX 内容放到栈底, 这里是下一个函数 newobject 调用的参数</span></span><br><span class="line">    <span class="number">0x003d</span> <span class="number">00061</span> (main.go:<span class="number">9</span>)    <span class="keyword">CALL</span>    runtime.newobject(SB) <span class="comment">; 函数调用</span></span><br><span class="line">    <span class="number">0x0042</span> <span class="number">00066</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; newobject 返回值放到8(SP), 然后再放到 AX</span></span><br><span class="line">    <span class="number">0x0047</span> <span class="number">00071</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.&amp;num+<span class="number">128</span>(<span class="built_in">SP</span>)<span class="comment">; 返回值从 AX 放到 &amp;num 变量位置, 表示 num 的地址</span></span><br><span class="line">    <span class="number">0x004f</span> <span class="number">00079</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="number">$3</span>, (<span class="built_in">AX</span>)<span class="comment">; (AX)表示 AX 的地址对应的值, 赋值为 3</span></span><br><span class="line">    <span class="number">0x0056</span> <span class="number">00086</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.&amp;num+<span class="number">128</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; num 地址的值赋值个 AX </span></span><br><span class="line">    <span class="number">0x005e</span> <span class="number">00094</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    (<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; AX 值是地址，其对应的值赋值给 AX, 也就是常量 3</span></span><br><span class="line">    <span class="number">0x0061</span> <span class="number">00097</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_7+<span class="number">64</span>(<span class="built_in">SP</span>)<span class="comment">; 把这个值赋值给一个临时变量 autotmp_7</span></span><br><span class="line">    <span class="number">0x0066</span> <span class="number">00102</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>) <span class="comment">; 把值赋值给SP，栈底，是下一个函数 convT64 的参数</span></span><br><span class="line">    <span class="number">0x006a</span> <span class="number">00106</span> (main.go:<span class="number">10</span>)   <span class="keyword">CALL</span>    runtime.convT64(SB)<span class="comment">; 调用 runtime.convT64, 参数为 uint64, 返回值为 unsafe.Pointer</span></span><br><span class="line">    <span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; convT64 返回值放到8(SP), 并且赋值到 AX</span></span><br><span class="line">    <span class="number">0x0074</span> <span class="number">00116</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_8+<span class="number">80</span>(<span class="built_in">SP</span>)<span class="comment">; AX 的值放到临时变量 `autotmp_8`</span></span><br><span class="line">    <span class="number">0x0079</span> <span class="number">00121</span> (main.go:<span class="number">10</span>)   LEAQ    type.int(SB), <span class="built_in">CX</span> <span class="comment">; 通过 type.int  把 int 类型 转换为 *_type  类型，并把地址放到寄存器 CX</span></span><br><span class="line">    <span class="number">0x0080</span> <span class="number">00128</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.inter+<span class="number">136</span>(<span class="built_in">SP</span>)<span class="comment">; 将 CX 中代表*_type 地址的值放到 inter 变量eface类型的 _type 变量中</span></span><br><span class="line">    <span class="number">0x0088</span> <span class="number">00136</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.inter+<span class="number">144</span>(<span class="built_in">SP</span>)<span class="comment">; 将 AX 中代表 convT64返回值 3 的 unsafe.Pointer 类型 放到 inter 变量 eface 类型的 data 中 </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p> 这里只关注<code>main.go:9</code>和<code>main.go:10</code>的处理, 对应代码为:<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> num := <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>初始化变量<code>num</code>为<code>int</code>类型，并赋值为<code>3</code>, 具体的过程已经在前面汇编代码中通过注释的方式标出，下面来看一些细节:</p>
<ol>
<li>新建 <code>int</code> 类型变量需要申请内存, 通过<code>runtime.newobject</code>来申请</li>
<li><code>type.int</code>  可以获取 <code>int</code>类型的 <code>_type</code> 结构的地址 <code>*_type</code> (具体实现方式被编译优化了，需要再进一步深究)</li>
<li><p><code>MOVQ AX, (SP)</code>是为了把前面放到<code>AX</code>的<code>*_type</code> 放到栈底, 这个位置下面调用函数<code>runtime.newobject</code>的参数, 具体函数实现:</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完函数调用用会把返回值<code>unsafe.Pointer</code>放到<code>8(SP)</code>, 然后在放入 <code>AX</code></p>
</li>
<li><code>MOV $3,(AX)</code> 向表示寄存器<code>AX</code>包含的地址对应的值设置为常量<code>3</code></li>
<li><code>autotmp</code>是一个临时变量，是为了在程序内复用全局临时变量, 防止变量被修改:<br> <a href="https://github.com/golang/go/issues/21557" target="_blank" rel="noopener">https://github.com/golang/go/issues/21557</a>,<br> <a href="https://github.com/golang/go/issues/29547" target="_blank" rel="noopener">https://github.com/golang/go/issues/29547</a><br> <strong>具体需要再深入研究</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br></pre></td></tr></table></figure>
<p> 初始化变量<code>inter</code>,类型为<code>interface{}</code>, 并且指向<code>num</code>, 具体过程参考上面的注释部分，一些细节:</p>
<ol>
<li><p>这里会调用<code>runtime.convT64</code>函数，定义如下: ( 在<code>go 1.8</code>版本调用的是<code>runtime.convT2E</code>, 在<code>go1.10</code>调用的是<code>runtime.convT2E64</code>):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT64</span><span class="params">(val <span class="keyword">uint64</span>)</span> <span class="params">(x unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = mallocgc(<span class="number">8</span>, uint64Type, <span class="literal">false</span>)</span><br><span class="line">        *(*<span class="keyword">uint64</span>)(x) = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参就是 <code>num</code> 的值 <code>3</code>, 返回值是转换为<code>uint64</code>的值，并且申请一个地址，值为<code>3</code>, <strong>注意: 这里发生了值的<code>copy</code></strong></p>
</li>
<li>通过最后两行赋值<code>inter</code>, <code>inter</code>类型为<code>eface</code>, 定义前面提过，最终给<code>eface._type</code> 和<code>eface.data</code>赋值</li>
<li><code>eface.type</code>的查看这里还没有找到好的方法来查看，<code>dlv</code>无法深入到内置的实现。</li>
</ol>
<p>为了查看<code>_type</code> 类型，定义了一个跟 <code>runtime</code> 内部实现一样的数据结构，并且通过<code>unsafe</code>强制进行数据类型转换，可以得到<code>_type</code>的值。<br>借助<code>dlv</code>对上面的程序进行<code>debug</code>:</p>
<ol>
<li>在<code>e := *(*eface)(unsafe.Pointer(&amp;inter))</code>处打断点</li>
<li><p>执行到上面这行后打印出<code>e</code>的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p e</span><br><span class="line">main.eface &#123;</span><br><span class="line">        _type: *main._type &#123;</span><br><span class="line">                size: 8,</span><br><span class="line">                ptrdata: 0,</span><br><span class="line">                hash: 4149441018,</span><br><span class="line">                tflag: 7,</span><br><span class="line">                align: 8,</span><br><span class="line">                fieldalign: 8,</span><br><span class="line">                kind: 130,</span><br><span class="line">                alg: *(*main.typeAlg)(0x57adf0),</span><br><span class="line">                gcdata: *1,</span><br><span class="line">                str: 1059,</span><br><span class="line">                ptrToThis: 47520,&#125;,</span><br><span class="line">        data: unsafe.Pointer(0xc000080018),&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>*_type</code>源码的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有类型信息结构体的公共部分</span></span><br><span class="line"><span class="comment">// src/rumtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span>  <span class="comment">// 类型的大小</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span>  <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span>   <span class="comment">// 类型的Hash值</span></span><br><span class="line">    tflag      tflag    <span class="comment">// 类型的Tags </span></span><br><span class="line">    align      <span class="keyword">uint8</span>    <span class="comment">// 结构体内对齐</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span>    <span class="comment">// 结构体作为field时的对齐</span></span><br><span class="line">    kind       <span class="keyword">uint8</span>    <span class="comment">// 类型编号 定义于runtime/typekind.go</span></span><br><span class="line">    alg        *typeAlg <span class="comment">// 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span>     <span class="comment">// GC相关信息</span></span><br><span class="line">    str       nameOff   <span class="comment">// 类型名字的偏移    </span></span><br><span class="line">    ptrToThis typeOff    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为了查看<code>eface.data</code>的值，可以通过<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, *(*<span class="keyword">int</span>)(e.data))</span><br></pre></td></tr></table></figure></p>
<p> 输出，可以看到运行结果为<code>3</code>, 正是<code>num</code>的值。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p> 对于上面的程序我们只修改两行:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br><span class="line">    e := *(*eface)(unsafe.Pointer(&amp;inter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = <span class="number">3</span> </span><br><span class="line">    e := *(*eface)(unsafe.Pointer(&amp;inter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再查看其对应的汇编:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x002f</span> <span class="number">00047</span> (main.go:<span class="number">9</span>)    LEAQ    type.int(SB), <span class="built_in">AX</span> <span class="comment">; int 转为的_type类型</span></span><br><span class="line"><span class="number">0x0036</span> <span class="number">00054</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.inter+<span class="number">96</span>(<span class="built_in">SP</span>) <span class="comment">; 赋值给 inter._type</span></span><br><span class="line"><span class="number">0x003b</span> <span class="number">00059</span> (main.go:<span class="number">9</span>)    LEAQ    <span class="string">""</span>.statictmp_0(SB), <span class="built_in">AX</span> <span class="comment">; 取一个静态变量的是到 AX</span></span><br><span class="line"><span class="number">0x0042</span> <span class="number">00066</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.inter+<span class="number">104</span>(<span class="built_in">SP</span>) <span class="comment">; 赋值给 inter.data</span></span><br></pre></td></tr></table></figure></p>
<p><code>statictmp_0</code>代表的是一个全局静态变量，值是<code>3</code>:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.statictmp_0 SRODATA size=<span class="number">8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure></p>
<p>对于<code>statictmp</code> 时一个全局变量，一半的常量为了节省空间都会使用这个来代替，数据来源于’runtime/iface.go`:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// staticbytes is used to avoid convT2E for byte-sized values.</span></span><br><span class="line"><span class="keyword">var</span> staticbytes = [...]<span class="keyword">byte</span>&#123;</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>,</span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x0b</span>, <span class="number">0x0c</span>, <span class="number">0x0d</span>, <span class="number">0x0e</span>, <span class="number">0x0f</span>,</span><br><span class="line">    <span class="number">0x10</span>, <span class="number">0x11</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, <span class="number">0x15</span>, <span class="number">0x16</span>, <span class="number">0x17</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0x1a</span>, <span class="number">0x1b</span>, <span class="number">0x1c</span>, <span class="number">0x1d</span>, <span class="number">0x1e</span>, <span class="number">0x1f</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x21</span>, <span class="number">0x22</span>, <span class="number">0x23</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0x26</span>, <span class="number">0x27</span>,</span><br><span class="line">    <span class="number">0x28</span>, <span class="number">0x29</span>, <span class="number">0x2a</span>, <span class="number">0x2b</span>, <span class="number">0x2c</span>, <span class="number">0x2d</span>, <span class="number">0x2e</span>, <span class="number">0x2f</span>,</span><br><span class="line">    <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>,</span><br><span class="line">    <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x3a</span>, <span class="number">0x3b</span>, <span class="number">0x3c</span>, <span class="number">0x3d</span>, <span class="number">0x3e</span>, <span class="number">0x3f</span>,</span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x49</span>, <span class="number">0x4a</span>, <span class="number">0x4b</span>, <span class="number">0x4c</span>, <span class="number">0x4d</span>, <span class="number">0x4e</span>, <span class="number">0x4f</span>,</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>,</span><br><span class="line">    <span class="number">0x58</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x5b</span>, <span class="number">0x5c</span>, <span class="number">0x5d</span>, <span class="number">0x5e</span>, <span class="number">0x5f</span>,</span><br><span class="line">    <span class="number">0x60</span>, <span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x66</span>, <span class="number">0x67</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x69</span>, <span class="number">0x6a</span>, <span class="number">0x6b</span>, <span class="number">0x6c</span>, <span class="number">0x6d</span>, <span class="number">0x6e</span>, <span class="number">0x6f</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x71</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x76</span>, <span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x79</span>, <span class="number">0x7a</span>, <span class="number">0x7b</span>, <span class="number">0x7c</span>, <span class="number">0x7d</span>, <span class="number">0x7e</span>, <span class="number">0x7f</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x81</span>, <span class="number">0x82</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0x88</span>, <span class="number">0x89</span>, <span class="number">0x8a</span>, <span class="number">0x8b</span>, <span class="number">0x8c</span>, <span class="number">0x8d</span>, <span class="number">0x8e</span>, <span class="number">0x8f</span>,</span><br><span class="line">    <span class="number">0x90</span>, <span class="number">0x91</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>, <span class="number">0x95</span>, <span class="number">0x96</span>, <span class="number">0x97</span>,</span><br><span class="line">    <span class="number">0x98</span>, <span class="number">0x99</span>, <span class="number">0x9a</span>, <span class="number">0x9b</span>, <span class="number">0x9c</span>, <span class="number">0x9d</span>, <span class="number">0x9e</span>, <span class="number">0x9f</span>,</span><br><span class="line">    <span class="number">0xa0</span>, <span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>, <span class="number">0xa4</span>, <span class="number">0xa5</span>, <span class="number">0xa6</span>, <span class="number">0xa7</span>,</span><br><span class="line">    <span class="number">0xa8</span>, <span class="number">0xa9</span>, <span class="number">0xaa</span>, <span class="number">0xab</span>, <span class="number">0xac</span>, <span class="number">0xad</span>, <span class="number">0xae</span>, <span class="number">0xaf</span>,</span><br><span class="line">    <span class="number">0xb0</span>, <span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>, <span class="number">0xb4</span>, <span class="number">0xb5</span>, <span class="number">0xb6</span>, <span class="number">0xb7</span>,</span><br><span class="line">    <span class="number">0xb8</span>, <span class="number">0xb9</span>, <span class="number">0xba</span>, <span class="number">0xbb</span>, <span class="number">0xbc</span>, <span class="number">0xbd</span>, <span class="number">0xbe</span>, <span class="number">0xbf</span>,</span><br><span class="line">    <span class="number">0xc0</span>, <span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>, <span class="number">0xc4</span>, <span class="number">0xc5</span>, <span class="number">0xc6</span>, <span class="number">0xc7</span>,</span><br><span class="line">    <span class="number">0xc8</span>, <span class="number">0xc9</span>, <span class="number">0xca</span>, <span class="number">0xcb</span>, <span class="number">0xcc</span>, <span class="number">0xcd</span>, <span class="number">0xce</span>, <span class="number">0xcf</span>,</span><br><span class="line">    <span class="number">0xd0</span>, <span class="number">0xd1</span>, <span class="number">0xd2</span>, <span class="number">0xd3</span>, <span class="number">0xd4</span>, <span class="number">0xd5</span>, <span class="number">0xd6</span>, <span class="number">0xd7</span>,</span><br><span class="line">    <span class="number">0xd8</span>, <span class="number">0xd9</span>, <span class="number">0xda</span>, <span class="number">0xdb</span>, <span class="number">0xdc</span>, <span class="number">0xdd</span>, <span class="number">0xde</span>, <span class="number">0xdf</span>,</span><br><span class="line">    <span class="number">0xe0</span>, <span class="number">0xe1</span>, <span class="number">0xe2</span>, <span class="number">0xe3</span>, <span class="number">0xe4</span>, <span class="number">0xe5</span>, <span class="number">0xe6</span>, <span class="number">0xe7</span>,</span><br><span class="line">    <span class="number">0xe8</span>, <span class="number">0xe9</span>, <span class="number">0xea</span>, <span class="number">0xeb</span>, <span class="number">0xec</span>, <span class="number">0xed</span>, <span class="number">0xee</span>, <span class="number">0xef</span>,</span><br><span class="line">    <span class="number">0xf0</span>, <span class="number">0xf1</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>, <span class="number">0xf4</span>, <span class="number">0xf5</span>, <span class="number">0xf6</span>, <span class="number">0xf7</span>,</span><br><span class="line">    <span class="number">0xf8</span>, <span class="number">0xf9</span>, <span class="number">0xfa</span>, <span class="number">0xfb</span>, <span class="number">0xfc</span>, <span class="number">0xfd</span>, <span class="number">0xfe</span>, <span class="number">0xff</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译阶段会调用这个，  在<code>src/cmd/compile/internal/gc/walk.go</code> 中有相关代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> staticbytes == <span class="literal">nil</span> &#123;</span><br><span class="line">     staticbytes = newname(Runtimepkg.Lookup(<span class="string">"staticbytes"</span>)) <span class="comment">// 重 runtime 包中查找这个变量</span></span><br><span class="line">     staticbytes.SetClass(PEXTERN)</span><br><span class="line">     staticbytes.Type = types.NewArray(types.Types[TUINT8], <span class="number">256</span>)</span><br><span class="line">     zerobase = newname(Runtimepkg.Lookup(<span class="string">"zerobase"</span>))</span><br><span class="line">     zerobase.SetClass(PEXTERN)</span><br><span class="line">     zerobase.Type = types.Types[TUINTPTR]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Optimize convT2&#123;E,I&#125; for many cases in which T is not pointer-shaped,</span></span><br><span class="line"> <span class="comment">// by using an existing addressable value identical to n.Left</span></span><br><span class="line"> <span class="comment">// or creating one on the stack.</span></span><br><span class="line"> <span class="keyword">var</span> value *Node</span><br><span class="line"> <span class="keyword">switch</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> fromType.Size() == <span class="number">0</span>:</span><br><span class="line">     <span class="comment">// n.Left is zero-sized. Use zerobase.</span></span><br><span class="line">     cheapexpr(n.Left, init) <span class="comment">// Evaluate n.Left for side-effects. See issue 19246.</span></span><br><span class="line">     value = zerobase</span><br><span class="line"> <span class="keyword">case</span> fromType.IsBoolean() || (fromType.Size() == <span class="number">1</span> &amp;&amp; fromType.IsInteger()):</span><br><span class="line">     <span class="comment">// n.Left is a bool/byte. Use staticbytes[n.Left].</span></span><br><span class="line">     n.Left = cheapexpr(n.Left, init)</span><br><span class="line">     value = nod(OINDEX, staticbytes, byteindex(n.Left)) <span class="comment">// 编译时使用</span></span><br><span class="line">     value.SetBounded(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="iface-分析"><a href="#iface-分析" class="headerlink" title="iface 分析"></a><code>iface</code> 分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mather <span class="keyword">interface</span> &#123;</span><br><span class="line">        Add(a, b <span class="keyword">int32</span>) <span class="keyword">int32</span></span><br><span class="line">        Sub(a, b <span class="keyword">int64</span>) <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span>&#123; id <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Sub</span><span class="params">(a, b <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123; <span class="keyword">return</span> a - b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">        m := Mather(adder)</span><br><span class="line">		m.Add(<span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line">		m.Sub(<span class="number">19</span>, <span class="number">4</span>)</span><br><span class="line">        i := *(*iface)(unsafe.Pointer(&amp;m))</span><br><span class="line">        fmt.Printf(<span class="string">"%+v\n"</span>, i)</span><br><span class="line">		fmt.Printf(<span class="string">"%+v\n"</span>, *(*Adder)(i.data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">        tab  *itab</span><br><span class="line">        data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">        inter *interfacetype</span><br><span class="line">        _type *_type</span><br><span class="line">        hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">        _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">        fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">        typ     _type</span><br><span class="line">        pkgpath name</span><br><span class="line">        mhdr    []imethod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See reflect/type.go for details.</span></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;</span><br><span class="line">        bytes *<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line">        name nameOff</span><br><span class="line">        ityp typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">        size       <span class="keyword">uintptr</span></span><br><span class="line">        ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">        hash       <span class="keyword">uint32</span></span><br><span class="line">        tflag      tflag</span><br><span class="line">        align      <span class="keyword">uint8</span></span><br><span class="line">        fieldalign <span class="keyword">uint8</span></span><br><span class="line">        kind       <span class="keyword">uint8</span></span><br><span class="line">        alg        *typeAlg</span><br><span class="line">        <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">        <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">        <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">        gcdata    *<span class="keyword">byte</span></span><br><span class="line">        str       nameOff</span><br><span class="line">        ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tflag <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// function for hashing objects of this type</span></span><br><span class="line">        <span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">        hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">        // <span class="title">function</span> <span class="title">for</span> <span class="title">comparing</span> <span class="title">objects</span> <span class="title">of</span> <span class="title">this</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">        // <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function">        <span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">nameOff</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">typeOff</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure>
<p>对应的汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">377</span> args=<span class="number">0x0</span> locals=<span class="number">0xc8</span></span><br><span class="line">    <span class="number">0x002f</span> <span class="number">00047</span> (main.go:<span class="number">22</span>)   MOVL    <span class="number">$0</span>, <span class="string">""</span>.adder+<span class="number">68</span>(<span class="built_in">SP</span>) <span class="comment">; 初始化一个addr, 默认值都是空的</span></span><br><span class="line">    <span class="number">0x0037</span> <span class="number">00055</span> (main.go:<span class="number">22</span>)   MOVL    <span class="number">$6754</span>, <span class="string">""</span>.adder+<span class="number">68</span>(<span class="built_in">SP</span>) <span class="comment">; 对 Addr.id 字段进行赋值</span></span><br><span class="line">    <span class="number">0x003f</span> <span class="number">00063</span> (main.go:<span class="number">23</span>)   MOVL    <span class="number">$6754</span>, (<span class="built_in">SP</span>) <span class="comment">; 将id的值放到栈底，作为 convT32的参数</span></span><br><span class="line">    <span class="number">0x0046</span> <span class="number">00070</span> (main.go:<span class="number">23</span>)   <span class="keyword">CALL</span>    runtime.convT32(SB) <span class="comment">; 入参是 id, 输出的 值是转换后的unsafe.Pointer</span></span><br><span class="line">    <span class="number">0x004b</span> <span class="number">00075</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; 返回值从 8(SP) 的位置，复制到寄存器 AX</span></span><br><span class="line">    <span class="number">0x0050</span> <span class="number">00080</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_5+<span class="number">80</span>(<span class="built_in">SP</span>) <span class="comment">; 将返回值从 AX 复制到临时变量autotmp_5 的位置</span></span><br><span class="line">    <span class="number">0x0055</span> <span class="number">00085</span> (main.go:<span class="number">23</span>)   LEAQ    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather(SB), <span class="built_in">CX</span> <span class="comment">; 将 Adder 的 itab转换为 Mather 类型，并将地址放到 CX</span></span><br><span class="line">    <span class="number">0x005c</span> <span class="number">00092</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.m+<span class="number">104</span>(<span class="built_in">SP</span>) <span class="comment">; 将 CX 寄存器中的 itab 地址赋值给 m.tab</span></span><br><span class="line">    <span class="number">0x0061</span> <span class="number">00097</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.m+<span class="number">112</span>(<span class="built_in">SP</span>) <span class="comment">; 将 AX 寄存器中的 unsafe.Pointer 的 表示的值，赋值给 m.data</span></span><br></pre></td></tr></table></figure></p>
<p>重点关注<code>main.go:22</code> 和<code>main.go:23</code>, 首先看一下<code>main.go:22</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的细节:</p>
<ol>
<li><code>struct</code> 的 赋值是先对其赋值为空，然后再一个字段一个字段赋值，字段在栈中的排列跟定义的顺序有关系，是紧密排列的，并且存在对齐的问题</li>
</ol>
<p>然后看如何把<code>Adder</code>类型转换为<code>Mather</code>接口类型的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := Mather(adder)</span><br></pre></td></tr></table></figure></p>
<p>具体赋值的 步骤前面汇编部分的注释已经说明了， 这里需要注意的几个细节:</p>
<ol>
<li><code>iface</code>类型与<code>eface</code>不通，有<code>tab</code>和<code>data</code> 两个字段，分别是<code>*itab</code>和<code>unsafe.Pointer</code>两个类型</li>
<li><code>go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), CX</code> 将 Adder 的 itab转换为 Mather 类型，并将地址放到 CX, <strong>具体如何实现的，还没有找到查看方法，需要继续研究</strong></li>
</ol>
<p><code>itab</code>类型也无法直接查看，这里通过<code>unsafe</code>进行转换，在通过<code>dlv</code>进行查看:</p>
<ol>
<li><p>转换代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := *(*iface)(unsafe.Pointer(&amp;m))</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 dlv 在此处打断点查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p i</span><br><span class="line">main.iface &#123;</span><br><span class="line">        tab: *main.itab &#123;</span><br><span class="line">                inter: *(*main.interfacetype)(0x4c0360),</span><br><span class="line">                _type: *(*main._type)(0x4c63e0),</span><br><span class="line">                hash: 1633631626,</span><br><span class="line">                _: [4]uint8 [0,0,0,0],</span><br><span class="line">                fun: [1]uintptr [4867136],&#125;,</span><br><span class="line">        data: unsafe.Pointer(0xc000080010),&#125;</span><br><span class="line"></span><br><span class="line">(dlv) p i.tab</span><br><span class="line">*main.itab &#123;</span><br><span class="line">        inter: *main.interfacetype &#123;</span><br><span class="line">                typ: (*main._type)(0x4c0360),</span><br><span class="line">                pkgpath: (*main.name)(0x4c0390),</span><br><span class="line">                mhdr: []main.imethod len: 2, cap: 2, [</span><br><span class="line">                        (*main.imethod)(0x4c03c0),</span><br><span class="line">                        (*main.imethod)(0x4c03c8),</span><br><span class="line">                ],&#125;,</span><br><span class="line">        _type: *main._type &#123;</span><br><span class="line">                size: 4,</span><br><span class="line">                ptrdata: 0,</span><br><span class="line">                hash: 1633631626,</span><br><span class="line">                tflag: 7,</span><br><span class="line">                align: 4,</span><br><span class="line">                fieldalign: 4,</span><br><span class="line">                kind: 153,</span><br><span class="line">                alg: *(*main.typeAlg)(0x57bde0),</span><br><span class="line">                gcdata: *1,</span><br><span class="line">                str: 14386,</span><br><span class="line">                ptrToThis: 105952,&#125;,</span><br><span class="line">        hash: 1633631626,</span><br><span class="line">        _: [4]uint8 [0,0,0,0],</span><br><span class="line">        fun: [1]uintptr [4867136],&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>关于<code>itab</code>类型是包含接口的静态类型信息、数据的动态类型信息、函数表的结构, 在源码中的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123;</span><br><span class="line">    inter *interfacetype //  本实例所实现的接口的类型信息,  用于定位到具体的 interface, 这个是在编译时确定的</span><br><span class="line">    _type *_type //  本实例的具体数据的类型信息, 参考前面 _type 类型的定义 </span><br><span class="line">    hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">    _     [4]byte</span><br><span class="line">    // fun 表示的 interface 里面的 method 的具体实现</span><br><span class="line">    // 这里放置和接口方法对应的具体数据类型的方法地址</span><br><span class="line">    // 实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时</span><br><span class="line">    // 会更新此表，或者直接拿缓存的itab</span><br><span class="line">    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// interfacetype 只是对于 _type 的一种包装，在其顶部空间还包装了额外的 interface 相关的元信息</span><br><span class="line">type interfacetype struct &#123;</span><br><span class="line">    typ     _type // 所实现的接口的类型</span><br><span class="line">    pkgpath name  // 所实现的接口的定义路径</span><br><span class="line">    mhdr    []imethod //   所实现的接口在定义时的函数声明列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里的 method 只是一种函数声明的抽象，比如  func Print() error</span><br><span class="line">type imethod struct &#123;</span><br><span class="line">    name nameOff</span><br><span class="line">    ityp typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的点:</p>
<ol>
<li><code>func</code>表示的 interface 里面的 method 的具体实现, 比如这里的两个方法<code>Sub</code>和<code>Add</code>， 但是<code>func</code>的长度为1， 该如何表示多个方法呢?<br>看一下函数调用:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.Add(<span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line">m.Sub(<span class="number">19</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对应的汇编:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0066</span> <span class="number">00102</span> (main.go:<span class="number">24</span>)   TESTB   <span class="built_in">AL</span>, (<span class="built_in">CX</span>)<span class="comment">; 求与 AL &amp; (CX), 检查 CX 是否为 nil, AL 是 AX 的低8位, AH 是 AX 的高8位</span></span><br><span class="line"><span class="number">0x0068</span> <span class="number">00104</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather+<span class="number">24</span>(SB), <span class="built_in">CX</span> <span class="comment">; Add函数的入口地址放到 CX</span></span><br><span class="line"><span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0073</span> <span class="number">00115</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="number">$8589934604</span>, <span class="built_in">AX</span> <span class="comment">; 将 12, 2两个参数赋值到 AX 中</span></span><br><span class="line"><span class="number">0x007d</span> <span class="number">00125</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; 将 AX 中的参数赋值到 8(SP) 位置</span></span><br><span class="line"><span class="number">0x0082</span> <span class="number">00130</span> (main.go:<span class="number">24</span>)   <span class="keyword">CALL</span>    <span class="built_in">CX</span> <span class="comment">; 调用 m.Add</span></span><br><span class="line"><span class="number">0x0084</span> <span class="number">00132</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.m+<span class="number">104</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; 前面看到这个位置是 m.tab 的值</span></span><br><span class="line"><span class="number">0x0089</span> <span class="number">00137</span> (main.go:<span class="number">25</span>)   TESTB   <span class="built_in">AL</span>, (<span class="built_in">AX</span>)<span class="comment">; 检查 AX 是否为 nil</span></span><br><span class="line"><span class="number">0x008b</span> <span class="number">00139</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">32</span>(<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; (AX)地址 + 32 偏移，指向 Sub</span></span><br><span class="line"><span class="number">0x008f</span> <span class="number">00143</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.m+<span class="number">112</span>(<span class="built_in">SP</span>), <span class="built_in">CX</span> <span class="comment">; 这个位置是 m.data 的值</span></span><br><span class="line"><span class="number">0x0094</span> <span class="number">00148</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0098</span> <span class="number">00152</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">$19</span>, <span class="number">8</span>(<span class="built_in">SP</span>) <span class="comment">; 把参数 19 放到 8(SP) 位置</span></span><br><span class="line"><span class="number">0x00a1</span> <span class="number">00161</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">$4</span>, <span class="number">16</span>(<span class="built_in">SP</span>) <span class="comment">; 把参数 4 放到 16(SP) 位置</span></span><br><span class="line"><span class="number">0x00aa</span> <span class="number">00170</span> (main.go:<span class="number">25</span>)   <span class="keyword">CALL</span>    <span class="built_in">AX</span> <span class="comment">; 调用 m.Sub</span></span><br></pre></td></tr></table></figure>
<p> 需要注意的细节:</p>
<ol>
<li><p><code>TESTB AL, (CX)</code>是把 <code>AL &amp; (CX)</code> 位与的值放到 (CX) 中, 参考: <a href="https://github.com/golang/go/issues/10432" target="_blank" rel="noopener">https://github.com/golang/go/issues/10432</a> &amp; <a href="https://github.com/golang/go/issues/27180" target="_blank" rel="noopener">https://github.com/golang/go/issues/27180</a>, 这个步骤其实是为了检查 CX 是否为 nil， 如果是 nil 就没法调用这个函数了</p>
</li>
<li><p><code>MOVQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather+24(SB), CX</code> 这个为什么是取到了<code>Add</code>的地址?<br>看一下<code>itab</code>的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  <span class="keyword">uint32</span> </span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当前机器是64位的，所以可以看出<code>func</code> 相对于<code>itab</code>起始地址的偏移量为:<br><code>8(*interfacetype) + 8(*_type) + 4(uint32) + 4(byte=uint8) = 24</code><br>所以 <code>MOVQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather+24(SB)</code> 其实就是<code>func</code>的第一个函数<code>Add</code>的地址</p>
</li>
<li><p>函数<code>Sub</code>的地址为什么是<code>32(AX)</code>?<br>可以从前面一句<code>MOVQ    &quot;&quot;.m+104(SP), AX</code> 得出: <code>AX</code>目前指向的是<code>m.tab</code>, 也就是<code>itab</code>类型的起始地址，<code>32(AX)</code>就是相对<code>AX</code>有32位的偏移，前面说了相对<code>itab</code> <code>24</code>位的偏移其实时<code>Add</code>函数，然后对于64位系统，函数地址占<code>8</code>位，所以<code>32(AX)</code>就是下一个函数<code>Sub</code>的地址。 </p>
</li>
<li><p>前面只有两个函数，我们如果调换一下接口定义中两个函数的位置，发现生成的汇编是一样的，也就是:<strong>函数顺序与定义的顺序无关</strong>, 如果增加几个函数就可以看出来，其实:<strong> 函数在<code>func</code> 中的顺序是按照函数名的字典顺序排列的</strong></p>
</li>
<li><p><code>MOVQ    $8589934604, AX</code> 为什么是参数赋值?<br>这个其实我们可以对常量<code>8589934604</code> 进行分析，首先把它转化为二进制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;obase=2;8589934604&apos; | bc</span><br><span class="line">1000000000000000000000000000001100</span><br></pre></td></tr></table></figure>
<p>得到的数据其实是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">| 0000001000000000000000000000000000001100 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">  \______/\______________________________/  </span><br><span class="line">   +---+             +----+                 </span><br><span class="line">   | 2 |             | 12 |                 </span><br><span class="line">   +---+             +----+</span><br></pre></td></tr></table></figure>
<p>其实就是<code>2</code>和<code>12</code>两个<code>8</code>字节的数据组合在一起放到了<code>AX</code>寄存器中, 正是<code>Add(12,2)</code>的两个参数。</p>
</li>
</ol>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><code>interface{}</code> 是一个抽象的类型，如果需要转换为具体的类型，则需要类型断言, 类型断言其实有两个:</p>
<ol>
<li>类型判断: 判断类型是否一致</li>
<li>类型转换: 类型一致取出具体的数据</li>
</ol>
<p>下面看一个例子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">uint32</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> eface <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertion</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="keyword">uint64</span>(<span class="number">42</span>)</span><br><span class="line">    eface = i</span><br><span class="line">    j = eface.(<span class="keyword">uint32</span>)</span><br><span class="line">    r, ok = eface.(<span class="keyword">int32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的汇编语言如下:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0066</span> <span class="number">00102</span> (eface.go:<span class="number">11</span>)  MOVL    <span class="number">$0</span>, <span class="string">""</span>..autotmp_1+<span class="number">36</span>(<span class="built_in">SP</span>) <span class="comment">; 初始化0值</span></span><br><span class="line"><span class="number">0x006e</span> <span class="number">00110</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="string">""</span>.eface+<span class="number">8</span>(SB), <span class="built_in">AX</span> <span class="comment">; 把 data 放到 AX 寄存器</span></span><br><span class="line"><span class="number">0x0075</span> <span class="number">00117</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="string">""</span>.eface(SB), <span class="built_in">CX</span> <span class="comment">; 把 _type 放到 CX 寄存器</span></span><br><span class="line"><span class="number">0x007c</span> <span class="number">00124</span> (eface.go:<span class="number">11</span>)  LEAQ    type.uint32(SB), <span class="built_in">DX</span> <span class="comment">; 把 uint32的_type 值放到 DX 寄存器</span></span><br><span class="line"><span class="number">0x0083</span> <span class="number">00131</span> (eface.go:<span class="number">11</span>)  CMPQ    <span class="built_in">CX</span>, <span class="built_in">DX</span><span class="comment">; 比较 eface._type == uint32 ?</span></span><br><span class="line"><span class="number">0x0086</span> <span class="number">00134</span> (eface.go:<span class="number">11</span>)  JEQ <span class="number">138</span> <span class="comment">; JEQ = jump if equal, 如果类型相等就跳转到 138行</span></span><br><span class="line"><span class="number">0x0088</span> <span class="number">00136</span> (eface.go:<span class="number">11</span>)  <span class="keyword">JMP</span> <span class="number">246</span> <span class="comment">;  类型不匹配, 跳转到 246 行, 出现 panic</span></span><br><span class="line"><span class="number">0x008a</span> <span class="number">00138</span> (eface.go:<span class="number">11</span>)  MOVL    (<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; JEQ 跳转的行 138, 把(AX)地址对应的值放到 AX 寄存器，也就是 eface.data</span></span><br><span class="line"><span class="number">0x008c</span> <span class="number">00140</span> (eface.go:<span class="number">11</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_1+<span class="number">36</span>(<span class="built_in">SP</span>) <span class="comment">; 临时变量赋值</span></span><br><span class="line"><span class="number">0x0090</span> <span class="number">00144</span> (eface.go:<span class="number">11</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.j(SB) <span class="comment">; 赋值给变量 j</span></span><br><span class="line"><span class="number">0x0096</span> <span class="number">00150</span> (eface.go:<span class="number">12</span>)  <span class="keyword">MOVQ</span>    <span class="string">""</span>.eface+<span class="number">8</span>(SB), <span class="built_in">AX</span> <span class="comment">;  把 data 放到 AX 寄存器</span></span><br><span class="line"><span class="number">0x009d</span> <span class="number">00157</span> (eface.go:<span class="number">12</span>)  LEAQ    type.int32(SB), <span class="built_in">CX</span> <span class="comment">; 把 int32 的_type 值放到 DX 寄存器</span></span><br><span class="line"><span class="number">0x00a4</span> <span class="number">00164</span> (eface.go:<span class="number">12</span>)  CMPQ    <span class="string">""</span>.eface(SB), <span class="built_in">CX</span> <span class="comment">; 比较 eface._type == int32 ?</span></span><br><span class="line"><span class="number">0x00ab</span> <span class="number">00171</span> (eface.go:<span class="number">12</span>)  JEQ <span class="number">175</span> <span class="comment">; 如果类型相等就跳转到 175 行</span></span><br><span class="line"><span class="number">0x00ad</span> <span class="number">00173</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">223</span> <span class="comment">; 跳转到 223 行，输出 panic</span></span><br><span class="line"><span class="number">0x00af</span> <span class="number">00175</span> (eface.go:<span class="number">12</span>)  MOVL    (<span class="built_in">AX</span>), <span class="built_in">AX</span><span class="comment">; 类型相等就把 data 放到 AX</span></span><br><span class="line"><span class="number">0x00b1</span> <span class="number">00177</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="number">$1</span>, <span class="built_in">CX</span> 把常量 <span class="number">1</span> 放到 <span class="built_in">CX</span></span><br><span class="line"><span class="number">0x00b6</span> <span class="number">00182</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">184</span> <span class="comment">; 调到 184 行</span></span><br><span class="line"><span class="number">0x00b8</span> <span class="number">00184</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x00bc</span> <span class="number">00188</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">CL</span>, <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>) <span class="comment">; CL 是 CX 的低 8 位</span></span><br><span class="line"><span class="number">0x00c0</span> <span class="number">00192</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x00c4</span> <span class="number">00196</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.r(SB) <span class="comment">; AX 是 data 的值， 放到 r 变量中</span></span><br><span class="line"><span class="number">0x00ca</span> <span class="number">00202</span> (eface.go:<span class="number">12</span>)  MOVBLZX <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; MOVBLZX 用 0 扩展，放到 autotmp_3 变量</span></span><br><span class="line"><span class="number">0x00cf</span> <span class="number">00207</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">AL</span>, <span class="string">""</span>.ok(SB)<span class="comment">; AL 低8位赋值给 ok ，因为ok 是 bool 类型的， 根据字节对齐，占 8 位</span></span><br><span class="line"><span class="number">0x00d5</span> <span class="number">00213</span> (eface.go:<span class="number">13</span>)  <span class="keyword">MOVQ</span>    <span class="number">56</span>(<span class="built_in">SP</span>), <span class="built_in">BP</span></span><br><span class="line"><span class="number">0x00da</span> <span class="number">00218</span> (eface.go:<span class="number">13</span>)  ADDQ    <span class="number">$64</span>, <span class="built_in">SP</span></span><br><span class="line"><span class="number">0x00de</span> <span class="number">00222</span> (eface.go:<span class="number">13</span>)  <span class="keyword">RET</span></span><br><span class="line"><span class="number">0x00df</span> <span class="number">00223</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">AX</span>, <span class="built_in">AX</span> <span class="comment">; eface.type != int32 情况下，执行本行, XOR是异或，所以 AX^AX , 结果为 0</span></span><br><span class="line"><span class="number">0x00e1</span> <span class="number">00225</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">CX</span>, <span class="built_in">CX</span><span class="comment">; 同上， CX 结果为 0</span></span><br><span class="line"><span class="number">0x00e3</span> <span class="number">00227</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">184</span> <span class="comment">; 跳转到 184 行执行，这里要注意的是 AX, CX 寄存器已经为0， 所有后面 ok 的值也位0了</span></span><br><span class="line"><span class="number">0x00e5</span> <span class="number">00229</span> (eface.go:<span class="number">10</span>)  LEAQ    <span class="string">""</span>.eface+<span class="number">8</span>(SB), <span class="built_in">DI</span></span><br><span class="line"><span class="number">0x00ec</span> <span class="number">00236</span> (eface.go:<span class="number">10</span>)  <span class="keyword">CALL</span>    runtime.gcWriteBarrier(SB)</span><br><span class="line"><span class="number">0x00f1</span> <span class="number">00241</span> (eface.go:<span class="number">10</span>)  <span class="keyword">JMP</span> <span class="number">102</span></span><br><span class="line"><span class="number">0x00f6</span> <span class="number">00246</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>) <span class="comment">; 一个返回值表达式类型不匹配时，执行到这里, CX 类型值放到(SP)作为第一个参数</span></span><br><span class="line"><span class="number">0x00fa</span> <span class="number">00250</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">DX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; 想要的类型从 DX 放到 8(SP) 作为第二个参数</span></span><br><span class="line"><span class="number">0x00ff</span> <span class="number">00255</span> (eface.go:<span class="number">11</span>)  LEAQ    type.interface &#123;&#125;(SB), <span class="built_in">AX</span> <span class="comment">; interface 类型的地址放到 AX</span></span><br><span class="line"><span class="number">0x0106</span> <span class="number">00262</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">16</span>(<span class="built_in">SP</span>)<span class="comment">; AX 值放到 16(SP) 作为第三个参数</span></span><br><span class="line"><span class="number">0x010b</span> <span class="number">00267</span> (eface.go:<span class="number">11</span>)  <span class="keyword">CALL</span>    runtime.panicdottypeE(SB)<span class="comment">; 执行函数调用，使用前面的三个参数，返回 panic</span></span><br></pre></td></tr></table></figure></p>
<p> 需要注意的点:</p>
<ol>
<li>当使用返回值为一个的表达式时，如果出现类型不匹配，会触发<code>panic</code></li>
<li><p>当使用两个返回值的表达式时,  <code>r</code>, <code>ok</code>的值随着<code>AX</code>, <code>CX</code>的值 改变:<br>分为两种情况:<br>当类型相等时: <code>AX</code> 值为<code>eface.data</code>, <code>CX</code> 的值为<code>1</code><br>赋值的过程如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00b8</span> <span class="number">00184</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x00bc</span> <span class="number">00188</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">CL</span>, <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>) <span class="comment">; CL 是 CX 的低 8 位, CX 是 1, 二进制是: 0000000000000001; CL 就是: 00000001</span></span><br><span class="line"><span class="number">0x00c0</span> <span class="number">00192</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x00c4</span> <span class="number">00196</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.r(SB) <span class="comment">; AX 是 data 的值， 放到 r 变量中</span></span><br><span class="line"><span class="number">0x00ca</span> <span class="number">00202</span> (eface.go:<span class="number">12</span>)  MOVBLZX <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; MOVBLZX 用 0 扩展，放到 autotmp_3 变量, autotmp_3 是 00000001, 扩展后是: 0000000000000001</span></span><br><span class="line"><span class="number">0x00cf</span> <span class="number">00207</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">AL</span>, <span class="string">""</span>.ok(SB)<span class="comment">; AL 低8位赋值给 ok ，因为ok 是 bool 类型的， 根据字节对齐，占 8 位, ok 值为: 00000001</span></span><br></pre></td></tr></table></figure>
<p>当类型不相等时: <code>AX</code>和<code>CX</code>的值都初始化位空</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00df</span> <span class="number">00223</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">AX</span>, <span class="built_in">AX</span> <span class="comment">; eface.type != int32 情况下，执行本行, XOR是异或，所以 AX^AX , 结果为 0</span></span><br><span class="line"><span class="number">0x00e1</span> <span class="number">00225</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">CX</span>, <span class="built_in">CX</span><span class="comment">; 同上， CX 结果为 0</span></span><br><span class="line"><span class="number">0x00e3</span> <span class="number">00227</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">184</span> <span class="comment">; 跳转到 184 行执行，这里要注意的是 AX, CX 寄存器已经为0， 所有后面 ok 的值也位0了</span></span><br></pre></td></tr></table></figure>
<p>赋值过程如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00b8</span> <span class="number">00184</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x00bc</span> <span class="number">00188</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">CL</span>, <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>) <span class="comment">; CL 是 CX 的低 8 位, CX 是 0, 二进制是: 0000000000000000; CL 就是: 00000000</span></span><br><span class="line"><span class="number">0x00c0</span> <span class="number">00192</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x00c4</span> <span class="number">00196</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.r(SB) <span class="comment">; AX 是 data 的值， 放到 r 变量中, AX 是空值，所以 r == nil</span></span><br><span class="line"><span class="number">0x00ca</span> <span class="number">00202</span> (eface.go:<span class="number">12</span>)  MOVBLZX <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; MOVBLZX 用 0 扩展，放到 autotmp_3 变量, autotmp_3 是 00000000, 扩展后是: 0000000000000000</span></span><br><span class="line"><span class="number">0x00cf</span> <span class="number">00207</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">AL</span>, <span class="string">""</span>.ok(SB)<span class="comment">; AL 低8位赋值给 ok ，因为ok 是 bool 类型的， 根据字节对齐，占 8 位, ok 值为: 00000000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献,"></a>参考文献,</h2><p><a href="https://yougg.github.io/2017/03/27/%E7%90%86%E8%A7%A3go%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B1interface%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">理解Go语言模型(1)：interface底层详解</a><br><a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">Go Data Structures: Interfaces</a><br><a href="https://www.ardanlabs.com/blog/2017/07/interface-semantics.html" target="_blank" rel="noopener">Interface Semantics</a><br><a href="https://github.com/two/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">go-internals chapter2 interfacs</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>