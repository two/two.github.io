<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/09/02/go-interface-implement/"><span>Go Interface 源码解析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/09/02/go-interface-implement/" rel="bookmark">
        <time class="entry-date published" datetime="2019-09-02T02:18:00.000Z">
          2019-09-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本文基于<code>go1.12.4</code>源码</p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义:"></a>类型定义:</h3><p><code>runtime/runtime2.go</code></p>
<h4 id="不含method的interface"><a href="#不含method的interface" class="headerlink" title="不含method的interface"></a>不含<code>method</code>的<code>interface</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含method的interface"><a href="#包含method的interface" class="headerlink" title="包含method的interface"></a>包含<code>method</code>的<code>interface</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eface-分析"><a href="#eface-分析" class="headerlink" title="eface 分析"></a><code>eface</code> 分析</h2><p>首先写一个<code>eface</code>的具体<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br><span class="line">    e := *(*eface)(unsafe.Pointer(&amp;inter))</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, e)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *(*<span class="keyword">int</span>)(e.data))</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, &amp;num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    kind       <span class="keyword">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tflag <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// function for hashing objects of this type</span></span><br><span class="line">    <span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">    hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">    // <span class="title">function</span> <span class="title">for</span> <span class="title">comparing</span> <span class="title">objects</span> <span class="title">of</span> <span class="title">this</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">    // <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function">    <span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">nameOff</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">typeOff</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure></p>
<p>对应汇编:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">782</span> args=<span class="number">0x0</span> locals=<span class="number">0x128</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (main.go:<span class="number">8</span>)    TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$296</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0032</span> <span class="number">00050</span> (main.go:<span class="number">9</span>)    LEAQ    type.int(SB), <span class="built_in">AX</span> <span class="comment">;  通过 type.int  把 int 类型 转换为 *_type  类型，并把地址放到寄存器 AX</span></span><br><span class="line">    <span class="number">0x0039</span> <span class="number">00057</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)<span class="comment">; 把 AX 内容放到栈底, 这里是下一个函数 newobject 调用的参数</span></span><br><span class="line">    <span class="number">0x003d</span> <span class="number">00061</span> (main.go:<span class="number">9</span>)    <span class="keyword">CALL</span>    runtime.newobject(SB) <span class="comment">; 函数调用</span></span><br><span class="line">    <span class="number">0x0042</span> <span class="number">00066</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; newobject 返回值放到8(SP), 然后再放到 AX</span></span><br><span class="line">    <span class="number">0x0047</span> <span class="number">00071</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.&amp;num+<span class="number">128</span>(<span class="built_in">SP</span>)<span class="comment">; 返回值从 AX 放到 &amp;num 变量位置, 表示 num 的地址</span></span><br><span class="line">    <span class="number">0x004f</span> <span class="number">00079</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="number">$3</span>, (<span class="built_in">AX</span>)<span class="comment">; (AX)表示 AX 的地址对应的值, 赋值为 3</span></span><br><span class="line">    <span class="number">0x0056</span> <span class="number">00086</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.&amp;num+<span class="number">128</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; num 地址的值赋值个 AX </span></span><br><span class="line">    <span class="number">0x005e</span> <span class="number">00094</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    (<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; AX 值是地址，其对应的值赋值给 AX, 也就是常量 3</span></span><br><span class="line">    <span class="number">0x0061</span> <span class="number">00097</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_7+<span class="number">64</span>(<span class="built_in">SP</span>)<span class="comment">; 把这个值赋值给一个临时变量 autotmp_7</span></span><br><span class="line">    <span class="number">0x0066</span> <span class="number">00102</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>) <span class="comment">; 把值赋值给SP，栈底，是下一个函数 convT64 的参数</span></span><br><span class="line">    <span class="number">0x006a</span> <span class="number">00106</span> (main.go:<span class="number">10</span>)   <span class="keyword">CALL</span>    runtime.convT64(SB)<span class="comment">; 调用 runtime.convT64, 参数为 uint64, 返回值为 unsafe.Pointer</span></span><br><span class="line">    <span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; convT64 返回值放到8(SP), 并且赋值到 AX</span></span><br><span class="line">    <span class="number">0x0074</span> <span class="number">00116</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_8+<span class="number">80</span>(<span class="built_in">SP</span>)<span class="comment">; AX 的值放到临时变量 `autotmp_8`</span></span><br><span class="line">    <span class="number">0x0079</span> <span class="number">00121</span> (main.go:<span class="number">10</span>)   LEAQ    type.int(SB), <span class="built_in">CX</span> <span class="comment">; 通过 type.int  把 int 类型 转换为 *_type  类型，并把地址放到寄存器 CX</span></span><br><span class="line">    <span class="number">0x0080</span> <span class="number">00128</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.inter+<span class="number">136</span>(<span class="built_in">SP</span>)<span class="comment">; 将 CX 中代表*_type 地址的值放到 inter 变量eface类型的 _type 变量中</span></span><br><span class="line">    <span class="number">0x0088</span> <span class="number">00136</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.inter+<span class="number">144</span>(<span class="built_in">SP</span>)<span class="comment">; 将 AX 中代表 convT64返回值 3 的 unsafe.Pointer 类型 放到 inter 变量 eface 类型的 data 中 </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p> 这里只关注<code>main.go:9</code>和<code>main.go:10</code>的处理, 对应代码为:<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> num := <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>初始化变量<code>num</code>为<code>int</code>类型，并赋值为<code>3</code>, 具体的过程已经在前面汇编代码中通过注释的方式标出，下面来看一些细节:</p>
<ol>
<li>新建 <code>int</code> 类型变量需要申请内存, 通过<code>runtime.newobject</code>来申请</li>
<li><code>type.int</code>  可以获取 <code>int</code>类型的 <code>_type</code> 结构的地址 <code>*_type</code> (具体实现方式被编译优化了，需要再进一步深究)</li>
<li><p><code>MOVQ AX, (SP)</code>是为了把前面放到<code>AX</code>的<code>*_type</code> 放到栈底, 这个位置下面调用函数<code>runtime.newobject</code>的参数, 具体函数实现:</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完函数调用用会把返回值<code>unsafe.Pointer</code>放到<code>8(SP)</code>, 然后在放入 <code>AX</code></p>
</li>
<li><code>MOV $3,(AX)</code> 向表示寄存器<code>AX</code>包含的地址对应的值设置为常量<code>3</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br></pre></td></tr></table></figure>
<p> 初始化变量<code>inter</code>,类型为<code>interface{}</code>, 并且指向<code>num</code>, 具体过程参考上面的注释部分，一些细节:</p>
<ol>
<li><p>这里会调用<code>runtime.convT64</code>函数，定义如下: ( 在<code>go 1.8</code>版本调用的是<code>runtime.convT2E</code>, 在<code>go1.10</code>调用的是<code>runtime.convT2E64</code>):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT64</span><span class="params">(val <span class="keyword">uint64</span>)</span> <span class="params">(x unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = mallocgc(<span class="number">8</span>, uint64Type, <span class="literal">false</span>)</span><br><span class="line">        *(*<span class="keyword">uint64</span>)(x) = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参就是 <code>num</code> 的值 <code>3</code>, 返回值是转换为<code>uint64</code>的值，并且申请一个地址，值为<code>3</code>, <strong>注意: 这里发生了值的<code>copy</code></strong></p>
</li>
<li>通过最后两行赋值<code>inter</code>, <code>inter</code>类型为<code>eface</code>, 定义前面提过，最终给<code>eface._type</code> 和<code>eface.data</code>赋值</li>
<li><code>eface.type</code>的查看这里还没有找到好的方法来查看，<code>dlv</code>无法深入到内置的实现。</li>
</ol>
<p>为了查看<code>_type</code> 类型，定义了一个跟 <code>runtime</code> 内部实现一样的数据结构，并且通过<code>unsafe</code>强制进行数据类型转换，可以得到<code>_type</code>的值。<br>借助<code>dlv</code>对上面的程序进行<code>debug</code>:</p>
<ol>
<li>在<code>e := *(*eface)(unsafe.Pointer(&amp;inter))</code>处打断点</li>
<li><p>执行到上面这行后打印出<code>e</code>的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p e</span><br><span class="line">main.eface &#123;</span><br><span class="line">        _type: *main._type &#123;</span><br><span class="line">                size: 8,</span><br><span class="line">                ptrdata: 0,</span><br><span class="line">                hash: 4149441018,</span><br><span class="line">                tflag: 7,</span><br><span class="line">                align: 8,</span><br><span class="line">                fieldalign: 8,</span><br><span class="line">                kind: 130,</span><br><span class="line">                alg: *(*main.typeAlg)(0x57adf0),</span><br><span class="line">                gcdata: *1,</span><br><span class="line">                str: 1059,</span><br><span class="line">                ptrToThis: 47520,&#125;,</span><br><span class="line">        data: unsafe.Pointer(0xc000080018),&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>*_type</code>源码的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有类型信息结构体的公共部分</span></span><br><span class="line"><span class="comment">// src/rumtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span>  <span class="comment">// 类型的大小</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span>  <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span>   <span class="comment">// 类型的Hash值</span></span><br><span class="line">    tflag      tflag    <span class="comment">// 类型的Tags </span></span><br><span class="line">    align      <span class="keyword">uint8</span>    <span class="comment">// 结构体内对齐</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span>    <span class="comment">// 结构体作为field时的对齐</span></span><br><span class="line">    kind       <span class="keyword">uint8</span>    <span class="comment">// 类型编号 定义于runtime/typekind.go</span></span><br><span class="line">    alg        *typeAlg <span class="comment">// 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span>     <span class="comment">// GC相关信息</span></span><br><span class="line">    str       nameOff   <span class="comment">// 类型名字的偏移    </span></span><br><span class="line">    ptrToThis typeOff    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为了查看<code>eface.data</code>的值，可以通过<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, *(*<span class="keyword">int</span>)(e.data))</span><br></pre></td></tr></table></figure></p>
<p> 输出，可以看到运行结果为<code>3</code>, 正是<code>num</code>的值。</p>
<h2 id="iface-分析"><a href="#iface-分析" class="headerlink" title="iface 分析"></a><code>iface</code> 分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mather <span class="keyword">interface</span> &#123;</span><br><span class="line">        Add(a, b <span class="keyword">int32</span>) <span class="keyword">int32</span></span><br><span class="line">        Sub(a, b <span class="keyword">int64</span>) <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span>&#123; id <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Sub</span><span class="params">(a, b <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123; <span class="keyword">return</span> a - b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">        m := Mather(adder)</span><br><span class="line">		m.Add(<span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line">		m.Sub(<span class="number">19</span>, <span class="number">4</span>)</span><br><span class="line">        i := *(*iface)(unsafe.Pointer(&amp;m))</span><br><span class="line">        fmt.Printf(<span class="string">"%+v\n"</span>, i)</span><br><span class="line">		fmt.Printf(<span class="string">"%+v\n"</span>, *(*Adder)(i.data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">        tab  *itab</span><br><span class="line">        data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">        inter *interfacetype</span><br><span class="line">        _type *_type</span><br><span class="line">        hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">        _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">        fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">        typ     _type</span><br><span class="line">        pkgpath name</span><br><span class="line">        mhdr    []imethod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See reflect/type.go for details.</span></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;</span><br><span class="line">        bytes *<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line">        name nameOff</span><br><span class="line">        ityp typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">        size       <span class="keyword">uintptr</span></span><br><span class="line">        ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">        hash       <span class="keyword">uint32</span></span><br><span class="line">        tflag      tflag</span><br><span class="line">        align      <span class="keyword">uint8</span></span><br><span class="line">        fieldalign <span class="keyword">uint8</span></span><br><span class="line">        kind       <span class="keyword">uint8</span></span><br><span class="line">        alg        *typeAlg</span><br><span class="line">        <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">        <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">        <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">        gcdata    *<span class="keyword">byte</span></span><br><span class="line">        str       nameOff</span><br><span class="line">        ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tflag <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// function for hashing objects of this type</span></span><br><span class="line">        <span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">        hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">        // <span class="title">function</span> <span class="title">for</span> <span class="title">comparing</span> <span class="title">objects</span> <span class="title">of</span> <span class="title">this</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">        // <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function">        <span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">nameOff</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">typeOff</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure>
<p>对应的汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">377</span> args=<span class="number">0x0</span> locals=<span class="number">0xc8</span></span><br><span class="line">    <span class="number">0x002f</span> <span class="number">00047</span> (main.go:<span class="number">22</span>)   MOVL    <span class="number">$0</span>, <span class="string">""</span>.adder+<span class="number">68</span>(<span class="built_in">SP</span>) <span class="comment">; 初始化一个addr, 默认值都是空的</span></span><br><span class="line">    <span class="number">0x0037</span> <span class="number">00055</span> (main.go:<span class="number">22</span>)   MOVL    <span class="number">$6754</span>, <span class="string">""</span>.adder+<span class="number">68</span>(<span class="built_in">SP</span>) <span class="comment">; 对 Addr.id 字段进行赋值</span></span><br><span class="line">    <span class="number">0x003f</span> <span class="number">00063</span> (main.go:<span class="number">23</span>)   MOVL    <span class="number">$6754</span>, (<span class="built_in">SP</span>) <span class="comment">; 将id的值放到栈底，作为 convT32的参数</span></span><br><span class="line">    <span class="number">0x0046</span> <span class="number">00070</span> (main.go:<span class="number">23</span>)   <span class="keyword">CALL</span>    runtime.convT32(SB) <span class="comment">; 入参是 id, 输出的 值是转换后的unsafe.Pointer</span></span><br><span class="line">    <span class="number">0x004b</span> <span class="number">00075</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; 返回值从 8(SP) 的位置，复制到寄存器 AX</span></span><br><span class="line">    <span class="number">0x0050</span> <span class="number">00080</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_5+<span class="number">80</span>(<span class="built_in">SP</span>) <span class="comment">; 将返回值从 AX 复制到临时变量autotmp_5 的位置</span></span><br><span class="line">    <span class="number">0x0055</span> <span class="number">00085</span> (main.go:<span class="number">23</span>)   LEAQ    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather(SB), <span class="built_in">CX</span> <span class="comment">; 将 Adder 的 itab转换为 Mather 类型，并将地址放到 CX</span></span><br><span class="line">    <span class="number">0x005c</span> <span class="number">00092</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.m+<span class="number">104</span>(<span class="built_in">SP</span>) <span class="comment">; 将 CX 寄存器中的 itab 地址赋值给 m.tab</span></span><br><span class="line">    <span class="number">0x0061</span> <span class="number">00097</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.m+<span class="number">112</span>(<span class="built_in">SP</span>) <span class="comment">; 将 AX 寄存器中的 unsafe.Pointer 的 表示的值，赋值给 m.data</span></span><br></pre></td></tr></table></figure></p>
<p>重点关注<code>main.go:22</code> 和<code>main.go:23</code>, 首先看一下<code>main.go:22</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的细节:</p>
<ol>
<li><code>struct</code> 的 赋值是先对其赋值为空，然后再一个字段一个字段赋值，字段在栈中的排列跟定义的顺序有关系，是紧密排列的，并且存在对齐的问题</li>
</ol>
<p>然后看如何把<code>Adder</code>类型转换为<code>Mather</code>接口类型的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := Mather(adder)</span><br></pre></td></tr></table></figure></p>
<p>具体赋值的 步骤前面汇编部分的注释已经说明了， 这里需要注意的几个细节:</p>
<ol>
<li><code>iface</code>类型与<code>eface</code>不通，有<code>tab</code>和<code>data</code> 两个字段，分别是<code>*itab</code>和<code>unsafe.Pointer</code>两个类型</li>
<li><code>go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), CX</code> 将 Adder 的 itab转换为 Mather 类型，并将地址放到 CX, <strong>具体如何实现的，还没有找到查看方法，需要继续研究</strong></li>
</ol>
<p><code>itab</code>类型也无法直接查看，这里通过<code>unsafe</code>进行转换，在通过<code>dlv</code>进行查看:</p>
<ol>
<li><p>转换代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := *(*iface)(unsafe.Pointer(&amp;m))</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 dlv 在此处打断点查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p i</span><br><span class="line">main.iface &#123;</span><br><span class="line">        tab: *main.itab &#123;</span><br><span class="line">                inter: *(*main.interfacetype)(0x4c0360),</span><br><span class="line">                _type: *(*main._type)(0x4c63e0),</span><br><span class="line">                hash: 1633631626,</span><br><span class="line">                _: [4]uint8 [0,0,0,0],</span><br><span class="line">                fun: [1]uintptr [4867136],&#125;,</span><br><span class="line">        data: unsafe.Pointer(0xc000080010),&#125;</span><br><span class="line"></span><br><span class="line">(dlv) p i.tab</span><br><span class="line">*main.itab &#123;</span><br><span class="line">        inter: *main.interfacetype &#123;</span><br><span class="line">                typ: (*main._type)(0x4c0360),</span><br><span class="line">                pkgpath: (*main.name)(0x4c0390),</span><br><span class="line">                mhdr: []main.imethod len: 2, cap: 2, [</span><br><span class="line">                        (*main.imethod)(0x4c03c0),</span><br><span class="line">                        (*main.imethod)(0x4c03c8),</span><br><span class="line">                ],&#125;,</span><br><span class="line">        _type: *main._type &#123;</span><br><span class="line">                size: 4,</span><br><span class="line">                ptrdata: 0,</span><br><span class="line">                hash: 1633631626,</span><br><span class="line">                tflag: 7,</span><br><span class="line">                align: 4,</span><br><span class="line">                fieldalign: 4,</span><br><span class="line">                kind: 153,</span><br><span class="line">                alg: *(*main.typeAlg)(0x57bde0),</span><br><span class="line">                gcdata: *1,</span><br><span class="line">                str: 14386,</span><br><span class="line">                ptrToThis: 105952,&#125;,</span><br><span class="line">        hash: 1633631626,</span><br><span class="line">        _: [4]uint8 [0,0,0,0],</span><br><span class="line">        fun: [1]uintptr [4867136],&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>关于<code>itab</code>类型是包含接口的静态类型信息、数据的动态类型信息、函数表的结构, 在源码中的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123;</span><br><span class="line">    inter *interfacetype //  本实例所实现的接口的类型信息,  用于定位到具体的 interface, 这个是在编译时确定的</span><br><span class="line">    _type *_type //  本实例的具体数据的类型信息, 参考前面 _type 类型的定义 </span><br><span class="line">    hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">    _     [4]byte</span><br><span class="line">    // fun 表示的 interface 里面的 method 的具体实现</span><br><span class="line">    // 这里放置和接口方法对应的具体数据类型的方法地址</span><br><span class="line">    // 实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时</span><br><span class="line">    // 会更新此表，或者直接拿缓存的itab</span><br><span class="line">    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// interfacetype 只是对于 _type 的一种包装，在其顶部空间还包装了额外的 interface 相关的元信息</span><br><span class="line">type interfacetype struct &#123;</span><br><span class="line">    typ     _type // 所实现的接口的类型</span><br><span class="line">    pkgpath name  // 所实现的接口的定义路径</span><br><span class="line">    mhdr    []imethod //   所实现的接口在定义时的函数声明列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里的 method 只是一种函数声明的抽象，比如  func Print() error</span><br><span class="line">type imethod struct &#123;</span><br><span class="line">    name nameOff</span><br><span class="line">    ityp typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的点:</p>
<ol>
<li><code>func</code>表示的 interface 里面的 method 的具体实现, 比如这里的两个方法<code>Sub</code>和<code>Add</code>， 但是<code>func</code>的长度为1， 该如何表示多个方法呢?<br>看一下函数调用:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.Add(<span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line">m.Sub(<span class="number">19</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对应的汇编:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0066</span> <span class="number">00102</span> (main.go:<span class="number">24</span>)   TESTB   <span class="built_in">AL</span>, (<span class="built_in">CX</span>)<span class="comment">; 求与 AL &amp; (CX), 检查 CX 是否为 nil</span></span><br><span class="line"><span class="number">0x0068</span> <span class="number">00104</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather+<span class="number">24</span>(SB), <span class="built_in">CX</span> <span class="comment">; Add函数的入口地址放到 CX</span></span><br><span class="line"><span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0073</span> <span class="number">00115</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="number">$8589934604</span>, <span class="built_in">AX</span> <span class="comment">; 将 12, 2两个参数赋值到 AX 中</span></span><br><span class="line"><span class="number">0x007d</span> <span class="number">00125</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; 将 AX 中的参数赋值到 8(SP) 位置</span></span><br><span class="line"><span class="number">0x0082</span> <span class="number">00130</span> (main.go:<span class="number">24</span>)   <span class="keyword">CALL</span>    <span class="built_in">CX</span> <span class="comment">; 调用 m.Add</span></span><br><span class="line"><span class="number">0x0084</span> <span class="number">00132</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.m+<span class="number">104</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; 前面看到这个位置是 m.tab 的值</span></span><br><span class="line"><span class="number">0x0089</span> <span class="number">00137</span> (main.go:<span class="number">25</span>)   TESTB   <span class="built_in">AL</span>, (<span class="built_in">AX</span>)<span class="comment">; 检查 AX 是否为 nil</span></span><br><span class="line"><span class="number">0x008b</span> <span class="number">00139</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">32</span>(<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; (AX)地址 + 32 偏移，指向 Sub</span></span><br><span class="line"><span class="number">0x008f</span> <span class="number">00143</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.m+<span class="number">112</span>(<span class="built_in">SP</span>), <span class="built_in">CX</span> <span class="comment">; 这个位置是 m.data 的值</span></span><br><span class="line"><span class="number">0x0094</span> <span class="number">00148</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0098</span> <span class="number">00152</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">$19</span>, <span class="number">8</span>(<span class="built_in">SP</span>) <span class="comment">; 把参数 19 放到 8(SP) 位置</span></span><br><span class="line"><span class="number">0x00a1</span> <span class="number">00161</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">$4</span>, <span class="number">16</span>(<span class="built_in">SP</span>) <span class="comment">; 把参数 4 放到 16(SP) 位置</span></span><br><span class="line"><span class="number">0x00aa</span> <span class="number">00170</span> (main.go:<span class="number">25</span>)   <span class="keyword">CALL</span>    <span class="built_in">AX</span> <span class="comment">; 调用 m.Sub</span></span><br></pre></td></tr></table></figure>
<p> 需要注意的细节:</p>
<ol>
<li><p><code>TESTB AL, (CX)</code>是把 <code>AL &amp; (CX)</code> 位与的值放到 (CX) 中, 参考: <a href="https://github.com/golang/go/issues/10432" target="_blank" rel="noopener">https://github.com/golang/go/issues/10432</a> &amp; <a href="https://github.com/golang/go/issues/27180" target="_blank" rel="noopener">https://github.com/golang/go/issues/27180</a>, 这个步骤其实是为了检查 CX 是否为 nil， 如果是 nil 就没法调用这个函数了</p>
</li>
<li><p><code>MOVQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather+24(SB), CX</code> 这个为什么是取到了<code>Add</code>的地址?<br>看一下<code>itab</code>的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  <span class="keyword">uint32</span> </span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当前机器是64位的，所以可以看出<code>func</code> 相对于<code>itab</code>起始地址的偏移量为:<br><code>8(*interfacetype) + 8(*_type) + 4(uint32) + 4(byte=uint8) = 24</code><br>所以 <code>MOVQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather+24(SB)</code> 其实就是<code>func</code>的第一个函数<code>Add</code>的地址</p>
</li>
<li><p>函数<code>Sub</code>的地址为什么是<code>32(AX)</code>?<br>可以从前面一句<code>MOVQ    &quot;&quot;.m+104(SP), AX</code> 得出: <code>AX</code>目前指向的是<code>m.tab</code>, 也就是<code>itab</code>类型的起始地址，<code>32(AX)</code>就是相对<code>AX</code>有32位的偏移，前面说了相对<code>itab</code> <code>24</code>位的偏移其实时<code>Add</code>函数，然后对于64位系统，函数地址占<code>8</code>位，所以<code>32(AX)</code>就是下一个函数<code>Sub</code>的地址。 </p>
</li>
<li><p>前面只有两个函数，我们如果调换一下接口定义中两个函数的位置，发现生成的汇编是一样的，也就是:<strong>函数顺序与定义的顺序无关</strong>, 如果增加几个函数就可以看出来，其实:<strong> 函数在<code>func</code> 中的顺序是按照函数名的字典顺序排列的</strong></p>
</li>
<li><p><code>MOVQ    $8589934604, AX</code> 为什么是参数赋值?<br>这个其实我们可以对常量<code>8589934604</code> 进行分析，首先把它转化为二进制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;obase=2;8589934604&apos; | bc</span><br><span class="line">1000000000000000000000000000001100</span><br></pre></td></tr></table></figure>
<p>得到的数据其实是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">| 0000001000000000000000000000000000001100 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">  \______/\______________________________/  </span><br><span class="line">   +---+             +----+                 </span><br><span class="line">   | 2 |             | 12 |                 </span><br><span class="line">   +---+             +----+</span><br></pre></td></tr></table></figure>
<p>其实就是<code>2</code>和<code>12</code>两个<code>8</code>字节的数据组合在一起放到了<code>AX</code>寄存器中, 正是<code>Add(12,2)</code>的两个参数。</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献,"></a>参考文献,</h2><p><a href="https://yougg.github.io/2017/03/27/%E7%90%86%E8%A7%A3go%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B1interface%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">理解Go语言模型(1)：interface底层详解</a><br><a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">Go Data Structures: Interfaces</a><br><a href="https://www.ardanlabs.com/blog/2017/07/interface-semantics.html" target="_blank" rel="noopener">Interface Semantics</a><br><a href="https://github.com/two/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">go-internals chapter2 interfacs</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/12/go-converte-between-string-and-byte/"><span>go converte between string and byte slice</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/12/go-converte-between-string-and-byte/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-12T05:17:10.000Z">
          2019-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Go第一版代码<code>c</code>实现, 在<code>runtime/runtime.h</code>里:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">String</span>      <span class="title">String</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    byte*   str;</span><br><span class="line">    intgo   len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  String  runtime·emptystring;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>Go</code>中的<code>string</code>类型其实就是<code>String</code>这个类型。<br>之后<code>Go</code>实现了自举，从<code>runtime/string.go</code>中可以看到之前的影子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="todo-如何通过编译过程查找对应的类型定义"><a href="#todo-如何通过编译过程查找对应的类型定义" class="headerlink" title="todo: 如何通过编译过程查找对应的类型定义"></a>todo: 如何通过编译过程查找对应的类型定义</h3><h2 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h2><p><code>byte</code>的类型定义在 <code>builtin/builtin.go</code>中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uint8 is the set of all unsigned 8-bit integers.</span></span><br><span class="line"><span class="comment">// Range: 0 through 255.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">uint8</span> <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到其实<code>byte</code>是<code>uint8</code>的类型别名</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string-to-byte-slice"><a href="#string-to-byte-slice" class="headerlink" title="string to byte slice"></a>string to byte slice</h2><p>写一个<code>string</code>强制类型转换为<code>[]byte</code>的<code>demo</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">"strings"</span></span><br><span class="line">    <span class="keyword">var</span> b = []<span class="keyword">byte</span>(s)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过命令:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S -N -l main.go</span><br></pre></td></tr></table></figure></p>
<p>编译出汇编指令:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">317</span> args=<span class="number">0x0</span> locals=<span class="number">0xa8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (main.go:<span class="number">5</span>)    TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$168</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x002f</span> <span class="number">00047</span> (main.go:<span class="number">6</span>)    LEAQ    go.string.<span class="string">"strings"</span>(SB), <span class="built_in">AX</span></span><br><span class="line">    <span class="number">0x0036</span> <span class="number">00054</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.s+<span class="number">80</span>(<span class="built_in">SP</span>) # 把string内容放到这个位置</span><br><span class="line">    <span class="number">0x003b</span> <span class="number">00059</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="number">$7</span>, <span class="string">""</span>.s+<span class="number">88</span>(<span class="built_in">SP</span>) # 把string长度放到这个位置</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x005a</span> <span class="number">00090</span> (main.go:<span class="number">7</span>)    <span class="keyword">CALL</span>    runtime.stringtoslicebyte(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x008e</span> <span class="number">00142</span> (main.go:<span class="number">8</span>)    <span class="keyword">CALL</span>    runtime.convTslice(SB)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>上面可以看出当定义一个<code>string</code>时，其实会存储<code>string</code>的内容和长度, 对应前讲的<code>string</code>的结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct String</span><br><span class="line">&#123;</span><br><span class="line">    byte*   str;</span><br><span class="line">    intgo   len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后又调用了<code>runtime.stringtoslicebyte(SB)</code>, 在<code>runtime/string.go</code>中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123; <span class="comment">// 如果字符串的长度小于buf长度，直接使用buf</span></span><br><span class="line">        *buf = tmpBuf&#123;&#125;</span><br><span class="line">        b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = rawbyteslice(<span class="built_in">len</span>(s)) <span class="comment">// 否则调用这个进行内存申请</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(b, s) <span class="comment">// 内存 copy</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>buf</code>默认值是<code>32</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpStringBufSize = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tmpBuf [tmpStringBufSize]<span class="keyword">byte</span></span><br></pre></td></tr></table></figure></p>
<p>如果不满足长度，申请的内存大小为<code>len(s)</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawbyteslice</span><span class="params">(size <span class="keyword">int</span>)</span> <span class="params">(b []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">cap</span> := roundupsize(<span class="keyword">uintptr</span>(size))</span><br><span class="line">    p := mallocgc(<span class="built_in">cap</span>, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> != <span class="keyword">uintptr</span>(size) &#123;</span><br><span class="line">        memclrNoHeapPointers(add(p, <span class="keyword">uintptr</span>(size)), <span class="built_in">cap</span>-<span class="keyword">uintptr</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是类型的转换，把申请的内存变成一个slice结构，赋值给b的地址</span></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, <span class="keyword">int</span>(<span class="built_in">cap</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的过程重点有三个:</p>
<ol>
<li>当长度小于<code>32</code>时，直接使用临时内存地址</li>
<li>当长度大于<code>32</code>时，需要申请新的长度为<code>len(s)</code>的内存地址</li>
<li>需要进行内存的<code>copy</code></li>
</ol>
<h2 id="byte-slice-to-string"><a href="#byte-slice-to-string" class="headerlink" title="byte slice to string"></a>byte slice to string</h2><p>下面返回来，把一个<code>[]byte</code>转换为<code>string</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b = []<span class="keyword">byte</span>&#123;<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">string</span>(b)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的汇编代码是:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">371</span> args=<span class="number">0x0</span> locals=<span class="number">0xb8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (main.go:<span class="number">5</span>)    TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$184</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x005b</span> <span class="number">00091</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.b+<span class="number">128</span>(<span class="built_in">SP</span>) # 把slice内容放到这个位置</span><br><span class="line">    <span class="number">0x0063</span> <span class="number">00099</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="number">$3</span>, <span class="string">""</span>.b+<span class="number">136</span>(<span class="built_in">SP</span>) # 把slice len 放到这个位置</span><br><span class="line">    <span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="number">$3</span>, <span class="string">""</span>.b+<span class="number">144</span>(<span class="built_in">SP</span>) # 把slice cap 放到这个位置</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00a2</span> <span class="number">00162</span> (main.go:<span class="number">7</span>)    <span class="keyword">CALL</span>    runtime.slicebytetostring(SB) #调用这个函数进行转换</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00c4</span> <span class="number">00196</span> (main.go:<span class="number">8</span>)    <span class="keyword">CALL</span>    runtime.convTstring(SB)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>上面可以看出当定义一个<code>slice</code>时，其实会存储<code>slice</code>的内容和长度和容量, 对应之前讲的<code>slice</code>的结构:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后调用<code>runtime.slicebytetostring</code>函数, 在<code>runtime/string.go</code>中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buf is a fixed-size buffer for the result,</span></span><br><span class="line"><span class="comment">// it is not nil if the result does not escape.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, b []<span class="keyword">byte</span>)</span> <span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(b)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Turns out to be a relatively common case.</span></span><br><span class="line">        <span class="comment">// Consider that you want to parse out data between parens in "foo()bar",</span></span><br><span class="line">        <span class="comment">// you find the indices and convert the subslice to string.</span></span><br><span class="line">        <span class="comment">// 长度为0，直接返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为1，直接返回staticbytes[b[0]]这个提前设定好的地址内容</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// stringStruct结构的str字段指向对应的值得地址</span></span><br><span class="line">        stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="number">0</span>]])</span><br><span class="line">        <span class="comment">// stringStruct结构的len字段设置为1</span></span><br><span class="line">        stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">        p = unsafe.Pointer(buf)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = mallocgc(<span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stringStructOf(&amp;str).str = p</span><br><span class="line">    stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="built_in">len</span>(b)</span><br><span class="line">    memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/04/go-select/"><span>go select 原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/04/go-select/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-04T06:25:40.000Z">
          2019-07-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本篇主要介绍 <code>select</code> 的内部实现原理(基于go1.12), 通过源码和图形的方式展示 <code>select</code> 的内部结构及对<code>select</code> 进行操作的过程。</p>
</blockquote>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Go官方给出的<a href="https://tour.golang.org/concurrency/5" target="_blank" rel="noopener">例子</a>很简单:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出<code>Select</code>和<code>Switch</code>使用方法有点相似，不一样的地方在于:<strong><code>Select</code>的<code>case</code>条件必须是与<code>chan</code>相关的操作（从<code>chan</code>发送或者接收数据）</strong></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>关于<code>select</code>的编译过程可以从<code>$GOROOT/src/cmd/compile/internal/gc/select.go</code>中找到。</p>
<h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>为了研究代码的运行逻辑，我们可以借助针对<code>Go</code>开发的<code>debug</code>工具:<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">dlv</a>, 我们通过:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build  -gcflags=<span class="string">"all=-N -l"</span> <span class="variable">$GOROOT</span>/src/cmd/compile</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以使用对<code>compile</code>工具进行<code>debug</code>了, 通过下面的方式运行:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv <span class="built_in">exec</span> compile <span class="variable">$GOROOT</span>/src/cmd/compile/internal/gc/select.go</span><br></pre></td></tr></table></figure></p>
<p>然后分别给我们想要<code>debug</code>的地方打断点</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>我们对<code>typecheckselect</code>和<code>walkselect</code>函数打断点，可以知道运行顺序是<code>typecheckselect</code> -&gt; <code>walkselect</code>。<br>首先我们先来看<code>typecheckselect</code>函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckselect</span><span class="params">(sel *Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> def *Node</span><br><span class="line">    lno := setlineno(sel)</span><br><span class="line">    typecheckslice(sel.Ninit.Slice(), ctxStmt)</span><br><span class="line">    <span class="comment">// 遍历检查所有的case</span></span><br><span class="line">    <span class="keyword">for</span> _, ncase := <span class="keyword">range</span> sel.List.Slice() &#123;</span><br><span class="line">        <span class="comment">// 处理之前对每个case先进行检查是否是空的</span></span><br><span class="line">        <span class="keyword">if</span> ncase.Op != OXCASE &#123;</span><br><span class="line">            setlineno(ncase)</span><br><span class="line">            Fatalf(<span class="string">"typecheckselect %v"</span>, ncase.Op)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 后面是空条件，这种情况说明是default</span></span><br><span class="line">        <span class="keyword">if</span> ncase.List.Len() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// default</span></span><br><span class="line">            <span class="keyword">if</span> def != <span class="literal">nil</span> &#123;</span><br><span class="line">                yyerrorl(ncase.Pos, <span class="string">"multiple defaults in select (first at %v)"</span>, def.Line())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                def = ncase</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ncase.List.Len() &gt; <span class="number">1</span> &#123; <span class="comment">// case的值不支持多个表达式</span></span><br><span class="line">            yyerrorl(ncase.Pos, <span class="string">"select cases cannot be lists"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// case 只有一个表达式</span></span><br><span class="line">            ncase.List.SetFirst(typecheck(ncase.List.First(), ctxStmt))</span><br><span class="line">            n := ncase.List.First() <span class="comment">// 把case的第一个表达式赋值给 n</span></span><br><span class="line">            ncase.Left = n</span><br><span class="line">            ncase.List.Set(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">switch</span> n.Op &#123; <span class="comment">// 对 case 的具体操作进行检查</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 对于未知类型的case 进行下面的处理</span></span><br><span class="line">                pos := n.Pos</span><br><span class="line">                <span class="keyword">if</span> n.Op == ONAME &#123;</span><br><span class="line">                    <span class="comment">// We don't have the right position for ONAME nodes (see #15459 and</span></span><br><span class="line">                    <span class="comment">// others). Using ncase.Pos for now as it will provide the correct</span></span><br><span class="line">                    <span class="comment">// line number (assuming the expression follows the "case" keyword</span></span><br><span class="line">                    <span class="comment">// on the same line). This matches the approach before 1.10.</span></span><br><span class="line">                    pos = ncase.Pos</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  打印错误，只接受下面的几个类型</span></span><br><span class="line">                yyerrorl(pos, <span class="string">"select case must be receive, send or assign recv"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert x = &lt;-c into OSELRECV(x, &lt;-c).</span></span><br><span class="line">            <span class="comment">// remove implicit conversions; the eventual assignment</span></span><br><span class="line">            <span class="comment">// will reintroduce them.</span></span><br><span class="line">            <span class="comment">// 处理 case 为 x = &lt;-c 的表达式</span></span><br><span class="line">            <span class="keyword">case</span> OAS:</span><br><span class="line">                <span class="keyword">if</span> (n.Right.Op == OCONVNOP || n.Right.Op == OCONVIFACE) &amp;&amp; n.Right.Implicit() &#123;</span><br><span class="line">                    n.Right = n.Right.Left</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n.Right.Op != ORECV &#123;</span><br><span class="line">                    yyerrorl(n.Pos, <span class="string">"select assignment must have receive on right hand side"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n.Op = OSELRECV</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert x, ok = &lt;-c into OSELRECV2(x, &lt;-c) with ntest=ok</span></span><br><span class="line">            <span class="comment">// 处理 case 为 x, ok = &lt;-c 的表达式</span></span><br><span class="line">            <span class="keyword">case</span> OAS2RECV:</span><br><span class="line">                <span class="keyword">if</span> n.Rlist.First().Op != ORECV &#123;</span><br><span class="line">                    yyerrorl(n.Pos, <span class="string">"select assignment must have receive on right hand side"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n.Op = OSELRECV2</span><br><span class="line">                n.Left = n.List.First()</span><br><span class="line">                n.List.Set1(n.List.Second())</span><br><span class="line">                n.Right = n.Rlist.First()</span><br><span class="line">                n.Rlist.Set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert &lt;-c into OSELRECV(N, &lt;-c)</span></span><br><span class="line">            <span class="comment">// 处理 case 为 &lt;-c 的表达式</span></span><br><span class="line">            <span class="keyword">case</span> ORECV:</span><br><span class="line">                n = nodl(n.Pos, OSELRECV, <span class="literal">nil</span>, n)</span><br><span class="line"></span><br><span class="line">                n.SetTypecheck(<span class="number">1</span>)</span><br><span class="line">                ncase.Left = n</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OSEND: <span class="comment">// 无需要做特殊处理</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        typecheckslice(ncase.Nbody.Slice(), ctxStmt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lineno = lno</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再来看<code>walkselect</code>函数, 这个函数主要是对每个<code>case</code>进行处理，真正处理每个<code>case</code>的函数是<code>walkselectcases</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkselectcases</span><span class="params">(cases *Nodes)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line">    n := cases.Len()</span><br><span class="line">    sellineno := lineno</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optimization: zero-case select</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optimization: one-case select: single op.</span></span><br><span class="line">    <span class="comment">// TODO(rsc): Reenable optimization once order.go can handle it.</span></span><br><span class="line">    <span class="comment">// golang.org/issue/7672.</span></span><br><span class="line">    <span class="comment">// 处理只有一个 case 的情况</span></span><br><span class="line">    <span class="comment">// 处理结果是优化成: if xx &#123;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        cas := cases.First()</span><br><span class="line">        setlineno(cas)</span><br><span class="line">        l := cas.Ninit.Slice()</span><br><span class="line">        <span class="keyword">if</span> cas.Left != <span class="literal">nil</span> &#123; <span class="comment">// not default:</span></span><br><span class="line">            n := cas.Left</span><br><span class="line">            l = <span class="built_in">append</span>(l, n.Ninit.Slice()...)</span><br><span class="line">            n.Ninit.Set(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">var</span> ch *Node</span><br><span class="line">            <span class="keyword">switch</span> n.Op &#123; <span class="comment">// 根据操作符对齐进行词法分析，重新构造AST</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ok already</span></span><br><span class="line">            <span class="keyword">case</span> OSEND:</span><br><span class="line">                ch = n.Left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">                ch = n.Right.Left</span><br><span class="line">                <span class="keyword">if</span> n.Op == OSELRECV || n.List.Len() == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> n.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">                        n = n.Right</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        n.Op = OAS <span class="comment">// 转化为 Left = Right 表达式</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">                    nblank = typecheck(nblank, ctxExpr|ctxAssign)</span><br><span class="line">                    n.Left = nblank</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n.Op = OAS2 <span class="comment">//  转化为多赋值表达式:  List = Rlist (x, y, z = a, b, c)</span></span><br><span class="line">                n.List.Prepend(n.Left)</span><br><span class="line">                n.Rlist.Set1(n.Right)</span><br><span class="line">                n.Right = <span class="literal">nil</span></span><br><span class="line">                n.Left = <span class="literal">nil</span></span><br><span class="line">                n.SetTypecheck(<span class="number">0</span>)</span><br><span class="line">                n = typecheck(n, ctxStmt)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if ch == nil &#123; block() &#125;; n; // 转换为 if ch == nil &#123; block() &#125; 表达式</span></span><br><span class="line">            a := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 转化为: if Ninit; Left &#123; Nbody &#125; else &#123; Rlist &#125;</span></span><br><span class="line"></span><br><span class="line">            a.Left = nod(OEQ, ch, nodnil()) <span class="comment">// a.Left 转化为:  Left == Right, 既: ch == nil</span></span><br><span class="line">            <span class="keyword">var</span> ln Nodes</span><br><span class="line">            ln.Set(l)</span><br><span class="line">            a.Nbody.Set1(mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, &amp;ln)) <span class="comment">// Body 变为 block 调用</span></span><br><span class="line">            l = ln.Slice()</span><br><span class="line">            a = typecheck(a, ctxStmt)</span><br><span class="line">            l = <span class="built_in">append</span>(l, a, n)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l = <span class="built_in">append</span>(l, cas.Nbody.Slice()...)</span><br><span class="line">        l = <span class="built_in">append</span>(l, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert case value arguments to addresses.</span></span><br><span class="line">    <span class="comment">// this rewrite is used by both the general code and the next optimization.</span></span><br><span class="line">    <span class="comment">// 存在多个 case, 分别处理</span></span><br><span class="line">    <span class="keyword">for</span> _, cas := <span class="keyword">range</span> cases.Slice() &#123;</span><br><span class="line">        setlineno(cas)</span><br><span class="line">        n := cas.Left</span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">        <span class="keyword">case</span> OSEND:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optimization: two-case select but one is default: single non-blocking op.</span></span><br><span class="line">    <span class="comment">// 处理只有两个 case, 并且其中一个是 default 的情况</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &amp;&amp; (cases.First().Left == <span class="literal">nil</span> || cases.Second().Left == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cas *Node <span class="comment">// 非 default case</span></span><br><span class="line">        <span class="keyword">var</span> dflt *Node <span class="comment">// default case</span></span><br><span class="line">        <span class="keyword">if</span> cases.First().Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            cas = cases.Second() </span><br><span class="line">            dflt = cases.First()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dflt = cases.Second()</span><br><span class="line">            cas = cases.First()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n := cas.Left</span><br><span class="line">        setlineno(n)</span><br><span class="line">        r := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        r.Ninit.Set(cas.Ninit.Slice())</span><br><span class="line">        <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OSEND:</span><br><span class="line">            <span class="comment">// if selectnbsend(c, v) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">            ch := n.Left</span><br><span class="line">            r.Left = mkcall1(chanfn(<span class="string">"selectnbsend"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, ch, n.Right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OSELRECV:</span><br><span class="line">            <span class="comment">// if selectnbrecv(&amp;v, c) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">            ...</span><br><span class="line">            r.Left = mkcall1(chanfn(<span class="string">"selectnbrecv"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, elem, ch)</span><br><span class="line">        <span class="keyword">case</span> OSELRECV2:</span><br><span class="line">            <span class="comment">// if selectnbrecv2(&amp;v, &amp;received, c) &#123; body &#125; else &#123; default body &#125;   </span></span><br><span class="line">            ...</span><br><span class="line">            r.Left = mkcall1(chanfn(<span class="string">"selectnbrecv2"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, elem, receivedp, ch)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.Left = typecheck(r.Left, ctxExpr)</span><br><span class="line">        r.Nbody.Set(cas.Nbody.Slice())</span><br><span class="line">        r.Rlist.Set(<span class="built_in">append</span>(dflt.Ninit.Slice(), dflt.Nbody.Slice()...))</span><br><span class="line">        <span class="keyword">return</span> []*Node&#123;r, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> init []*Node</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate sel-struct</span></span><br><span class="line">    lineno = sellineno</span><br><span class="line">    selv := temp(types.NewArray(scasetype(), <span class="keyword">int64</span>(n)))</span><br><span class="line">    r := nod(OAS, selv, <span class="literal">nil</span>)</span><br><span class="line">    r = typecheck(r, ctxStmt)</span><br><span class="line">    init = <span class="built_in">append</span>(init, r)</span><br><span class="line"></span><br><span class="line">    order := temp(types.NewArray(types.Types[TUINT16], <span class="number">2</span>*<span class="keyword">int64</span>(n)))</span><br><span class="line">    r = nod(OAS, order, <span class="literal">nil</span>)</span><br><span class="line">    r = typecheck(r, ctxStmt)</span><br><span class="line">    init = <span class="built_in">append</span>(init, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register cases</span></span><br><span class="line">    <span class="keyword">for</span> i, cas := <span class="keyword">range</span> cases.Slice() &#123; <span class="comment">// 其它 case 的情况处理</span></span><br><span class="line">        setlineno(cas)</span><br><span class="line"></span><br><span class="line">        init = <span class="built_in">append</span>(init, cas.Ninit.Slice()...)</span><br><span class="line">        cas.Ninit.Set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep in sync with runtime/select.go.</span></span><br><span class="line">        <span class="keyword">const</span> (</span><br><span class="line">            caseNil = <span class="literal">iota</span></span><br><span class="line">            caseRecv</span><br><span class="line">            caseSend</span><br><span class="line">            caseDefault</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> c, elem *Node</span><br><span class="line">        <span class="keyword">var</span> kind <span class="keyword">int64</span> = caseDefault</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n := cas.Left; n != <span class="literal">nil</span> &#123;</span><br><span class="line">            init = <span class="built_in">append</span>(init, n.Ninit.Slice()...)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line">            <span class="keyword">case</span> OSEND:</span><br><span class="line">                kind = caseSend</span><br><span class="line">                c = n.Left</span><br><span class="line">                elem = n.Right</span><br><span class="line">            <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">                kind = caseRecv</span><br><span class="line">                c = n.Right.Left</span><br><span class="line">                elem = n.Left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setField := <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>, val *Node)</span></span> &#123;</span><br><span class="line">            r := nod(OAS, nodSym(ODOT, nod(OINDEX, selv, nodintconst(<span class="keyword">int64</span>(i))), lookup(f)), val)</span><br><span class="line">            r = typecheck(r, ctxStmt)</span><br><span class="line">            init = <span class="built_in">append</span>(init, r)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setField(<span class="string">"kind"</span>, nodintconst(kind))</span><br><span class="line">        <span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">            c = convnop(c, types.Types[TUNSAFEPTR])</span><br><span class="line">            setField(<span class="string">"c"</span>, c)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            elem = convnop(elem, types.Types[TUNSAFEPTR])</span><br><span class="line">            setField(<span class="string">"elem"</span>, elem)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(mdempsky): There should be a cleaner way to</span></span><br><span class="line">        <span class="comment">// handle this.</span></span><br><span class="line">        <span class="keyword">if</span> instrumenting &#123;</span><br><span class="line">            r = mkcall(<span class="string">"selectsetpc"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, bytePtrToIndex(selv, <span class="keyword">int64</span>(i)))</span><br><span class="line">            init = <span class="built_in">append</span>(init, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run the select</span></span><br><span class="line">    lineno = sellineno</span><br><span class="line">    chosen := temp(types.Types[TINT])</span><br><span class="line">    recvOK := temp(types.Types[TBOOL])</span><br><span class="line">    r = nod(OAS2, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">    r.List.Set2(chosen, recvOK)</span><br><span class="line">    fn := syslook(<span class="string">"selectgo"</span>)</span><br><span class="line">    r.Rlist.Set1(mkcall1(fn, fn.Type.Results(), <span class="literal">nil</span>, bytePtrToIndex(selv, <span class="number">0</span>), bytePtrToIndex(order, <span class="number">0</span>), nodintconst(<span class="keyword">int64</span>(n))))</span><br><span class="line">    r = typecheck(r, ctxStmt)</span><br><span class="line">    init = <span class="built_in">append</span>(init, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// selv and order are no longer alive after selectgo.</span></span><br><span class="line">    init = <span class="built_in">append</span>(init, nod(OVARKILL, selv, <span class="literal">nil</span>))</span><br><span class="line">    init = <span class="built_in">append</span>(init, nod(OVARKILL, order, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch cases</span></span><br><span class="line">    <span class="keyword">for</span> i, cas := <span class="keyword">range</span> cases.Slice() &#123;</span><br><span class="line">        setlineno(cas)</span><br><span class="line"></span><br><span class="line">        cond := nod(OEQ, chosen, nodintconst(<span class="keyword">int64</span>(i)))</span><br><span class="line">        cond = typecheck(cond, ctxExpr)</span><br><span class="line">        cond = defaultlit(cond, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        r = nod(OIF, cond, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n := cas.Left; n != <span class="literal">nil</span> &amp;&amp; n.Op == OSELRECV2 &#123;</span><br><span class="line">            x := nod(OAS, n.List.First(), recvOK)</span><br><span class="line">            x = typecheck(x, ctxStmt)</span><br><span class="line">            r.Nbody.Append(x)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.Nbody.AppendNodes(&amp;cas.Nbody)</span><br><span class="line">        r.Nbody.Append(nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">        init = <span class="built_in">append</span>(init, r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> init</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对<code>select</code>不同<code>case</code>的情况编译的方式不用:</p>
<h4 id="没有case"><a href="#没有case" class="headerlink" title="没有case"></a>没有<code>case</code></h4><p>看一下相关代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接调用<code>block</code><br>由于没又对应的<code>chan</code>处理，所以当前<code>goroutine</code>进入休眠状态，无法被唤醒</p>
<h4 id="只有1个case"><a href="#只有1个case" class="headerlink" title="只有1个case"></a>只有<strong>1</strong>个<code>case</code></h4><p>对应源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">    cas := cases.First()</span><br><span class="line">    setlineno(cas)</span><br><span class="line">    l := cas.Ninit.Slice()</span><br><span class="line">    <span class="keyword">if</span> cas.Left != <span class="literal">nil</span> &#123; <span class="comment">// not default:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ok already</span></span><br><span class="line">        <span class="keyword">case</span> OSEND:</span><br><span class="line">            ch = n.Left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if ch == nil &#123; block() &#125;; n;</span></span><br><span class="line">        a := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        a.Left = nod(OEQ, ch, nodnil())</span><br><span class="line">        <span class="keyword">var</span> ln Nodes</span><br><span class="line">        ln.Set(l)</span><br><span class="line">        a.Nbody.Set1(mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, &amp;ln))</span><br><span class="line">        l = ln.Slice()</span><br><span class="line">        a = typecheck(a, ctxStmt)</span><br><span class="line">        l = <span class="built_in">append</span>(l, a, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">append</span>(l, cas.Nbody.Slice()...) <span class="comment">// 指的是下面的具体case处理内容</span></span><br><span class="line">    l = <span class="built_in">append</span>(l, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实也分为两种方式，</p>
<h5 id="一种是这个case是default"><a href="#一种是这个case是default" class="headerlink" title="一种是这个case是default"></a>一种是这个<code>case</code>是<code>default</code></h5><p>直接把 <code>case</code> 对应的 <code>body</code> 放入 <code>AST</code> 中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转换为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"default"</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="另一种是这个case不是default"><a href="#另一种是这个case不是default" class="headerlink" title="另一种是这个case不是default:"></a>另一种是这个<code>case</code>不是<code>default</code>:</h5><p>转换一下 <code>case</code> 表达式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok &lt;-ch:</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转换为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<h4 id="有2个case-其中一个是default"><a href="#有2个case-其中一个是default" class="headerlink" title="有2个case, 其中一个是default"></a>有<strong>2</strong>个<code>case</code>, 其中一个是<code>default</code></h4><p>对于有两个, 但是其中一个为<code>default</code>的，具体处理代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optimization: two-case select but one is default: single non-blocking op.</span></span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">2</span> &amp;&amp; (cases.First().Left == <span class="literal">nil</span> || cases.Second().Left == <span class="literal">nil</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> cas *Node</span><br><span class="line">       <span class="keyword">var</span> dflt *Node</span><br><span class="line">       <span class="keyword">if</span> cases.First().Left == <span class="literal">nil</span> &#123;</span><br><span class="line">           cas = cases.Second()</span><br><span class="line">           dflt = cases.First()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dflt = cases.Second()</span><br><span class="line">           cas = cases.First()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       n := cas.Left</span><br><span class="line">       setlineno(n)</span><br><span class="line">       r := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">       r.Ninit.Set(cas.Ninit.Slice())</span><br><span class="line">       <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> OSEND:</span><br><span class="line">           <span class="comment">// if selectnbsend(c, v) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">           ch := n.Left</span><br><span class="line">           r.Left = mkcall1(chanfn(<span class="string">"selectnbsend"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, ch, n.Right)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> OSELRECV:</span><br><span class="line">           <span class="comment">// if selectnbrecv(&amp;v, c) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">           ...</span><br><span class="line">           r.Left = mkcall1(chanfn(<span class="string">"selectnbrecv"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, elem, ch)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> OSELRECV2:</span><br><span class="line">           <span class="comment">// if selectnbrecv2(&amp;v, &amp;received, c) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">           ...</span><br><span class="line">           r.Rlist.Set(<span class="built_in">append</span>(dflt.Ninit.Slice(), dflt.Nbody.Slice()...))</span><br><span class="line">           <span class="keyword">return</span> []*Node&#123;r, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到真对每个<code>case</code>的具体操作可以转为不同的形式，具体的可以参考针对每个 <code>case</code> 所调用的函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  select &#123;</span></span><br><span class="line"><span class="comment">//  case c &lt;- v:</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  &#125; else &#123;</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  select &#123;</span></span><br><span class="line"><span class="comment">//  case v = &lt;-c:</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  if selectnbrecv(&amp;v, c) &#123;</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  &#125; else &#123;</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  select &#123;</span></span><br><span class="line"><span class="comment">//  case v, ok = &lt;-c:</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  if c != nil &amp;&amp; selectnbrecv2(&amp;v, &amp;ok, c) &#123;</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  &#125; else &#123;</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv2</span><span class="params">(elem unsafe.Pointer, received *<span class="keyword">bool</span>, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// TODO(khr): just return 2 values from this function, now that it is in Go.</span></span><br><span class="line">    selected, *received = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2个以上case-或两个case并且没有default"><a href="#2个以上case-或两个case并且没有default" class="headerlink" title="2个以上case, 或两个case并且没有default"></a><strong>2</strong>个以上<code>case</code>, 或两个<code>case</code>并且没有<code>default</code></h4><p>对于这种情况，主要是调用了 <code>selectgo</code>来处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn := syslook(<span class="string">"selectgo"</span>)</span><br><span class="line">r.Rlist.Set1(mkcall1(fn, fn.Type.Results(), <span class="literal">nil</span>, bytePtrToIndex(selv, <span class="number">0</span>), bytePtrToIndex(order, <span class="number">0</span>), nodintconst(<span class="keyword">int64</span>(n))))</span><br></pre></td></tr></table></figure></p>
<p>用图形来表示这时的<code>select</code>结构如下:<br><img src="/assets/img/go/select/2more_case.png" alt><br>详细内容参考下面的 <code>selectgo</code>的分析</p>
<h2 id="select-源码分析"><a href="#select-源码分析" class="headerlink" title="select 源码分析"></a>select 源码分析</h2><p>前面主要是介绍<code>select</code>的基本语法和词法分析过程，下面针对<code>select</code>的运行时代码进行分析</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>在分析源码之前，先写一个<code>demo</code>, 然后通过编译成汇编，看看内部是如何调用的, 还是使用官方给出的<code>demo</code>, 对其进行编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S select.go</span><br></pre></td></tr></table></figure></p>
<p>输出汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.fibonacci STEXT size=<span class="number">354</span> args=<span class="number">0x10</span> locals=<span class="number">0xc8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (select2.go:<span class="number">5</span>) TEXT    <span class="string">""</span>.fibonacci(SB), ABIInternal, <span class="number">$200</span>-<span class="number">16</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00d4</span> <span class="number">00212</span> (select2.go:<span class="number">8</span>) <span class="keyword">CALL</span>    runtime.selectgo(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00d4</span> <span class="number">00212</span> (select2.go:<span class="number">8</span>) <span class="keyword">CALL</span>    runtime.selectgo(SB)</span><br></pre></td></tr></table></figure></p>
<p>可以看出调用了<code>runtime.selectgo</code>函数，这个函数的实现在<code>runtime/select.go:155</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectgo implements the select statement.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// cas0 points to an array of type [ncases]scase, and order0 points to</span></span><br><span class="line"><span class="comment">// an array of type [2*ncases]uint16. Both reside on the goroutine's</span></span><br><span class="line"><span class="comment">// stack (regardless of any escaping in selectgo).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// selectgo returns the index of the chosen scase, which matches the</span></span><br><span class="line"><span class="comment">// ordinal position of its respective select&#123;recv,send,default&#125; call.</span></span><br><span class="line"><span class="comment">// Also, if the chosen scase was a receive operation, it reports whether</span></span><br><span class="line"><span class="comment">// a value was received.</span></span><br><span class="line"><span class="comment">// cas0 是指向类型为 [ncases]scase 的数组, 其实就是我们 select 写的 case 组成的数组</span></span><br><span class="line"><span class="comment">// order0 指向的是一个类型为 [2*ncases]uint16 的数组</span></span><br><span class="line"><span class="comment">// cas0 和 order0 都存在于 goroutine 的栈中(不考虑逃逸分析)</span></span><br><span class="line"><span class="comment">// selectgo 返回的是要执行的 case 的索引(index)</span></span><br><span class="line"><span class="comment">// 如果 case 是 recv 操作, 还没返回是否接收到了数据(第二个 bool 参数)</span></span><br><span class="line"><span class="comment">// ncases 表示的是 case 的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0)) <span class="comment">// 创建一个长度为[1&lt;&lt;16]的数组，并把cas0的地址赋值给cas1, 现在cas1表示了所有的case</span></span><br><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0)) <span class="comment">// 创建一个长度为[1&lt;&lt;17]的数组，指向order0</span></span><br><span class="line"></span><br><span class="line">	scases := cas1[:ncases:ncases] <span class="comment">// scases 包含了所有的case, 并且cap为case的个数</span></span><br><span class="line">	pollorder := order1[:ncases:ncases] <span class="comment">// 长度为case个数的数组，其实里面的内容是要放case的执行顺序</span></span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases] <span class="comment">// 指向order1的后面的存储空间, 内容是要存放根据chan的地址顺序排序的所有chan</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line">	<span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line">    <span class="comment">// 先对所有case进行处理，忽略case.c = nil, 也就是对应的chan已经被关闭或者其他情况导致的nil</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">		<span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">			*cas = scase&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line">	<span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line">	<span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line">	<span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line">	<span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line">	<span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line">	<span class="comment">// optimizing (and needing to test).</span></span><br><span class="line">    <span class="comment">// 编译器已经把对于只有0或者1个case+default的形式给优化成了简单的结构</span></span><br><span class="line">    <span class="comment">// 这个我们处理的是更多的select case的情况</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate permuted order</span></span><br><span class="line">    <span class="comment">// 对 case 进行随机排序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>)) <span class="comment">// 快速求随机数, 范围: [0, i]</span></span><br><span class="line">		pollorder[i] = pollorder[j] <span class="comment">// 第 i 个数据的值 = 第 j 个数据的值</span></span><br><span class="line">		pollorder[j] = <span class="keyword">uint16</span>(i) <span class="comment">// 第 j 个数的值赋值为 i</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line">	<span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line">    <span class="comment">// 对所有case 中的 hchan 按照地址进行堆排序</span></span><br><span class="line">    <span class="comment">// 排完序后是为了对齐进行加锁，防止重复加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hchan 地址构建大顶堆</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := i</span><br><span class="line">		<span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">		c := scases[pollorder[i]].c</span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">			k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">			lockorder[j] = lockorder[k]</span><br><span class="line">			j = k</span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = pollorder[i]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 进行堆排序</span></span><br><span class="line">	<span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		o := lockorder[i]</span><br><span class="line">		c := scases[o].c</span><br><span class="line">		lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">		j := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				k++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">				lockorder[j] = lockorder[k]</span><br><span class="line">				j = k</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = o</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">    <span class="comment">// 根据lockorder对scases的chan上锁，具体实现参考下面对sellock函数的介绍</span></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		gp     *g</span><br><span class="line">		sg     *sudog</span><br><span class="line">		c      *hchan</span><br><span class="line">		k      *scase</span><br><span class="line">		sglist *sudog</span><br><span class="line">		sgnext *sudog</span><br><span class="line">		qp     unsafe.Pointer</span><br><span class="line">		nextp  **sudog</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line">    <span class="comment">// 第一种情况，已经有满足的 case 条件</span></span><br><span class="line">	<span class="keyword">var</span> dfli <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> dfl *scase</span><br><span class="line">	<span class="keyword">var</span> casi <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> cas *scase</span><br><span class="line">	<span class="keyword">var</span> recvOK <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123; <span class="comment">// 根据之前的随机顺序访问</span></span><br><span class="line">		casi = <span class="keyword">int</span>(pollorder[i])</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseNil: <span class="comment">// 如果当前 case 是一个 nil 的 chan, 则不处理，继续寻找其他的 case</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseRecv: <span class="comment">// 如果是接收数据的 case</span></span><br><span class="line">			sg = c.sendq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123; <span class="comment">// sg != nil 这证明 buf已经满了，或者是一个不带buf的chan, 然后执行 recv函数，recv的过程可以参考 go channel 原理的介绍</span></span><br><span class="line">				<span class="keyword">goto</span> recv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123; <span class="comment">// 如果 qcount &gt; 0 这证明 buf 里是有数据的，所有从 buf 里取数据</span></span><br><span class="line">				<span class="keyword">goto</span> bufrecv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123; <span class="comment">// 对应的chan已经被关闭了</span></span><br><span class="line">				<span class="keyword">goto</span> rclose</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend: <span class="comment">// 如果是发送数据</span></span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123; <span class="comment">// 如果被关闭了，进入sclose， 最终会 panic</span></span><br><span class="line">				<span class="keyword">goto</span> sclose</span><br><span class="line">			&#125;</span><br><span class="line">			sg = c.recvq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123; <span class="comment">// recv队列不为空，则执行 send 函数, 参考 go channel 中 send 的处理</span></span><br><span class="line">				<span class="keyword">goto</span> send</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123; <span class="comment">// 证明 buf 还没满，直接发送到 buf 中</span></span><br><span class="line">				<span class="keyword">goto</span> bufsend</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseDefault: <span class="comment">// case 是 default case，这里其实时延迟赋值，如果运行了其他case, 就没必要赋值了</span></span><br><span class="line">			dfli = casi <span class="comment">// default 的下标</span></span><br><span class="line">			dfl = cas  <span class="comment">// 给 default 赋值</span></span><br><span class="line">            <span class="comment">// 继续寻找其他case</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走到这里证明没有准备好的chan case能够执行，下面会优先执行 default</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123; <span class="comment">// default 不为空</span></span><br><span class="line">		selunlock(scases, lockorder) <span class="comment">// 对已经上锁的进行解锁</span></span><br><span class="line">		casi = dfli</span><br><span class="line">		cas = dfl</span><br><span class="line">		<span class="keyword">goto</span> retc  <span class="comment">// 直接返回 default 的 index </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">    <span class="comment">// 走到这里所有的case都无法运行</span></span><br><span class="line">    <span class="comment">// 把所有的chan都进入阻塞状态</span></span><br><span class="line">    <span class="comment">// 具体细节可以参考 go  channel 的操作</span></span><br><span class="line">	gp = getg()</span><br><span class="line">	<span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		casi = <span class="keyword">int</span>(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.isSelect = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">		<span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">		sg.elem = cas.elem</span><br><span class="line">		sg.releasetime = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.c = c</span><br><span class="line">		<span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">		*nextp = sg</span><br><span class="line">		nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for someone to wake us up</span></span><br><span class="line">    <span class="comment">// 这里当前goroutine会进入阻塞，让出CPU, 等待chan可以发送或者接收数据时就被唤醒，这个可以参考chan的实现:</span></span><br><span class="line">    <span class="comment">// 当前goroutine进入recvq或sendq， 当任何一个chan被其他goroutine操作时，就会把当前goroutine唤醒</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>) <span class="comment">//阻塞，直到被唤醒</span></span><br><span class="line"></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	gp.selectDone = <span class="number">0</span></span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line">	<span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line">	<span class="comment">// record the successful case, if any.</span></span><br><span class="line">	<span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">	casi = <span class="number">-1</span></span><br><span class="line">	cas = <span class="literal">nil</span></span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	<span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line">	<span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">		sg1.isSelect = <span class="literal">false</span></span><br><span class="line">		sg1.elem = <span class="literal">nil</span></span><br><span class="line">		sg1.c = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		<span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			k.releasetime = sglist.releasetime</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">			<span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line">			casi = <span class="keyword">int</span>(casei)</span><br><span class="line">			cas = k <span class="comment">// 寻找当前被唤醒的case</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = k.c</span><br><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist) <span class="comment">// 出队, 但是不处理对应的 chan 值</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist) <span class="comment">// 出队, 但是不处理对应的 chan 值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">		releaseSudog(sglist) <span class="comment">// 释放当前 sglist</span></span><br><span class="line">		sglist = sgnext <span class="comment">// 继续处理下一个 sglist</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果没有被唤醒的case(在一些情况下, 如: close chan等)</span></span><br><span class="line">	<span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class="line">		<span class="comment">// when a channel involved in the select has been closed.</span></span><br><span class="line">		<span class="comment">// It is easiest to loop and re-run the operation;</span></span><br><span class="line">		<span class="comment">// we'll see that it's now closed.</span></span><br><span class="line">		<span class="comment">// Maybe some day we can signal the close explicitly,</span></span><br><span class="line">		<span class="comment">// but we'd have to distinguish close-on-reader from close-on-writer.</span></span><br><span class="line">		<span class="comment">// It's easiest not to duplicate the code and just recheck above.</span></span><br><span class="line">		<span class="comment">// We know that something closed, and things never un-close,</span></span><br><span class="line">		<span class="comment">// so we won't block again.</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">		recvOK = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line">	<span class="comment">// can receive from buffer</span></span><br><span class="line">    <span class="comment">// 处理从 buf recv 的情况</span></span><br><span class="line">    ...</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	<span class="comment">// can send to buffer</span></span><br><span class="line">    <span class="comment">// 处理从 buf send 的情况</span></span><br><span class="line">    ...</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">    <span class="comment">// 直接从 goroutine 中 recv</span></span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncrecv: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line">	<span class="comment">// read at end of closed channel</span></span><br><span class="line">    <span class="comment">// recv close chan 的情况</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line">    <span class="comment">// 直接从 goroutine 中 send</span></span><br><span class="line">    ...</span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncsend: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line">    <span class="comment">// 返回 index 和 recv 状态</span></span><br><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	<span class="comment">// send on closed channel</span></span><br><span class="line">    <span class="comment">// send close chan 的情况</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是整个<code>select</code>的选择过程。<br>其中 每个case <code>scase</code> 的数据结构如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select case descriptor.</span></span><br><span class="line"><span class="comment">// Known to compiler.</span></span><br><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's scasetype.</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">    c           *hchan         <span class="comment">// case 语句中使用到的 chan</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">    kind        <span class="keyword">uint16</span> <span class="comment">// case的类型，包括send, recv, default等</span></span><br><span class="line">    pc          <span class="keyword">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对每个<code>case</code>的<code>chan</code>上锁的过程如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 select 的 case.c 上锁，根据 lockorder 的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sellock</span><span class="params">(scases []scase, lockorder []<span class="keyword">uint16</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">        c0 := scases[o].c</span><br><span class="line">        <span class="keyword">if</span> c0 != <span class="literal">nil</span> &amp;&amp; c0 != c &#123; <span class="comment">// 这个判断如果不满足证明当前chan和前一个chan地址是一样的，只上一次锁就行了</span></span><br><span class="line">            c = c0</span><br><span class="line">            lock(&amp;c.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的过程也可以用一个流程图来表示:<br><img src="/assets/img/go/select/select_process.svg" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.gopl.io/" target="_blank" rel="noopener">The Go Programming Language</a><br><a href="https://draveness.me/golang/keyword/golang-select.html" target="_blank" rel="noopener">select 源码分析</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/27/go-channel/"><span>go channel 原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/27/go-channel/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-27T09:27:24.000Z">
          2019-06-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本篇主要介绍<code>chan</code>的内部实现原理(基于go1.12), 通过源码和图形的方式展示<code>chan</code>的内部结构及对<code>chan</code>进行操作的过程。</p>
</blockquote>
<h2 id="make-chan"><a href="#make-chan" class="headerlink" title="make chan"></a>make chan</h2><p>在进入源码分析之前，我们假设自己并不知道去哪里看其源码，我们先简单的创建一个<code>chan</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了分析其内部实现，我们可以通过<code>compile</code>工具对其编译生成伪汇编代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S chan.go</span><br></pre></td></tr></table></figure></p>
<p>生成的汇编代码重点的内容入下:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">71</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (chan1.go:<span class="number">3</span>)   TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$32</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0031</span> <span class="number">00049</span> (chan1.go:<span class="number">4</span>)   <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0045</span> <span class="number">00069</span> (chan1.go:<span class="number">3</span>)   <span class="keyword">JMP</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到执行<code>make</code>其实最终执行的是<code>runtime.makechan</code>这个函数，这个函数的实现在<code>runtime/chan.go</code>文件中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line">    ...</span><br><span class="line">    mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Queue or element size is zero.</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">        <span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Elements contain pointers.</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></p>
<p>可以看到最终会返回一个<code>*hchan</code>类型，这个就是<code>chan</code>的结构体:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 队列中有数据的个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 循环队列的大小z</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向循环队列的地址</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         </span><br><span class="line">    closed   <span class="keyword">uint32</span> <span class="comment">// chan的关闭状态</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// 队列中下一个要发送的数据的下标</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// 队列中下一个要接收的数据的下标</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 等待接受的G队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 等待发送的G队列</span></span><br><span class="line">    lock     mutex  <span class="comment">// 操作chan是需要加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完上面的<code>make</code>后，生成的<code>chan</code>如下:<br><img src="/assets/img/go/channel/makechan.png" alt></p>
<h2 id="send-chan"><a href="#send-chan" class="headerlink" title="send chan"></a>send chan</h2><p>为了了解我们往<code>chan</code>发送的时候都做了什么我可能先写一个demo:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看其汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">97</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (chan2.go:<span class="number">3</span>)   TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$32</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0031</span> <span class="number">00049</span> (chan2.go:<span class="number">4</span>)   <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x004b</span> <span class="number">00075</span> (chan2.go:<span class="number">5</span>)   <span class="keyword">CALL</span>    runtime.chansend1(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x005f</span> <span class="number">00095</span> (chan2.go:<span class="number">3</span>)   <span class="keyword">JMP</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出我们往<code>chan</code>发送数据其实执行的是<code>runtime.chansend1</code>函数，这个函数很简简单，只是调用了<code>runtime.chansend</code>函数,我们主要看一下<code>runtime.chansend</code>函数的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 往已经 closed 的 chan 发送数据会直接 panic</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果有接收队列，则进入send函数</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 没有接收队列，buf还没有满，则直接往里放数据</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123; <span class="comment">//如果sendx == dataqsize, 证明buf满了，</span></span><br><span class="line">            c.sendx = <span class="number">0</span> <span class="comment">// c.sendx=0保证了又从头开始，形成了一个循环队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个sudog结构, 把当前发送数据所在的g和要发送的数据都放到这里</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.sendq.enqueue(mysg) <span class="comment">// 把这个sudog结构体放到发送对队列中</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>) <span class="comment">//阻塞当前g,直到由于可以发送数据而被唤醒</span></span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们有一个图来表示其过程，图中主要分为下面几个步骤:</p>
<ol>
<li>往上面初始化好的<code>hchan</code>结构体发送第 1 个数据: 数据放到<code>buf[0]</code>的位置</li>
<li>往<code>hchan</code>结构体发送第 2 个数据: 数据放到<code>buf[1]</code>的位置</li>
<li>往<code>hchan</code>结构体发送第 3 个数据: 数据放到<code>buf[2]</code>的位置, 这时<code>buf</code><strong>满了</strong></li>
<li>往<code>buf</code>满了的<code>hchan</code>结构体发送第 4 个数据: <code>g1</code>会放到<code>sudog</code>结构体中，并放到<code>sendq</code>队列中，等待被唤醒</li>
<li>往<code>buf</code>满了的<code>hchan</code>结构体发送第 5 个数据: <code>g2</code>会放到<code>sudog</code>结构体中，并放到<code>sendq</code>队列中，等待被唤醒</li>
</ol>
<p><img src="/assets/img/go/channel/send.gif" alt></p>
<h2 id="recv-chan"><a href="#recv-chan" class="headerlink" title="recv chan"></a>recv chan</h2><p>同上面一样，我们先写一个<code>demo</code>看看<code>recv</code>调用的是哪个函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">94</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0031</span> <span class="number">00049</span> (chan3.go:<span class="number">4</span>)       <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0048</span> <span class="number">00072</span> (chan3.go:<span class="number">5</span>)       <span class="keyword">CALL</span>    runtime.chanrecv1(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x005c</span> <span class="number">00092</span> (chan3.go:<span class="number">3</span>)       <span class="keyword">JMP</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>同样<code>runtime.chanrecv1</code>也是简单调用了<code>runtime.chanrecv</code>函数，具体代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">        c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 如果chan已经被关闭，并且qcount==0, 则返回默认零值+false(如x, ok := &lt;- c, x是零值，ok=false)</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在接收的时候有发送队列存在，则执行recv函数</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">        <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">        <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">        <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在buf, 存在数据</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Receive directly from queue</span></span><br><span class="line">        qp := chanbuf(c, c.recvx) <span class="comment">//获取recvx位置的地址</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp) <span class="comment">// 把recvx位置的数据copy到接收的变量中</span></span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp) <span class="comment">// 清空原来recvx位置的数据</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123; <span class="comment">// 如果recvx == dataqsiz 证明已经到达最后一个，需要从头开始</span></span><br><span class="line">            c.recvx = <span class="number">0</span> <span class="comment">//从头开始，形成一个循环队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog() <span class="comment">// 获取一个sudog结构，把对应的g和接收数据的变量地址放到sudog中</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.recvq.enqueue(mysg) <span class="comment">// 把sudog放入接收队列中</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>) <span class="comment">//阻塞当前g，直到被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closed := gp.param == <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面说到如果存在发送队列就会执行<code>recv</code>函数，下面看一下这个函数的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//对于nobuf的chan, 直接copy数据</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racesync(c, sg)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// copy data from sender</span></span><br><span class="line">            recvDirect(c.elemtype, sg, ep)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">        <span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">        <span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">        <span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">        qp := chanbuf(c, c.recvx) <span class="comment">// 获取接收数据的位置</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy data from queue to receiver</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp) <span class="comment">//把recvx位置的数据copy到接收的变量中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy data from sender to queue</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, sg.elem) <span class="comment">// 把发送队列的数据copy到当前recvx的位置</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为上面把发送队列的数据copy到了recvx, 为了保证下一个位置属按照顺序的，需要sendx = recvx</span></span><br><span class="line">        <span class="comment">// 这几步保证了chan是一个FIFO的过程</span></span><br><span class="line">        c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz </span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 把出队的g放到ready中，下次调度就可以运行了，不再阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们有一个图来表示接收数据的过程，图中主要分为下面几个步骤:</p>
<ol>
<li>初始的<code>hchan</code>是上面<code>send</code>之后的结构</li>
<li><code>g3</code>执行接收操作，首先会把发送队列中的第 1 个<code>g1</code>出队，然后把<code>buf[0]</code>的数据赋值到<code>g3</code>中，再把<code>g1</code>的数据赋值到<code>buf[0]</code>中</li>
<li><code>g3</code>执行接收操作，首先会把发送队列中的第 2 个<code>g2</code>出队，然后把<code>buf[1]</code>的数据赋值到<code>g3</code>中，再把<code>g2</code>的数据赋值到<code>buf[1]</code>中</li>
<li>这个时候没有发送队列了，所以可以直接把<code>buf[2]</code>中的书赋值到<code>g3</code>中</li>
<li>把下一个数据<code>buf[0]</code>中的书赋值到<code>g3</code>中</li>
<li>把最后一个数据<code>buf[1]</code>中的书赋值到<code>g3</code>中</li>
<li>已经没有数据可以赋值给<code>g3</code>了，所以<code>g3</code>被放入<code>sudog</code>结构体中，入队到了接收队列, 进入阻塞状态</li>
</ol>
<p><img src="/assets/img/go/channel/recv.gif" alt></p>
<h2 id="send-chan-again"><a href="#send-chan-again" class="headerlink" title="send chan again"></a>send chan again</h2><p>上面介绍<code>send</code>说到如果发送数据的时候有<code>recvq</code>队列就会调用<code>send</code>函数，这个函数的具体实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">            racesync(c, sg) <span class="comment">// no buf 直接同步</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Pretend we go through the buffer, even though</span></span><br><span class="line">            <span class="comment">// we copy directly. Note that we need to increment</span></span><br><span class="line">            <span class="comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">            qp := chanbuf(c, c.recvx) <span class="comment">// 获取recvx位置</span></span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">            c.recvx++</span><br><span class="line">            <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">                c.recvx = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep) <span class="comment">//直接把要发送的数据 copy 到 recvq 队列出队的 g 中</span></span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 把g放到ready队列中，下次有机会被调度，不再阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/go/channel/send-recv.gif" alt></p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>当我们<code>close</code>掉一个<code>chan</code>都发生了什么呢? 下面写一个<code>close</code>的<code>demo</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">85</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0031</span> <span class="number">00049</span> (chan4.go:<span class="number">4</span>)       <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x003f</span> <span class="number">00063</span> (chan4.go:<span class="number">5</span>)       <span class="keyword">CALL</span>    runtime.closechan(SB)</span><br><span class="line">        <span class="number">0x0053</span> <span class="number">00083</span> (chan4.go:<span class="number">3</span>)       <span class="keyword">JMP</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以调用了<code>runtime.closechan</code>函数，对应的代码为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>)) <span class="comment">// 已经关闭的 chan 不能再关闭</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">        racerelease(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.closed = <span class="number">1</span> <span class="comment">// 关闭状态设置为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line">    <span class="comment">// release all readers</span></span><br><span class="line">    <span class="comment">// 遍历所有recvq 队列, 从队列中去掉，并清空其内容，把所有g都放到glist结构中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">            sg.elem = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有 sendq 队列, 从队列中去掉，把所有g都放到glist结构中</span></span><br><span class="line">    <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">    <span class="comment">// 把刚才所有放到 glist 中的 g 都改为ready 状态，使其不再阻塞</span></span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们分别看一下:</p>
<ol>
<li><p>当存在<code>recvq</code>队列时:<br><img src="/assets/img/go/channel/close-recv.gif" alt></p>
</li>
<li><p>当存在<code>sendq</code>队列时:</p>
</li>
</ol>
<p><img src="/assets/img/go/channel/close-send.gif" alt></p>
<h2 id="no-buffer-chan"><a href="#no-buffer-chan" class="headerlink" title="no buffer chan"></a>no buffer chan</h2><p>前面讲的都是带<code>buffer</code>的<code>chan</code>, 还有一种是经常使用的不带<code>buffer</code>的<code>chan</code>，其实处理起来更简单，前面源码部分已经有涉及了，下面看一下操作过程:</p>
<ol>
<li><code>make</code>一个不带<code>buffer</code>的<code>chan</code></li>
<li><code>g1</code>向这个<code>chan</code>发送数据, 由于没有接收者而被阻塞，放到<code>sendq</code>中</li>
<li><code>g2</code>继续想这个<code>chan</code>发送数据，继续放到<code>sendq</code>中</li>
<li>来一个接收者<code>g3</code>, 这时把<code>g1</code>从<code>sendq</code>中出队，并把<code>elem</code>的值赋值给<code>g3</code>的<code>x</code></li>
<li><code>g3</code>继续接收,把<code>g2</code>从<code>sendq</code>中出队，并把<code>elem</code>的值赋值给<code>g3</code>的<code>x</code></li>
<li>没有发送队列存在，<code>g3</code>也进入了阻塞状态，放到了<code>recvq</code>队列中</li>
</ol>
<p>下面是其图形化展示:<br><img src="/assets/img/go/channel/no-buf-chan.gif" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/w9_ycAYD6SRhaxy-4BnvwA" target="_blank" rel="noopener">图解Go的channel底层原理</a><br>Go 1.12 runtime/chan.go<br><a href="https://www.youtube.com/watch?v=KBZlN0izeiY" target="_blank" rel="noopener">GopherCon 2017: Kavya Joshi - Understanding Channels</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/10/unit-test-in-go/"><span>Go 单元测试</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/10/unit-test-in-go/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-10T02:11:19.000Z">
          2019-06-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Go单元测试"><a href="#Go单元测试" class="headerlink" title="Go单元测试"></a>Go单元测试</h1><p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。<br>我们为何要进行单元测试呢？其实如果你不添加单元测试的话，别人调用你提供的函数是，其实就是帮你做测试，但是这种测试我们越早做越能发现问题.</p>
<h3 id="单元测试的粒度"><a href="#单元测试的粒度" class="headerlink" title="单元测试的粒度"></a>单元测试的粒度</h3><p>程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。在 Go 中程序单元指的是<code>Package</code>中的方法。<br>那么我们对于 Go 中改对那些函数写单元测试呢？这里的答案是: 包中可导出的函数。 因为这些函数是对外可见的，这些是我们包的入口。那么对于不可导出的函数我们是否需要些单元测试呢？答案是不用。有些人可能会有一位，如果我们不对不可导出的函数写单元测试，那么如何保证单元测试的覆盖率呢？因为有些不可导出函数的覆盖率达不到要求。这里要说的是: 如果有些不可导出函数单元测试覆盖率达不到，有两点可能性:</p>
<ul>
<li>这些逻辑是不需要的，你可以直接去掉</li>
<li>你的测试用例不够，你需要增加可导出函数的测试用例</li>
</ul>
<h3 id="单测的三个原则"><a href="#单测的三个原则" class="headerlink" title="单测的三个原则"></a>单测的三个原则</h3><p>还有一个问题是: 我该先开发功能在写单元测试，还是先写单元测试再开发功能？<br>其实关于TDD有三个定律:</p>
<ol>
<li>You are not allowed to write any production code unless it is to make a failing unit test pass.</li>
<li>You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.</li>
<li>You are not allowed to write any more production code than is sufficient to pass the one failing unit test.</li>
</ol>
<p>关于这三条定律，我发现每个人翻译的都不一样，我觉得比较符合我的理解的翻译是:</p>
<ol>
<li>除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</li>
<li>在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</li>
<li>只允许编写刚好能够使一个失败的 unit test 通过的产品代码</li>
</ol>
<p>如果违反了会怎么样呢？<br>违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p>
<p>还是针对上面的问题: 先写单元测试还是先写功能？<br>我的答案是: <strong>单元测试-&gt; 功能开发 -&gt; 单元测试 -&gt; 功能开发…</strong><br>它们应该是交替进行的，既: 先写小范围的单元测试，然后针对这些测试进行开发功能，等所有测试通过后继续增加测试<code>case</code>, 然后针对新增的<code>case</code>继续编写功能，直到功能满足了需求为止。</p>
<h3 id="测试行为-而非实现"><a href="#测试行为-而非实现" class="headerlink" title="测试行为, 而非实现"></a>测试行为, 而非实现</h3><p>Avoid Testing Implementation Details, Test Behaviours<br>当我们测试行为时，我们的意思是 : “我不在乎你是如何得出答案的，只要确保在这种情况下答案是正确的”<br>当我们测试实现时，我们的意思是 : “我不在乎答案是什么，只要确保它是按照你规定的方式工作的。”</p>
<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="单元测试编写"><a href="#单元测试编写" class="headerlink" title="单元测试编写"></a>单元测试编写</h3><p>下面给出一个完整的<code>Go</code>的单元测试的例子:<br><code>split.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">    i := strings.Index(s, sep)</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">        s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">        i = strings.Index(s, sep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>split_test.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        got := Split(<span class="string">"a/b/c"</span>, <span class="string">"/"</span>)</span><br><span class="line">        want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, want, got)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Go</code>官方网站有关于单元测试的<a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">写法介绍</a>, 以上面的代码为例:</p>
<ol>
<li><p>一般我们需要单元测试文件和要测试的包的文件需要在同一个目录下，并且以<code>_test.go</code>结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/split/</span><br><span class="line">├── split.go</span><br><span class="line">└── split_test.go</span><br></pre></td></tr></table></figure>
</li>
<li><p>单元测试的函数名为<code>Test</code> + 要测试的函数名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要测试的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">// 单元测试函数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TestSplit</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单元测试函数的参数是固定的 (<a href="https://golang.org/pkg/testing/#T" target="_blank" rel="noopener">*testing.T</a>):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p><code>Go</code>语言的工具链中提供了很强大的<a href="https://golang.org/cmd/go/#hdr-Test_packages" target="_blank" rel="noopener">单元测试工具</a>:<code>go test</code>, 如果想要运行刚才的单元测试，我们只需要在<code>split</code>文件夹下执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure></p>
<p>就可以得出测试结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">PASS</span><br><span class="line">ok      split   0.008s</span><br></pre></td></tr></table></figure></p>
<h3 id="运行多个单元测试"><a href="#运行多个单元测试" class="headerlink" title="运行多个单元测试"></a>运行多个单元测试</h3><p>有是有我们需要同时运行多个单元测试, 如果这些单元测试在同一个包下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/xml/</span><br><span class="line">├── atom_test.go</span><br><span class="line">├── example_marshaling_test.go</span><br><span class="line">├── example_test.go</span><br><span class="line">├── example_text_marshaling_test.go</span><br><span class="line">├── marshal.go</span><br><span class="line">├── marshal_test.go</span><br><span class="line">├── read.go</span><br><span class="line">├── read_test.go</span><br><span class="line">├── typeinfo.go</span><br><span class="line">├── xml.go</span><br><span class="line">└── xml_test.go</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接运行: <code>go test</code><br>如果这些单元测试文件不在同一个包下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/</span><br><span class="line">├── ascii85</span><br><span class="line">│   ├── ascii85.go</span><br><span class="line">│   └── ascii85_test.go</span><br><span class="line">├── asn1</span><br><span class="line">│   ├── asn1.go</span><br><span class="line">│   ├── asn1_test.go</span><br><span class="line">│   ├── common.go</span><br><span class="line">│   ├── marshal.go</span><br><span class="line">│   └── marshal_test.go</span><br><span class="line">├── base32</span><br><span class="line">│   ├── base32.go</span><br><span class="line">│   ├── base32_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">├── base64</span><br><span class="line">│   ├── base64.go</span><br><span class="line">│   ├── base64_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们需要在这些包的外面运行: <code>go test ./...</code></p>
<h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>如果我们想要查看单元测试的覆盖率，<code>Go</code> 工具链也是支持的, 详情可以参考官方的Blog: <a href="https://blog.golang.org/cover" target="_blank" rel="noopener">The cover story</a><br>如果要查看单元测试覆盖率，我们可以运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      split   0.013s</span><br></pre></td></tr></table></figure></p>
<p>但是上面的测试只给出了覆盖率的值，并没有看到详细的信息，如果我们需要查看覆盖率的详细信息，可以把测试覆盖率的内容输出到文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go test -coverprofile=coverage.out</span><br></pre></td></tr></table></figure></p>
<p>这样，测试覆盖率的详细信息就输出到了文件<code>coverage.out</code>中。<br>如过要查看每个函数的测试覆盖率，可以利用刚才的<code>coverage.out</code>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -func=coverage.out</span><br><span class="line">split/split.go:7:       Split           100.0%</span><br><span class="line">total:                  (statements)    100.0%</span><br></pre></td></tr></table></figure></p>
<p>如果要想可视化测试覆盖率，还可以生成<code>html</code>格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -html=coverage.out</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到每行的覆盖情况:<br><img src="https://blog.golang.org/cover/set.png" alt="覆盖率"><br>其中红色代表没有覆盖到，绿色代表覆盖到，灰色代表不计入测试覆盖率的范围</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="多个case"><a href="#多个case" class="headerlink" title="多个case"></a>多个case</h3><p>前面我们讲了如何进行基本的单元测试，但是现实中往往我们需要对同一个函数进行多个<code>case</code>的测试，那么其实有两种写法:</p>
<h4 id="针对每个case写一个测试函数"><a href="#针对每个case写一个测试函数" class="headerlink" title="针对每个case写一个测试函数:"></a><strong>针对每个<code>case</code>写一个测试函数:</strong></h4><p>对于比较复杂的函数，其函数的表现可能会收到不同环境因素的影响，他们的单元测试写法差别也比较大，比如<code>beego</code>中 <a href="https://github.com/astaxie/beego/blob/develop/logs/file_test.go" target="_blank" rel="noopener">logs/file</a> 的单元测试, 同样是测试<code>FileDailyRotate</code>函数，<code>TestFileDailyRotate_01</code>测试的是创建文件, <code>TestFileDailyRotate_02</code>测试的是当创建的文件存在时，给文件加后缀。</p>
<h4 id="同一个测试函数里有多个case"><a href="#同一个测试函数里有多个case" class="headerlink" title="同一个测试函数里有多个case:"></a><strong>同一个测试函数里有多个<code>case</code>:</strong></h4><p>一般比较简单的单元测试，只是根据输入的不同而产生不同的输出，则可以使用这种方式。比如前面说的<code>split</code>函数的多个<code>case</code>测试, 我们把<code>split_test.go</code>改为下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep   <span class="keyword">string</span></span><br><span class="line">        want  []<span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tests := []test&#123;</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := Split(tc.input, tc.sep)</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">            t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边界条件测试"><a href="#边界条件测试" class="headerlink" title="边界条件测试"></a>边界条件测试</h3><p>由长期的测试工作经验得知，大量的错误是发生在输入或输出的边界上。因此针对各种边界情况设计测试用例，可以查出更多的错误。上面的<code>case</code>中我们并没有对边界条件进行测试，下面我们加上一个边界条件的测试<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们的单元测试有一个<code>case</code>没有通过，但是这里有一点疑问:<strong>哪个测试<code>case</code>没过?</strong></p>
<h3 id="定位测试case"><a href="#定位测试case" class="headerlink" title="定位测试case"></a>定位测试case</h3><h4 id="通过编号定位"><a href="#通过编号定位" class="headerlink" title="通过编号定位"></a>通过编号定位</h4><p>我们可以给每个case一个编号:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"test %d: expected: %v , got %v"</span>, i+<span class="number">1</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: test 2: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.016s</span><br></pre></td></tr></table></figure>
<p>这里可以定位出 <code>test 2</code> 有问题的，但是编号的问题是 : </p>
<ul>
<li>每个人定义的开始下标可能不同: 有的人是从<code>0</code>开始，有的人从<code>1</code>开始，照成理解不一致</li>
<li>随着case的增多，同样不好定位具体的<code>case</code>: 如果你要从<code>50</code>个<code>case</code>中定位第<code>27</code>个<code>case</code>, 还是比较费时的。</li>
</ul>
<h4 id="通过名字定位"><a href="#通过名字定位" class="headerlink" title="通过名字定位"></a>通过名字定位</h4><p>还有一种方式: 我们给每个<code>case</code>一个名字:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                name  <span class="keyword">string</span></span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;name: <span class="string">"simple"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"trailing sep"</span>, input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"wrong sep"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"no sep"</span>, input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, tc.name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:26: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure>
<p>现在我们可以看到我们可以很好的通过<code>trailing sep</code>快速定位到了具体的<code>case</code></p>
<h3 id="随机测试case"><a href="#随机测试case" class="headerlink" title="随机测试case"></a>随机测试case</h3><p>上面的测试方式看上去很完美了，可以如果我们实现的时候没有注意，<code>case</code>之间可能会相互影响, 比如一个<code>case</code>在函数内部修改了一个全局变量，下一个<code>case</code>的执行就会受到这种影响。为了避免由于测试顺序带来的问题，我们一般都会让每个<code>case</code>之间的顺序是随机的，而不是按照特定的顺序，而<code>slice</code>本身有顺序的，所以不满足我们的条件，这时我们可以使用<code>map</code>, 同时还可以把<code>name</code>放到<code>map</code>的<code>key</code>中，简化我们的写法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:23: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.014s</span><br></pre></td></tr></table></figure></p>
<h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><p>看上去前面的测试更加完美了， <strong>但是……</strong><br>我们的测试<code>case</code>出现错误的时候，我们会调用:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br></pre></td></tr></table></figure></p>
<p>打印我们的错误信息，但是这个错误信息打印后整个测试过程就结束了，如果我们有很多个<code>case</code>需要测试，而前面的<code>case</code>失败后就无法进行后面的测试了，这时候我们如果针对这个出错的<code>case</code>修改后，我们会发现其他的<code>case</code>有报错了，我们反复的修改，但是我们并不知道自己到底有多少个<code>case</code>是有问题的，我们无法一次性把问题修复好，照成我们工作量变大，并且效率变低，那么我们该如何改进这个情况呢?<br>我们知道问题出在<code>t.Fatalf</code>，那么我们可不可以即打印出错误信息又不让程序中断呢？答案是: 可以！ 我们使用<code>f.Errorf</code>替换<code>f.Fatalf</code><br><strong>可是…..</strong><br>如果某个<code>case</code>出现了<code>panic</code>同样会导致整个程序中断，所以这种方式治标不治本。那么我们该如何改进呢? Go 1.7 开始支持了 <a href="https://golang.org/doc/go1.7#testing" target="_blank" rel="noopener">sub test</a>。 下面我们就按照<code>Sub Test</code>的写法进行修改:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        got := Split(tc.input, tc.sep)</span><br><span class="line">                        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>t.Run</code>的源码我们看到:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span> tRunner(t, f)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实会诊对每个<code>case</code>启动一个<code>goroutine</code>， 所以其中一个出现了<code>panic</code>不会影响其他的<code>case</code>执行。</p>
<p>上面这种形态就是目前我们进行单元测试的<strong>最佳实践</strong>了。</p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><h4 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h4><p>外部依赖是指我们的函数需要调用其他的函数，外部依赖有可能涉及到一些数据依赖，网络依赖等。关于单元测试中如何解决外部依赖的问题, 常用的方法是: <strong>Test Double(测试替身)</strong>, 而它也分很多种:</p>
<ul>
<li><strong>Dummy</strong> objects are passed around but never actually used. Usually they are just used to fill parameter lists.</li>
<li><strong>Fake</strong> objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).</li>
<li><strong>Stubs</strong> provide canned answers to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test.</li>
<li><strong>Spies</strong> are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.</li>
<li><strong>Mocks</strong> are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.</li>
</ul>
<p>看上去有点儿头大，分这么多类型而且他们的接线感觉也比较模糊，为了便于理解我们不对这些概念做过多的解读，我们后面把所有我们的工作都看做是<code>Mock</code></p>
<h4 id="编写可测试代码"><a href="#编写可测试代码" class="headerlink" title="编写可测试代码"></a>编写可测试代码</h4><h5 id="函数要短小"><a href="#函数要短小" class="headerlink" title="函数要短小"></a>函数要短小</h5><p><em>函数的第一规则是要短小。第二条规则是还要短小</em> ———— 《代码整洁之道》<br>至于如何才算短小，一般建议是不超过100行，也就是显示器一屏所显示的行数。<br>函数越短小那么单元测试的编写就越简单。</p>
<h5 id="函数功能要单一"><a href="#函数功能要单一" class="headerlink" title="函数功能要单一"></a>函数功能要单一</h5><p><em>函数应该做一件事。做好这件事。只做一件事。</em> ————–《代码整洁之道》<br>一个函数做的事情越少其逻辑越简单，难么对应的单元测试也就越简单。</p>
<h5 id="减少外部依赖"><a href="#减少外部依赖" class="headerlink" title="减少外部依赖"></a>减少外部依赖</h5><p>这里要明确的是我们要测试的是自己的函数而不是调用的函数，所以我们应该把中重点放到自己的函数上，至于外部依赖的函数越少越好，因为每个外部依赖都增加了我们单元测试的不确定性。</p>
<h5 id="依赖模块要方便-Mock"><a href="#依赖模块要方便-Mock" class="headerlink" title="依赖模块要方便 Mock"></a>依赖模块要方便 Mock</h5><p>为了专注我们自己模块的测试，对于外部的模块我们一般都会使用<code>Mock</code>的方法, 所以依赖模块如果好<code>Mock</code>的话测试起来就会方便很多，反之会很麻烦。</p>
<h5 id="方便依赖注入"><a href="#方便依赖注入" class="headerlink" title="方便依赖注入"></a>方便依赖注入</h5><p>一般我们<code>Mock</code>是通过依赖注入的方式，这种方式可以方便的更改依赖的对象的实现，而依赖注入的方式有好几种:</p>
<ul>
<li>通过变量赋值</li>
<li>通过参数传递</li>
<li>通过Set/Get方法</li>
</ul>
<h3 id="一个外部依赖的例子"><a href="#一个外部依赖的例子" class="headerlink" title="一个外部依赖的例子"></a>一个外部依赖的例子</h3><p>一个<code>User</code>包, 有一个通过<code>uid</code>获取分数<code>score</code>的方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">                Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">                Password: <span class="string">""</span>,</span><br><span class="line">                DB:       <span class="number">0</span>,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        _, err := client.Ping().Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">        <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个<code>Class</code>包，通过调用<code>user.Score</code>方法获取分数，根据分数给这个用户一个等级:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们要给<code>UserLevel</code>写单元测试，该怎么写呢？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">5</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestUserLevel (0.02s)</span><br><span class="line">    --- FAIL: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">        class_test.go:24: expected: N, got E</span><br><span class="line">    --- FAIL: TestUserLevel/C_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: C, got E</span><br><span class="line">    --- FAIL: TestUserLevel/B_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: B, got E</span><br><span class="line">    --- FAIL: TestUserLevel/A_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: A, got E</span><br><span class="line">    --- FAIL: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">        class_test.go:24: expected: W, got E</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    class   0.023s</span><br></pre></td></tr></table></figure></p>
<p>可以看到除了<code>Got Error</code>运行成功，其他的都失败了，因为我们本地并没有开启<code>redis</code>服务，所以是连不上的。如果我们要让这个测试用例通过，显然我们不能真的开启一个<code>redis</code>的服务，我们需要对<code>user.Score</code>进行<code>Mock</code></p>
<h4 id="Mock框架"><a href="#Mock框架" class="headerlink" title="Mock框架"></a>Mock框架</h4><p>go中<code>mock</code>的支持也有很多种:</p>
<ul>
<li><a href="https://github.com/golang/mock" target="_blank" rel="noopener">github.com/golang/mock</a></li>
<li><a href="https://github.com/bouk/monkey" target="_blank" rel="noopener">github.com/bouk/monkey</a></li>
<li><a href="https://github.com/smartystreets/goconvey" target="_blank" rel="noopener">github.com/smartystreets/goconvey</a></li>
<li><a href="https://github.com/stretchr/testify" target="_blank" rel="noopener">github.com/stretchr/testify</a></li>
<li><a href="https://github.com/prashantv/gostub" target="_blank" rel="noopener">github.com/prashantv/gostub</a></li>
</ul>
<p>每个框架都有自己的用法， 这里我那<code>github.com/bouk/monkey</code>来举例子, 改造一下我们的单元测试:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"bou.ke/monkey"</span></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        monkey.Patch(user.Score, mockScore)</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mockScore</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.014s</span><br></pre></td></tr></table></figure></p>
<h4 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h4><p>前面通过<code>Mock</code>框架我们可以在测试的时候替换原来的实现，这样就可以很方便的进行单元测试了,但是这种代码的实现方式其实并不符合面相对象设计的原则, 下面提出两个问题:</p>
<ol>
<li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?</li>
<li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？</li>
</ol>
<p>可见上面的方式不太灵活，面对复杂多变的需求无法很好的满足。这时就要求我们改用面相接口编程, 下面是我们使用面相接口编程的方式改进了上面的实现:<br><code>user</code>包增加了一个<code>User</code>接口，这个接口有一个函数<code>Score</code>, 然后定义了一个<code>defaultUser</code>, 并且实现了<code>Score</code>函数，最后定一个<code>New</code>函数向外输出这个<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class</code>包调用由原来的通过包直接调用改为了增加一个<code>u</code>变量, 然后调用<code>u.Score</code>来获取信息:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    score, err := u.Score(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class_test</code>不再依赖<code>mock</code>框架，而是实现了自己的<code>User</code>接口<code>mockUser</code>，替换了<code>user</code>包的<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u = mockUser&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.005s</span><br></pre></td></tr></table></figure></p>
<p>下面再来看上面提出的两个问题:</p>
<ol>
<li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?<br>答: 根据上面的实现可以看到，我们没有借助任何框架同样完成了<code>Mock</code>的效果</li>
<li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？<br>答: 由于面相接口编程，我们可以在user中增加一个实例实现从<code>mysql</code>获取数据的方法，调用者可以根据需求选择不同的实例，而且如果调用者对这个数据来源有自己的需求，甚至可以自己实现这个接口。</li>
</ol>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>上面的实现我们可以看到每次调用<code>var u =  user.New()</code>都会新建一个<code>defaultUser</code>对象，对于有些需要共享<code>defaultUser</code>状态的情况下，例如<code>defaultUser</code>中有一个常驻内存共享的数据, 我们在多个包调用的时候其实那得是不同的对象，为了共享这个数据我们把<code>user.New</code>改成下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样每次返回的其实都是同一个<code>defaultUser</code>。</p>
<h4 id="更方便的调用"><a href="#更方便的调用" class="headerlink" title="更方便的调用"></a>更方便的调用</h4><p>上面我们看出，修改为面相接口编程后我们需要通过依赖注入传递对象，但是这样会对调用者照成麻烦，我们是否可以在优化一下呢?<br>我们在<code>user</code>中增加一个函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以通过<code>user.Score</code>调用<code>du.Score</code>函数了，所以<code>class.go</code>的实现可以改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上去不错，但是我们如何进行依赖注入呢？不然单元测试使用的是默认实现，我们没办法做单元测试了。前面其实我们提过依赖注入的方式有一个<code>Get/Set</code>方式，我们可以再修改一下<code>user</code>包:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> definedUser != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> definedUser.Score(uid)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> definedUser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">    definedUser = u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class</code>不用修改，<code>class_test</code>修改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">int</span></span><br><span class="line">        want  <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">        <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">        <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">        <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">        <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">        <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user.SetUser(mockUser&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := UserLevel(tc.input)</span><br><span class="line">        t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> uid &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过<code>user.SetUser</code>方法用自己的实现替换了之前默认的实现，这样我们就可以方便的进行单元测试了。<br>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.011s</span><br></pre></td></tr></table></figure></p>
<p>在大多数情况下，我们都是使用的默认实现，只有在我们必须要修改依赖的实现，或者单元测试时才会使用其他的实现，所以为了大多数的场景下调用简单，我们应该尽量使用这种方式来实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要回顾了一下关于单元测试的一些理论知识: </p>
<ul>
<li>测试的粒度应该是测试包中的可导出函数</li>
<li>测试的原则告诉我们应该是变测试变开发, 相互交替进行</li>
<li>测试的目的应该是测试行为，而不是测试具体的实现</li>
</ul>
<p>关于Go的单元测试可以分为三个阶段:</p>
<ul>
<li>初级阶段: 主要是认识Go的单元测试基本写法，以及如何利用Go的工具链运行单元测试及查看单元测试覆盖率的情况</li>
<li>进阶阶段: 主要是举一个单元测试的例子，通过不断改进这个单元测试的写法来告诉我们如何写出更好的单元测试</li>
<li>高级阶段: 介绍了如何写出可测试的函数，面对复杂的调用和多变得需求如何利用面相接口编程和依赖注入改进我们的程序的写法</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf" target="_blank" rel="noopener">Test-Driven Development By Example</a><br><a href="https://github.com/gopherchina/conference/blob/master/2019/1.4%20Testing%3B%20how%2C%20what%2C%20why%20-%20Dave%20.pdf" target="_blank" rel="noopener">Testing; how, what, why - Dave</a><br><a href="https://www.youtube.com/watch?v=EZ05e7EMOLM" target="_blank" rel="noopener">TDD, Where Did It All Go Wrong - Lan Cooper</a><br><a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" target="_blank" rel="noopener">The Three Laws of TDD.</a><br><a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">深度解读 - TDD（测试驱动开发）</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">单元测试wiki</a><br><a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">How to Write Go Code - Testing</a><br><a href="https://teamgaslight.com/blog/testing-behavior-vs-testing-implementation" target="_blank" rel="noopener">Testing Behavior vs. Testing Implementation</a><br><a href="http://codebetter.com/iancooper/2011/10/06/avoid-testing-implementation-details-test-behaviours/" target="_blank" rel="noopener">Avoid Testing Implementation Details, Test Behaviours</a><br><a href="https://baike.baidu.com/item/%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">边界条件测试</a><br><a href="https://item.jd.com/10064006.html" target="_blank" rel="noopener">代码整洁之道</a><br><a href="https://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">Mocks Aren’t Stubs</a><br><a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">TestDouble</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/06/Dependency-inversion-principle-in-Go/"><span>Dependency inversion principle in Go</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/06/Dependency-inversion-principle-in-Go/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-06T06:54:25.000Z">
          2019-06-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="依赖反转原则在Go中使用"><a href="#依赖反转原则在Go中使用" class="headerlink" title="依赖反转原则在Go中使用"></a>依赖反转原则在Go中使用</h1><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a>有五个，分别是:</p>
<table>
<thead>
<tr>
<th>首字母</th>
<th>指代</th>
<th>概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>单一功能原则</td>
<td>认为对象应该仅具有一种单一功能的概念。</td>
</tr>
<tr>
<td>O</td>
<td>开闭原则</td>
<td>认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>
</tr>
<tr>
<td>L</td>
<td>里氏替换原则</td>
<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。  参考契约式设计。</td>
</tr>
<tr>
<td>I</td>
<td>接口隔离原则</td>
<td>认为“多个特定客户端接口要好于一个宽泛用途的接口” 的概念。</td>
</tr>
<tr>
<td>D</td>
<td>依赖反转原则</td>
<td>认为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。 依赖注入是该原则的一种实现方式。</td>
</tr>
</tbody>
</table>
<p>这五个原则简称: <code>SOLID</code>。<br>在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。<br>该原则规定：</p>
<ul>
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li>
</ul>
<p>该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。</p>
<p>在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。这种对于低层次组件的依赖限制了高层次组件被重用的可行性。</p>
<p>依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和低层组件划分到不同的包/库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。众多的设计模式，比如插件，服务定位器或者依赖反转，则被用来在运行时把指定的低层组件实现提供给高层组件。</p>
<p>应用依赖反转原则同样被认为是应用了<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">适配器模式</a>，例如：高层的类定义了它自己的适配器接口（高层类所依赖的抽象接口）。被适配的对象同样依赖于适配器接口的抽象（这是当然的，因为它实现了这个接口），同时它的实现则可以使用它自身所在低层模块的代码。通过这种方式，高层组件则不依赖于低层组件，因为它（高层组件）仅间接的通过调用适配器接口多态方法使用了低层组件，而这些多态方法则是由被适配对象以及它的低层模块所实现的。</p>
<blockquote>
<p><strong>前面一大堆其实都是从wiki上copy过来的，自己的理解有以下几点:</strong></p>
<ul>
<li>上层指<strong>调用者</strong>, 下层指<strong>被调用者</strong></li>
<li>原来的编程方式是上层调用下层的时候依赖下层具体的实现方式</li>
<li>依赖反转（或叫:依赖倒置)是指下层的实现依赖上层调用的需求</li>
<li>最终的解决方式是: 把上层的需求抽象成接口，上层依赖接口的抽象进行调用，下层依赖接口的抽象进行实现(下面要介绍的<strong>面相接口编程</strong>)</li>
</ul>
</blockquote>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a>是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</p>
<blockquote>
<p><strong>上面这段也是wiki上的, 自己理解:</strong></p>
<ul>
<li>依赖注入就是: 把下层依赖注入(或叫传递)到上层调用</li>
<li>要把提供服务的一方(也就是前面说的: 下层)作为实例传递给客户端(即:上层)</li>
<li>不要客户端在内部自己实现服务端的实例化。</li>
<li>这种方式的好处是: 可以通过传递不同的实例化对象来实现多态。</li>
</ul>
</blockquote>
<h3 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a>是前面实现依赖反转原则的具体方式。<br>基于接口的编程将应用程序定义为组件的集合，其中组件间的应用程序接口（API）调用可能只通过抽象化接口完成，而没有具体的类。类的实例化一般通过使用如<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener">工厂模式</a>等技术的其他接口完成。</p>
<blockquote>
<p><strong>这里也说一点自己的理解:</strong><br>上面说到要通过依赖注入方式传递实例，这个实例如何生成呢？如果每次都生成一个，如果这个实例是有状态的，那么每个拿到的可能都是不一样的，这样就<strong>无法共享</strong>。所以一般都是通过工厂模式产生一个实例，其他调用方要共享的话都通过这个工厂拿到<strong>同一个实例</strong>。</p>
</blockquote>
<p>另一种定义描述: 在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类</p>
<h4 id="面向接口编程和面向对象编程是什么关系"><a href="#面向接口编程和面向对象编程是什么关系" class="headerlink" title="面向接口编程和面向对象编程是什么关系:"></a>面向接口编程和面向对象编程是什么关系:</h4><p>首先，面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。</p>
<h4 id="接口的本质"><a href="#接口的本质" class="headerlink" title="接口的本质"></a>接口的本质</h4><h5 id="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"><a href="#接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念" class="headerlink" title="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"></a>接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念</h5><p>例如，在自然界中，人都能吃饭，即“如果你是人，则必须能吃饭”。那么模拟到计算机程序中，就应该有一个Person接口，并有一个方法叫Eat()，然后我们规定，每一个表示“人”的类，必须实现Person接口，这就模拟了自然界“如果你是人，则必须能吃饭”这条规则。</p>
<p>从这里，我想各位也能看到些许面向对象思想的东西。面向对象思想的核心之一，就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。</p>
<h5 id="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"><a href="#接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同" class="headerlink" title="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"></a>接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同</h5><p>例如，在我的眼里，我是一个人，和一头猪有本质区别，我可以接受我和我同学是同类这个说法，但绝不能接受我和一头猪是同类。但是，如果在一个动物学家眼里，我和猪应该是同类，因为我们都是动物，他可以认为“人”和“猪”都实现了Animal这个接口，而他在研究动物行为时，不会把我和猪分开对待，而会从“动物”这个较大的粒度上研究，但他会认为我和一棵树有本质区别。</p>
<h4 id="面相接口编程的优点"><a href="#面相接口编程的优点" class="headerlink" title="面相接口编程的优点"></a>面相接口编程的优点</h4><ul>
<li>首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。</li>
<li>使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工。</li>
</ul>
<blockquote>
<p><strong>关于面相接口编程的归纳:</strong></p>
<ul>
<li>面相接口是面向对象编程的重要部分</li>
<li>接口本质上是一组规则的集合，是一定粒度上有相同特指的对象的的抽象</li>
<li>面相接口编程可以提高编程的灵活性, 可以并行开发。</li>
</ul>
</blockquote>
<h2 id="Go-中的应用"><a href="#Go-中的应用" class="headerlink" title="Go 中的应用"></a>Go 中的应用</h2><h3 id="Go-中的接口"><a href="#Go-中的接口" class="headerlink" title="Go 中的接口"></a>Go 中的接口</h3><p>Go语言中，接口(interface)有其特殊的地方, 其他的语言一般要实现一个接口都需要显示的说明<br>例如<code>PHP</code>(这里没有贬低PHP的意思，大多数语言也是这种实现方式例如<code>C++</code>, <code>Python</code>, <code>Rust</code>等):<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare the interface 'iTemplate'</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the interface</span></span><br><span class="line"><span class="comment">// This will work</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span> <span class="keyword">implements</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $vars = <span class="keyword">array</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vars[$name] = $var;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;vars <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">            $template = str_replace(<span class="string">'&#123;'</span> . $name . <span class="string">'&#125;'</span>, $value, $template);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> $template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用到关键字 <code>implements</code>。<br>todo: 对比优缺点</p>
<p>而<code>Go</code>语言中，<code>interface</code>是<code>duck typing</code>(鸭子类型: If it looks like a duck, and it quacks like a duck, then it is a duck), 也就是如果一个对象实现了某个接口的方法，那么这个对象就是这个接口类型了，不需要显示说明是否实现了某个接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Speaker types can say things.</span></span><br><span class="line"><span class="keyword">type</span> Speaker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Say(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person is a strut with filed name</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Say funciton is defined by Speaker and implement by Person</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Say</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  log.Println(p.name+<span class="string">":"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>Person</code>实现了函数<code>Say</code>, 所以<code>Person</code>就是<code>Speaker</code>类型了。</p>
<h3 id="Go-中面相接口编程"><a href="#Go-中面相接口编程" class="headerlink" title="Go 中面相接口编程"></a>Go 中面相接口编程</h3><p>这种编程方式不仅是在 Go 语言中是被推荐的，在几乎所有的编程语言中，我们都会推荐这种编程的方式，它为我们的程序提供了非常强的灵活性，想要构建一个稳定、健壮的 Go 语言项目，不使用接口是完全无法做到的。</p>
<p>如果一个略有规模的项目中没有出现任何 type … interface 的定义，那么作者可以推测出这在很大的概率上是一个工程质量堪忧并且没有多少单元测试覆盖的项目，我们确实需要认真考虑一下如何使用接口对项目进行重构。</p>
<p>事实上官方库也都是按照这个思想来实现的，比如<code>net/http</code>包(对这个包的分析参考 <a href="/2017/07/01/how-golang-webserver-work/">golang 的 webserver 是如何工作的</a>)。当我们要启动一个http server时一般代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个函数的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个参数是<code>Handler</code>类型, 这个函数的类型定义如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义的正是一个接口。这个接口只有一个函数<code>ServeHTTP</code>， 而最终对请求处理调用的也正是这个函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于第二个函数我们一般都会传<code>nil</code>, 所以会执行上面的逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler = DefaultServeMux</span><br></pre></td></tr></table></figure>
<p>而<code>DefaultServeMux</code>就是官方的默认实现。而我们也可以通过传递这个参数来实现自己的处理, 很多Web框架就是怎么做的，比如<code>gin</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    c := engine.pool.Get().(*Context)</span><br><span class="line">    c.writermem.reset(w)</span><br><span class="line">    c.Request = req</span><br><span class="line">    c.reset()</span><br><span class="line"></span><br><span class="line">    engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">    engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gin</code>自己实现了连接的处理方式，并且把这个实现作为参数传给<code>net/http</code>, 具体代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Run</span><span class="params">(addr ...<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; debugPrintError(err) &#125;()</span><br><span class="line"></span><br><span class="line">    address := resolveAddress(addr)</span><br><span class="line">    debugPrint(<span class="string">"Listening and serving HTTP on %s\n"</span>, address)</span><br><span class="line">    err = http.ListenAndServe(address, engine)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现正是前面说讲的: <strong>依赖接口编程</strong>，然后通过<strong>依赖注入</strong>把实例传入</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们有一个<code>user</code>包，里面是处理用户相关的信息, 还有一个<code>bank</code>包，<code>bank</code>会调用<code>user</code>的方法来获取一些用户信息, 刚开始他们的代码实现分别如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">    rows, err := db.Query(sql, uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    name, err := user.UserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在如果我们要给<code>bank</code>的<code>UserInfo</code>添加单元测试应该怎么做呢? 这里有以下几点问题:</p>
<ul>
<li>我们要测试的是<code>bank</code>的<code>UserInfo</code>函数，而不是为了测试这个函数都调用的函数，所以我们其实不太关心<code>user.UserName</code>里面的逻辑</li>
<li>我们要测试<code>UserInfo</code>就必须要从<code>UserName</code>获取一些信息，但是<code>UserName</code>的信息需要调用<code>db</code>才能获取，这里涉及到一些网络访问，会给我们的测试带来很多麻烦</li>
<li>我们需要把<code>UserName</code>给Mock掉<br>关于如何把<code>UserName</code> Mock掉, 其实我们可以借助一些<code>mock</code>的框架(比如<code>bou.ke/monkey</code>)来进行处理， 但是这种方法回避了设计上的一些问题，过度依赖会导致我们的代码质量堪忧，还有一些场景要求我们必须替换这个方法的实现，比如我们不想使用<code>user.UserName</code>的查询方式了，我们换了一种实现，这样我们就无法复用原来的代码了。<br>下面我们介绍如何利用上面介绍的知识来解决这个问题:</li>
</ul>
<h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>我们看一下第二版的代码<br><code>user</code>包:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">        UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DefaultUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">        rows, err := db.Query(sql, uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">                <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bank</code>代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    name, err := u.UserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们都做了那些修改呢?</p>
<ul>
<li>面向接口编程<br>我们定义了一个接口类型<code>User</code>:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">        UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后<code>user</code>包用<code>DefaultUser</code>来实现了这个方法，所以<code>DefaultUser</code>就是这个类型的包了<br><code>bank</code>中定义了一个变量<code>var u = user.New()</code>, 由于<code>user.New()</code>的类型也是<code>User</code>，所以<code>u</code>的类型就是<code>User</code>, 然后在<code>UserInfo</code>函数中调用<code>User</code>类型的<code>UserName</code>方法<br>也就是说<code>user</code>和<code>bank</code>都是面向<code>User</code>来进行编程的</p>
<ul>
<li>依赖注入<br>我们第一个版本是直接调用<code>user.UserName</code>函数, 但是我们无法自己去修改这个函数的实现，所以我们通过<code>var u = user.New()</code>来获取<code>user</code>给我传递的一个对象，这样我们就可以通过<code>u</code>来调用<code>UserName</code>函数了，这时<code>user.New</code>就实现了依赖注入，这样做我们就可以通过覆盖<code>u</code>这个实例，来完成自己的实现了，下面</li>
</ul>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>面对版本二, 我们怎么实现<code>bank.UserInfo</code>的单元测试呢？<br><code>bank_test.go</code>来看一下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u mockUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"John"</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserInfo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    u = mockUser&#123;&#125;</span><br><span class="line">    cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        uid  <span class="keyword">int</span></span><br><span class="line">        res  <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">"test1"</span>, <span class="number">1</span>, <span class="string">"something was wrong"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test2"</span>, <span class="number">2</span>, <span class="string">"not found this user"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test3"</span>, <span class="number">3</span>, <span class="string">"user name is John"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        t.Run(v.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            info := UserInfo(v.uid)</span><br><span class="line">            <span class="keyword">if</span> info != v.res &#123;</span><br><span class="line">                t.Errorf(<span class="string">"got %s; want %s"</span>, info, v.res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go test -v</span><br><span class="line">=== RUN   TestUserInfo</span><br><span class="line">=== RUN   TestUserInfo/test1</span><br><span class="line">=== RUN   TestUserInfo/test2</span><br><span class="line">=== RUN   TestUserInfo/test3</span><br><span class="line">--- PASS: TestUserInfo (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test1 (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test2 (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test3 (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      bank    0.013s</span><br></pre></td></tr></table></figure>
<p>首先我们定义了一个<code>mockUser</code>, 然后实现了<code>UserName</code>函数，所以这时<code>mockUser</code>已经是<code>User</code>类型了，然后我们在测试函数里通过<code>u = mockUser</code>替换掉了运来的<code>var u = user.New()</code>, 这时候在执行<code>UserInfo</code>调用的其实就是<code>mockUser.UserName</code>函数了，完美的完成了我们的单元测试。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>前面我们虽然用依赖注入的方式完成了调用，但是还有一个问题, 当我们依赖注入的时候用的是<code>var u = user.New()</code>的方式来获取的，但是在错综复杂的调用过程中，我们难免会多次调用<code>user.New()</code>函数，而且我们还要共享同一个<code>User</code>， 这时候就要求我们使用工厂模式保证不管多少次调用，返回的都是同一个<code>User</code>, 在上面的代码中其实很好改:<br>我们把<code>user</code>中的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改为下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultUser = DefaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们每次返回的都是<code>user</code>内部的<code>defaultUser</code>这个实例，而这个实例只初始化了一次, 所有通过这个方法获取的实例都是同一个实例</p>
<h4 id="简化调用"><a href="#简化调用" class="headerlink" title="简化调用"></a>简化调用</h4><p>有时候我们会觉得每次调用都通过依赖注入的传递一个对象，会使得调用变的复杂起来，比如本来我们调用的时候只需要<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.UserName()</span><br></pre></td></tr></table></figure></p>
<p>而现在可能我们的调用变成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var u = user.New()</span><br><span class="line">u.UserName()</span><br></pre></td></tr></table></figure></p>
<p>那么我们如何使用更符合<code>go</code>的方式，直接使用包调用而不是每次都传递一个对象呢？我们可以改为下面的方式:<br><code>user</code>的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultUser = DefaultUser&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> definedUser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultUser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">        definedUser = u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DefaultUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">        rows, err := db.Query(sql, uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">                <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> definedUser == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defaultUser.UserName(uid)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> definedUser.UserName(uid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们新增加了一个变量<code>definedUser</code>来表示用户自定义的实例，然后通过<code>SetUser</code>来对其进行复制，我们同时增加了一个包级别的<code>UserName</code>函数，里面的实现会判断如果有<code>definedUser</code>那么我们就是用这个自定义的实现，如果没有我们就调用默认的实现</p>
<p><code>bank</code>的实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        name, err := user.UserName(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bank</code>的实现跟第一个版本一样，如果我们不需要修改默认实现，对于调用来说非常方便，我们不用关系其内部的具体实现。</p>
<p><code>bank_test</code>的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u mockUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"John"</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserInfo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        user.SetUser(mockUser&#123;&#125;)</span><br><span class="line">        cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">                name <span class="keyword">string</span></span><br><span class="line">                uid  <span class="keyword">int</span></span><br><span class="line">                res  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                &#123;<span class="string">"test1"</span>, <span class="number">1</span>, <span class="string">"something was wrong"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"test2"</span>, <span class="number">2</span>, <span class="string">"not found this user"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"test3"</span>, <span class="number">3</span>, <span class="string">"user name is John"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> cases &#123;</span><br><span class="line">                t.Run(v.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        info := UserInfo(v.uid)</span><br><span class="line">                        <span class="keyword">if</span> info != v.res &#123;</span><br><span class="line">                                t.Errorf(<span class="string">"got %s; want %s"</span>, info, v.res)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bank_test</code>由于要对<code>UserName</code>进行Mock, 用自己的实现来替换原来的实现，我们只需要在测试的时候调用<code>SetUser</code>函数，就完成了替换。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a><br><a href="https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html" target="_blank" rel="noopener">面向接口编程详解（一）——思想基础</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://gocn.vip/article/1764" target="_blank" rel="noopener">使用Golang的interface接口设计原则</a><br><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d" target="_blank" rel="noopener">Duck typing in Go</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/05/28/go-scheduler-preemption/"><span>Go 调度器抢占方式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/05/28/go-scheduler-preemption/" rel="bookmark">
        <time class="entry-date published" datetime="2019-05-28T02:35:56.000Z">
          2019-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="OS-调度"><a href="#OS-调度" class="headerlink" title="OS 调度"></a>OS 调度</h2><h2 id="Go-调度"><a href="#Go-调度" class="headerlink" title="Go 调度"></a>Go 调度</h2><p>被抢占后把 g 状态从 <code>_Grunning</code> 改为 <code>_Grunnable</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">"bad g status"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">    dropg()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    globrunqput(gp)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Go-调度的问题"><a href="#Go-调度的问题" class="headerlink" title="Go 调度的问题"></a>Go 调度的问题</h2><h3 id="deadloop"><a href="#deadloop" class="headerlink" title="deadloop"></a>deadloop</h3><p>Go的抢占需要依赖函数的调用，只有在函数调用(准确的说是函数调用产生morestack调用的时候)的时候才会进行真正的强占，那么对于下面的这个方式:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个死循环，而且里面没有任何函数调用，也不会进行栈的扩张，所以这个goroutine永远不会被抢占。<br>参考<a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a> 这篇文档的说明，我们看一下具体的问题及解决方案。<br>// todo: 继续完善上篇文章中的例子</p>
<h3 id="deadloop-amp-GC"><a href="#deadloop-amp-GC" class="headerlink" title="deadloop &amp; GC"></a>deadloop &amp; GC</h3><p>还有这样一个<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">88</span> &#123;</span><br><span class="line">                runtime.GC()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// the wrong part</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">                sum += &lt;-ch</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序也会hang死。</p>
<p>下面这段代码在主goroutine中运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// the wrong part</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">            sum += &lt;-ch</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序由于没有函数的调用和<code>Goshced()</code>的主动调用所以会通过<code>阻塞监控</code>的方式被动弃权。</p>
<h4 id="runtime-GC"><a href="#runtime-GC" class="headerlink" title="runtime.GC"></a>runtime.GC</h4><p>当执行 <code>runtime.GC()</code>的时候都发生了什么？我们来看一下<br>通过<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">dlv</a>这个工具我们可以对这个程序进行断点调试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv debug go run gc.go</span><br></pre></td></tr></table></figure></p>
<p>函数会执行到 <code>stopTheWorldWithSema</code> 这个函数，这个函数主要作用是停止所有的P，然后进行垃圾回收，我们通过一步一步调试发现, 这个函数会下面这个循环中无法出来:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么会在这个地方无法出来？下面分析一下具体原因。</p>
<p>GC种一个步骤是要把所有的 p 都设置为<code>_Pgcstop</code> 状态后才能继续进行。 下面看看这个步骤是否能够完成。</p>
<p><code>stopTheWorldWithSema</code>函数更加详细的执行过程如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we hold a lock, then we won't be able to stop another M</span></span><br><span class="line">    <span class="comment">// that is blocked trying to acquire the lock.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"stopTheWorld: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.stopwait = gomaxprocs <span class="comment">// 设置stopwait的初始值为最大的 p 的个数</span></span><br><span class="line">    atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>) <span class="comment">// 设置 gcwaiting = 1, 表示正在进入GC状态</span></span><br><span class="line">    preemptall() <span class="comment">// 给所有的 p 发送抢占信号，如果成功，则对应的 p 进入 idle 状态</span></span><br><span class="line">    <span class="comment">// stop current P</span></span><br><span class="line">    _g_.m.p.ptr().status = _Pgcstop <span class="comment">// Pgcstop is only diagnostic.</span></span><br><span class="line">    sched.stopwait-- <span class="comment">// 给他当前的设置状态后，stopwait个数减一 </span></span><br><span class="line">    <span class="comment">// try to retake all P's in Psyscall status</span></span><br><span class="line">    <span class="comment">// 遍历所有的 p 如果满足条件(p的状态为 _Psyscall)则释放这个 p , 并且把 p 的状态都设置成 _Pgcstop ; 然后stopwait--</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := p.status</span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                traceGoSysBlock(p)</span><br><span class="line">                traceProcStop(p)</span><br><span class="line">            &#125;</span><br><span class="line">            p.syscalltick++</span><br><span class="line">            sched.stopwait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stop idle P's</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := pidleget() <span class="comment">//获取idle 状态的 p, 从 _Pidle list 获取</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        p.status = _Pgcstop <span class="comment">// 把 p 状态设置为 _Pgcstop</span></span><br><span class="line">        sched.stopwait-- <span class="comment">// 计数 stopwait --</span></span><br><span class="line">    &#125;</span><br><span class="line">    wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                noteclear(&amp;sched.stopnote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再次给所有的 p 发送 抢占信号</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面函数把所有非<code>_Prunning</code>状态的 p 都设置为了 <code>_Pgcstop</code> 状态，对于 <code>_Prunning</code> 状态的 p 如何设置其为 <code>_Pgcstop</code> 状态呢? 主要是通过 <code>preemptall()</code>函数给每个 p 发送抢占信号<br><code>preemptall()</code> 其实时调用了 <code>preemptone()</code> 前面我们已经讲了具体的原理。被抢占后 p 重新进入调度阶段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        stoplockedm()</span><br><span class="line">        execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不应该调度一个正在执行 cgo 调用的 g</span></span><br><span class="line">    <span class="comment">// 因为 cgo 在使用当前 m 的 g0 栈</span></span><br><span class="line">    <span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line">    <span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">        throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果还在等待 gc，则</span></span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top <span class="comment">// 循环执行</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面说调度器会会把 <code>gcwaiting</code>设置为<code>1</code>, 所以这里会进入 <code>gcstopm()</code>, 直到所有的 m 都被<code>stop</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcstopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"gcstopm: not waiting for gc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// OK to just drop nmspinning here,</span></span><br><span class="line">        <span class="comment">// startTheWorld will unpark threads as necessary.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"gcstopm: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _p_ := releasep()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    _p_.status = _Pgcstop <span class="comment">//设置 p 状态为 _Pgcstop</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">        notewakeup(&amp;sched.stopnote)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>gcstopm()</code> 会把 p 的状态置为 <code>_Pgcstop</code>。</p>
<p><strong>但是死循环的 g 不会被抢占，所以其 p 状态会一直是  Prunning 无法被设置为 Pgcstop</strong></p>
<p>再回到前面进入死循环的地方:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里进入死循环的原因是条件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) == <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>不满足<br><code>notetsleep</code>函数内部每隔一段时间就会返回:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> atomic.Load(key32(&amp;n.key)) != <span class="number">0</span> <span class="comment">// n.key 为参数 &amp;shced.stopnote.key的值</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数意思是<code>&amp;sched.stopnote.key != 0</code><br>如果要想让返回值为 <code>true</code> 就需要满足上面的条件。 <code>stopnote.key</code>的值有两个函数可以控制:</p>
<ul>
<li><code>notewakeup</code> 把 <code>stopnote</code> 设置为 1</li>
<li><code>noteclear 把</code>stopnote<code>设置为 0
所以我们需要调用</code>notewakeup<code>才行。而这个函数我们可以看到是在</code>gcstopm()`种有调用:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sched.stopwait--</span><br><span class="line"><span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">    notewakeup(&amp;sched.stopnote)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于存在 g 无法被抢占，所以其对应的 p 不会释放, <code>stopwait</code>也就不能为<code>0</code>, 所以也就无法执行<code>notewakeup</code>,最终导致上面的循环无法出来。</p>
<p>死锁状态的发生:</p>
<ul>
<li>GC: 要想进行<code>GC</code>就需要所有的P都转为空闲状态，而主<code>goroutine</code>无法被抢占，对应的<code>P</code>也无法进入空闲。所以<code>GC</code>会一直阻塞。</li>
<li>新启动的<code>goroutine</code>: 由于新启动的<code>goroutine</code>也进入了空闲状态</li>
<li>主<code>goroutine</code>: 由于新启动的<code>goroutine</code>进入了空闲状态,无法再给<code>chan</code>发信号，所以主<code>goroutine</code>也无法退出。<br>由于上面三个都进入了阻塞状态，导致了整个程序进入了死锁状态。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html" target="_blank" rel="noopener">scheduling-in-go-part1</a><br><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html" target="_blank" rel="noopener">scheduling-in-go-part2</a><br><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html" target="_blank" rel="noopener">scheduling-in-go-part3</a><br><a href="https://github.com/two/go-under-the-hood/blob/master/book/part2runtime/ch06sched/preemptive.md" target="_blank" rel="noopener">go-under-the-hood</a><br><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">non-cooperative-preemption</a><br><a href="https://gocn.vip/article/441" target="_blank" rel="noopener">如何定位 golang 进程 hang 死的 bug</a><br><a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/"><span>【译】 Go 语言机制之栈和指针 (1)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-04T05:29:19.000Z">
          2019-03-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列的文章主要是帮助你理解指针，栈，堆，逃逸分析和值/指针语义的设计和机制。本系列一共有四篇，这是第一篇。本篇主要是介绍栈和指针。</p>
<p>本系列文章索引:<br>1) Go 语言机制之栈和指针<br>2) Go 语言机制之逃逸分析<br>3) Go 语言机制之内存性能分析<br>4) Go 语言机制之数据和语义的使用原则</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我并不打算美化指针，因为指针真的很难理解。如果我们使用不当，指针能够产生很难理解的 bug 甚至影响性能。 在写并发程序或者多线程程序时这种问题更为明显。这也难怪很多语言试图对开发者隐藏指针的使用。尽管如此，如果你是用 Go 来开发程序，你是没有办法避免使用指针的。相对于深入的理解指针，你更应该关注如何写出干净，简单并且有效的代码。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/01/golang-http-client-connection-pool/"><span>golang http client 连接池</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/01/golang-http-client-connection-pool/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-01T02:44:03.000Z">
          2018-06-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>golang标准库<code>net/http</code>做为<code>client</code>时有哪些细节需要注意呢，这里做一个详细的分析。</p>
</blockquote>
<h2 id="net-http-client工作流程"><a href="#net-http-client工作流程" class="headerlink" title="net/http client工作流程"></a>net/http client工作流程</h2><p>首先分析一下<code>client</code>的工作流程。 下面是一般我们进行一个请求时的代码事例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoRequest</span><span class="params">(req *http.Request)</span> <span class="params">(MyResponse, error)</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response := MyResponse&#123;&#125;</span><br><span class="line">    response.Header = resp.Header</span><br><span class="line">    ...</span><br><span class="line">    response.Body = body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们首先创建一个<code>http.Client</code>, 所有的值都是默认值，然后调用<code>client.Do</code>发请求，<code>req</code>是我们请求的结构体。这里我们也可以用<code>client.Get</code>, <code>client.Post</code>等函数来调用，从他们的源码来看都是调用的<code>client.Do</code>。<br><code>client.Do</code>的实现在<code>net/http</code>包的<code>go/src/net/http/client.go</code>源文件中。可以看到函数内部主要是实现了一些参数检查，默认值设置，以及对于多跳请求的处理，最为核心的就是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// c.send() always closes req.Body</span></span><br><span class="line">            reqBodyClosed = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">                err = &amp;httpError&#123;</span><br><span class="line">                    err:     err.Error() + <span class="string">" (Client.Timeout exceeded while awaiting headers)"</span>,</span><br><span class="line">                    timeout: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shouldRedirect <span class="keyword">bool</span></span><br><span class="line">redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !shouldRedirect &#123;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里真正发请求的函数就是<code>c.send</code>, 这个函数的实现也比较简单, 主要是调用了<code>send</code>函数，这个函数的实现主要如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// didTimeout is non-nil only if err != nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send issues an HTTP request.</span></span><br><span class="line"><span class="comment">// Caller should close resp.Body when done reading from it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line">    ...</span><br><span class="line">        resp, err = rt.RoundTrip(req)</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里真正进行网络交互的定位到的函数是<code>rt.RoundTrip</code>,这个函数的定义是一个<code>interface</code>，从其注释也可以看出他的主要作用是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// RoundTrip executes a single HTTP transaction, returning</span><br><span class="line">// a Response for the provided Request.`</span><br></pre></td></tr></table></figure></p>
<p>由于这个函数是一个<code>interface</code>我们需要知道是谁实现了这个函数，看一下<code>send</code>的参数就可以找到，实现这个函数的是<code>c.transport()</code>的返回值，这个函数的实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到，返回的对象是<code>c.Transport</code>或者<code>DefaultTransport</code>, 由于我们创建<code>client</code>的时候没有设置<code>c.Transport</code>参数，所以这里返回的应该是<code>DefaultTransport</code>对象, 这个对象对<code>RoundTripper</code>函数的实现大概如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip implements the RoundTripper interface.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For higher-level HTTP client support (such as handling of cookies</span></span><br><span class="line"><span class="comment">// and redirects), see Get, Post, and the Client type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">                pconn, err := t.getConn(treq, cm)</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// HTTP/2 path.</span></span><br><span class="line">                    t.setReqCanceler(req, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">                        resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp, err = pconn.roundTrip(treq)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面具体的细节我们先不关系，对于<code>HTTP/2</code>的处理我们也先不关心。这里需要重点关注的是<code>t.getConn</code>这个函数。<code>t.getConn</code>的作用是获取一个链接，这个链接该怎么获取，是一个值得深究的问题。下面看一下这个函数的关键实现细节:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getConn dials and creates a new persistConn to the target as</span></span><br><span class="line"><span class="comment">// specified in the connectMethod. This includes doing a proxy CONNECT</span></span><br><span class="line"><span class="comment">// and/or setting up TLS.  If this doesn't return an error, the persistConn</span></span><br><span class="line"><span class="comment">// is ready to write requests to.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">req := treq.Request</span><br><span class="line">         trace := treq.trace</span><br><span class="line">         ctx := req.Context()</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GetConn(cm.addr())</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">if</span> pc, idleSince := t.getIdleConn(cm); pc != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GotConn(pc.gotIdleConnTrace(idleSince))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// set request canceler to some non-nil function so we</span></span><br><span class="line">         <span class="comment">// can detect whether it was cleared between now and when</span></span><br><span class="line">         <span class="comment">// we enter roundTrip</span></span><br><span class="line">         t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;&#125;)</span><br><span class="line">             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">         handlePendingDial := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             testHookPrePendingDial()</span><br><span class="line">                 <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> v := &lt;-dialc; v.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                         t.putOrCloseIdleConn(v.pc)</span><br><span class="line">                     &#125;</span><br><span class="line">                     testHookPostPendingDial()</span><br><span class="line">                 &#125;()</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">cancelc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">             t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123; cancelc &lt;- err &#125;)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                 pc, err := t.dialConn(ctx, cm)</span><br><span class="line">                     dialc &lt;- dialRes&#123;pc, err&#125;</span><br><span class="line">             &#125;()</span><br><span class="line">idleConnCh := t.getIdleConnCh(cm)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> v := &lt;-dialc:</span><br><span class="line">                            <span class="comment">// Our dial finished.</span></span><br><span class="line">                            <span class="keyword">if</span> v.pc != <span class="literal">nil</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &amp;&amp; v.pc.alt == <span class="literal">nil</span> &#123;</span><br><span class="line">                                    trace.GotConn(httptrace.GotConnInfo&#123;Conn: v.pc.conn&#125;)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> v.pc, <span class="literal">nil</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Our dial failed. See why to return a nicer error</span></span><br><span class="line">                            <span class="comment">// value.</span></span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                    <span class="comment">// It was an error due to cancelation, so prioritize that</span></span><br><span class="line">                                    <span class="comment">// error value. (Issue 16049)</span></span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                                <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                                          <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                              err = errRequestCanceledConn</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                              <span class="comment">// It wasn't an error due to cancelation, so</span></span><br><span class="line">                                              <span class="comment">// return the original error message:</span></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">nil</span>, v.err</span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="keyword">case</span> pc := &lt;-idleConnCh:</span><br><span class="line">                             <span class="comment">// Another request finished first and its net.Conn</span></span><br><span class="line">                             <span class="comment">// became available before our dial. Or somebody</span></span><br><span class="line">                             <span class="comment">// else's dial that they didn't use.</span></span><br><span class="line">                             <span class="comment">// But our dial is still going, so give it away</span></span><br><span class="line">                             <span class="comment">// when it finishes:</span></span><br><span class="line">                             handlePendingDial()</span><br><span class="line">                                 <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">                                     trace.GotConn(httptrace.GotConnInfo&#123;Conn: pc.conn, Reused: pc.isReused()&#125;)</span><br><span class="line">                                 &#125;</span><br><span class="line">                             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                 handlePendingDial()</span><br><span class="line">                                     <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                     handlePendingDial()</span><br><span class="line">                                         <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                    <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                              handlePendingDial()</span><br><span class="line">                                  <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                      err = errRequestCanceledConn</span><br><span class="line">                                  &#125;</span><br><span class="line">                              <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是这个过程的流程图:<br><img src="http://www.plantuml.com/plantuml/svg/NP3DYi8m58NNvYcohA-WIv-as5I39HbCD-vcm9_IHHsm54P1Pa2NC-fcb2deopHf-XRUDjQ1XcnoxpddVhd2jyS-eYwsiZJIjwsAzkhqgQEpN2R5wWhFDlQ7X65hGaGROJWTVOlbPckwNKGyGR35UDbq-NY4MXqPR6JwfvAZ2UmQcmf3ur7nLGR7_EUhU5ivrFRwsUNxeG68kc8O_XFAR6mFRCfW0kYCdpeUwN76UiE6HGPhkCKYX6dvUbhJrYG0PoYXz_XsHVLSWGeI_JhhUroGnlGgGiv-ipGfuWzzECZTD7-Vboh27BC3KE36cfX3NIHy_d87"><br>从上面可以看到，获取链接会优先从连接池中获取，如果连接池中没有可用的连接，则会创建一个连接或者从刚刚释放的连接中获取一个，这两个过程时同时进行的，谁先获取到连接就用谁的。<br>当新创建一个连接, 创建连接的函数定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error)</span><br></pre></td></tr></table></figure></p>
<p>最后这个函数会通过goroutine调用两个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go pconn.readLoop()</span><br><span class="line">go pconn.writeLoop()</span><br></pre></td></tr></table></figure></p>
<p>其中<code>readLoop</code>主要是读取从server返回的数据,<code>writeLoop</code>主要发送请求到server,在<code>readLoop</code>函数中有这么一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Put the idle conn back into the pool before we send the response</span><br><span class="line">// so if they process it quickly and make another request, they&apos;ll</span><br><span class="line">// get this same conn. But we use the unbuffered channel &apos;rc&apos;</span><br><span class="line">// to guarantee that persistConn.roundTrip got out of its select</span><br><span class="line">// potentially waiting for this persistConn to close.</span><br><span class="line">// but after</span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">    pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br></pre></td></tr></table></figure></p>
<p>这里可以看出，在处理完请求后，会立即把当前连接放到连接池中。</p>
<p>上面说到连接池，每个<code>client</code>的连接池结构是这样的:<code>idleConn   map[connectMethodKey][]*persistConn</code>。其中<code>connectMethodKey</code>的值就是<code>client</code>连接的server的<code>host</code>值, map的值是一个<code>*persistConn</code>类型的<code>slice</code>结构，这里就是存放连接的地方，<code>slice</code>的长度由<code>MaxIdleConnsPerHost</code>这个值指定的，当我们不设置这个值的时候就取默认的设置:<code>const DefaultMaxIdleConnsPerHost = 2</code>。</p>
<p>另外这里我们插一个知识点，对于HTTP协议，有一个header值”Connections”, 这个值的作用就是<code>client</code>向<code>server</code>端发请求的时候，告诉<code>server</code>是否要保持连接。具体的可以参考<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank" rel="noopener">rfc2616</a>。 这个协议头的值有两种可能(参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">MDN文档</a>):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p>
<p>当值为<code>keep-alive</code>时，<code>server</code>端会保持连接，一直到连接超时。当值为<code>close</code>时,<code>server</code>端会在传输完<code>response</code>后主动断掉<code>TCP</code>连接。在<code>HTTP/1.1</code>之前，这个值默认是<code>close</code>, 之后是默认<code>keep-alive</code>, 而<code>net/http</code>默认的协议是<code>HTTP/1.1</code>也就是默认<code>keep-alive</code>, 这个值可以通过<code>DisableKeepAlives</code>来设置。</p>
<p>从上面的介绍我们可以看出，<code>net/http</code>默认是连接复用的，对于每个server会默认的连接池大小是2。<br>接下来我们看一下连接是如何放进连接池的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">putOrCloseIdleConn</span><span class="params">(pconn *persistConn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span></span><br><span class="line"><span class="comment">// a new request.</span></span><br><span class="line"><span class="comment">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span></span><br><span class="line"><span class="comment">// an error explaining why it wasn't registered.</span></span><br><span class="line"><span class="comment">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errKeepAlivesDisabled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.isBroken() &#123;</span><br><span class="line">        <span class="keyword">return</span> errConnBroken</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errNotCachingH2Conn</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.markReused()</span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line"></span><br><span class="line">    t.idleMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> t.idleMu.Unlock()</span><br><span class="line">    waitingDialer := t.idleConnCh[key]</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> waitingDialer &lt;- pconn:</span><br><span class="line">        <span class="comment">// We're done with this pconn and somebody else is</span></span><br><span class="line">        <span class="comment">// currently waiting for a conn of this type (they're</span></span><br><span class="line">        <span class="comment">// actively dialing, but this conn is ready</span></span><br><span class="line">        <span class="comment">// first). Chrome calls this socket late binding. See</span></span><br><span class="line">        <span class="comment">// https://insouciant.org/tech/connection-management-in-chromium/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> waitingDialer != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// They had populated this, but their dial won</span></span><br><span class="line">            <span class="comment">// first, so we can clean up this map entry.</span></span><br><span class="line">            <span class="built_in">delete</span>(t.idleConnCh, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.wantIdle &#123;</span><br><span class="line">        <span class="keyword">return</span> errWantIdle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.idleConn == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.idleConn = <span class="built_in">make</span>(<span class="keyword">map</span>[connectMethodKey][]*persistConn)</span><br><span class="line">    &#125;</span><br><span class="line">    idles := t.idleConn[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(idles) &gt;= t.maxIdleConnsPerHost() &#123;</span><br><span class="line">        <span class="keyword">return</span> errTooManyIdleHost</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, exist := <span class="keyword">range</span> idles &#123;</span><br><span class="line">        <span class="keyword">if</span> exist == pconn &#123;</span><br><span class="line">            log.Fatalf(<span class="string">"dup idle pconn %p in freelist"</span>, pconn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    t.idleLRU.add(pconn)</span><br><span class="line">    <span class="keyword">if</span> t.MaxIdleConns != <span class="number">0</span> &amp;&amp; t.idleLRU.<span class="built_in">len</span>() &gt; t.MaxIdleConns &#123;</span><br><span class="line">        oldest := t.idleLRU.removeOldest()</span><br><span class="line">        oldest.<span class="built_in">close</span>(errTooManyIdle)</span><br><span class="line">        t.removeIdleConnLocked(oldest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IdleConnTimeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pconn.idleTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">            pconn.idleTimer.Reset(t.IdleConnTimeout)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.idleAt = time.Now()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会尝试把连接放入到连接池中，如果不成功则<code>关闭连接</code>,大致流程如下:<br><img src="http://www.plantuml.com/plantuml/svg/XP5FJy8m6CRl-nGzmispauEHWyQO-1LgU8UDIsVMuf-4WqOM5rHYuX914m864gC1528I8F9brcux-HMS82Cxg3sqJVi-lxvF7yQnoHMYeKIQCBoZmoR0_gfE3e2XL0fnCmSedqTR-6WZeyEQGIdR1dFTO1ojeAKauhj0KU8OM591uLWMLY-uRVcJgYmrLGLq1YX1ZVcbVIz6GtTmuWwUl7OzEBqvn8GJcaqJh8FfEO_ki1GAfTFtdY_4LIyuBqhdmxih-6y5ERnMqPIZ6URUT3E5kkEoi6nPBCuU3Uk5rHJsImpj3bhgGX9lSduCD1FX4SvYGXUA36WuftDXru9A8qRs9vN8pUVuCYXtPUiXA8z4lQh-YXDMNxJF0gVYTpgXwEz-mZLo_1tKZy_NcdZlob7zlmnYg7WUix-AU54jqPHe_W80"><br>如果<code>DisableKeepAlives</code>为<code>true</code>表示不使用连接复用，所以请求完后会把连接关掉，但是这里需要注意的是，同时发请求的时候我们会设置<code>Connections: close</code>, 所以<code>server</code>端发送完数据后就会自动断开，所以这种情况的连接其实是<code>server</code>端发起的。</p>
<h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>前面我们已经讲过<code>net/http</code>默认使用<code>HTTP/1.1</code>协议，也就是默认发送<code>Connections: keep-alive</code>的头，让服务端保持连接，就是所谓的长连接。<br>再看<code>DefaultTransport</code>的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// DefaultTransport is the default implementation of Transport and is</span><br><span class="line">// used by DefaultClient. It establishes network connections as needed</span><br><span class="line">// and caches them for reuse by subsequent calls. It uses HTTP proxies</span><br><span class="line">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and</span><br><span class="line">// $no_proxy) environment variables.</span><br><span class="line">var DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment, //代理使用</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   30 * time.Second, //连接超时时间</span><br><span class="line">        KeepAlive: 30 * time.Second, //连接保持超时时间</span><br><span class="line">        DualStack: true, //</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    MaxIdleConns:          100, //client对与所有host最大空闲连接数总和</span><br><span class="line">    IdleConnTimeout:       90 * time.Second, //空闲连接在连接池中的超时时间</span><br><span class="line">    TLSHandshakeTimeout:   10 * time.Second, //TLS安全连接握手超时时间</span><br><span class="line">    ExpectContinueTimeout: 1 * time.Second, //发送完请求到接收到响应头的超时时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用<code>DefaultTransport</code>时，就是默认使用的长连接。但是默认的连接池<code>MaxIdleConns</code>为100， <code>MaxIdleConnsPerHost</code>为2，当超出这个范围时，客户端会主动关闭到连接。<br>如果我们想设置为短连接，有几种方法:</p>
<ol>
<li>设置<code>DisableKeepAlives = true</code>: 这时就会发送<code>Connections:close</code>给server端，在server端响应后就会主动关闭连接。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>: 当<code>MaxIdleConnsPerHost &lt; 0</code>时，连接池是无法放置空闲连接的，所以无法复用,连接直接会在<code>client</code>端被关闭。</li>
</ol>
<h2 id="Server端出现大量的TIME-WAIT"><a href="#Server端出现大量的TIME-WAIT" class="headerlink" title="Server端出现大量的TIME_WAIT"></a>Server端出现大量的<code>TIME_WAIT</code></h2><p>当我们在实际使用时，会发现<code>Server</code>端出现了大量的<code>TIME_WAIT</code>,要想深入了解其原因，我们首先先回顾一下<code>TCP</code>三次握手和四次分手的过程:<br><img src="/assets/img/golang/tcp_3_handshake.png" alt><br><img src="/assets/img/golang/tcp_4_handshake.png" alt><br>图中可以看出，<code>TIME_WAIT</code>只会出现在主动关闭连接的一方,也就是<code>server</code>端出现了大量的主动关闭行为。<br>默认我们是使用长连接的，只有在超时的情况下<code>server</code>端才会主动关闭连接。前面也讲到，如果超出连接池的部分就会在<code>client</code>端主动关闭连接，连接池的连接会复用，看着似乎没有什么问题。问题出在我们每次请求都会<code>new</code>一个新的<code>client</code>,这样每个<code>client</code>的连接池里的连接并没有得到复用，而且这时<code>client</code>也不会主动关闭这个连接，所以<code>server</code>端出现了大量的<code>keep-alive</code>但是没有请求的连接，就会主动发起关闭。</p>
<p>todo:补充tcpdump的分析结果</p>
<p>要解决这个问题以下几个方案:</p>
<ol>
<li><code>client</code>复用，也就是我们尽量复用<code>client</code>，来保证<code>client</code>连接池里面的连接得到复用，而减少出现超时关闭的情况。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>：这样每次请求后都会由<code>client</code>发起主动关闭连接的请求，<code>server</code>端就不会出现大量的<code>TIME_WAIT</code></li>
<li><p>修改<code>server</code>内核参数: 当出现大量的<code>TIME_WAIT</code>时危害就是导致<code>fd</code>不够用,无法处理新的请求。我们可以通过设置<code>/etc/sysctl.conf</code>文件中的</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>
<p> 达到快速回收和重用的效果，不影响其对新连接的处理。</p>
</li>
</ol>
<p>另外需要注意的是，虽然<code>DisableKeepAlives = true</code>也能满足连接池中不放空闲连接，但是这时候会发送<code>Connections: close</code>，这时<code>server</code>端还是会主动关闭连接，导致大量的<code>TIME_WAIT</code>出现，所以这种方法行不通。</p>
<p>以上就是我总结的关于<code>net/http</code>中连接池相关的知识。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/03/the-core-technology-of-high-traffic-website/"><span>亿级流量网站架构核心技术总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/03/the-core-technology-of-high-traffic-website/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-03T05:27:30.000Z">
          2017-08-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近读了《亿级流量网站架构核心技术——跟开涛学搭建高可用高并发系统》这本书，总体感觉这本书很实用，作者根据自己负责的项目经历以及业务的发展过程和业界的理论基础相结合讲解了如何搭建一个具有高并发和高可用特征的电商网站。作者是京东的架构师，进来随着京东业务的不断发展，6.18和双十一活动规模的不断扩大，作者都亲身经历了整个电商网站的发展过程，相对于单纯的理论，这本书更多的是能够在业务中快速应用的经验总结。下面就这两方面我把作者的思维导图搬过来，不断提醒自己要注意的整体思想，并能够深入浅出，根据思维导图的每一项都有一个自己更发散更深入的认识。</p>
</blockquote>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><img src="/assets/img/cthtw/High-availability.png" alt="高可用"></p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="/assets/img/cthtw/High-concurrency.png" alt="高并发"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/java/">java</a><a href="/tags/架构/">架构</a><a href="/tags/高并发/">高并发</a><a href="/tags/高可用/">高可用</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>