<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>OohCode | ooh my code</title>

  
  <meta name="author" content="sean chen">
  

  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="OohCode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="OohCode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">OohCode</a>
    </h1>
    <p class="site-description">ooh my code</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/10/unit-test-in-go/"><span>Go 单元测试</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/10/unit-test-in-go/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-10T02:11:19.000Z">
          2019-06-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Go单元测试"><a href="#Go单元测试" class="headerlink" title="Go单元测试"></a>Go单元测试</h1><p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。<br>我们为何要进行单元测试呢？其实如果你不添加单元测试的话，别人调用你提供的函数是，其实就是帮你做测试，但是这种测试我们越早做越能发现问题.</p>
<h3 id="单元测试的粒度"><a href="#单元测试的粒度" class="headerlink" title="单元测试的粒度"></a>单元测试的粒度</h3><p>程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。在 Go 中程序单元指的是<code>Package</code>中的方法。<br>那么我们对于 Go 中改对那些函数写单元测试呢？这里的答案是: 包中可导出的函数。 因为这些函数是对外可见的，这些是我们包的入口。那么对于不可导出的函数我们是否需要些单元测试呢？答案是不用。有些人可能会有一位，如果我们不对不可导出的函数写单元测试，那么如何保证单元测试的覆盖率呢？因为有些不可导出函数的覆盖率达不到要求。这里要说的是: 如果有些不可导出函数单元测试覆盖率达不到，有两点可能性:</p>
<ul>
<li>这些逻辑是不需要的，你可以直接去掉</li>
<li>你的测试用例不够，你需要增加可导出函数的测试用例</li>
</ul>
<h3 id="单测的三个原则"><a href="#单测的三个原则" class="headerlink" title="单测的三个原则"></a>单测的三个原则</h3><p>还有一个问题是: 我该先开发功能在写单元测试，还是先写单元测试再开发功能？<br>其实关于TDD有三个定律:</p>
<ol>
<li>You are not allowed to write any production code unless it is to make a failing unit test pass.</li>
<li>You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.</li>
<li>You are not allowed to write any more production code than is sufficient to pass the one failing unit test.</li>
</ol>
<p>关于这三条定律，我发现每个人翻译的都不一样，我觉得比较符合我的理解的翻译是:</p>
<ol>
<li>除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</li>
<li>在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</li>
<li>只允许编写刚好能够使一个失败的 unit test 通过的产品代码</li>
</ol>
<p>如果违反了会怎么样呢？<br>违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p>
<p>还是针对上面的问题: 先写单元测试还是先写功能？<br>我的答案是: <strong>单元测试-&gt; 功能开发 -&gt; 单元测试 -&gt; 功能开发…</strong><br>它们应该是交替进行的，既: 先写小范围的单元测试，然后针对这些测试进行开发功能，等所有测试通过后继续增加测试<code>case</code>, 然后针对新增的<code>case</code>继续编写功能，直到功能满足了需求为止。</p>
<h3 id="测试行为-而非实现"><a href="#测试行为-而非实现" class="headerlink" title="测试行为, 而非实现"></a>测试行为, 而非实现</h3><p>Avoid Testing Implementation Details, Test Behaviours<br>当我们测试行为时，我们的意思是 : “我不在乎你是如何得出答案的，只要确保在这种情况下答案是正确的”<br>当我们测试实现时，我们的意思是 : “我不在乎答案是什么，只要确保它是按照你规定的方式工作的。”</p>
<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="单元测试编写"><a href="#单元测试编写" class="headerlink" title="单元测试编写"></a>单元测试编写</h3><p>下面给出一个完整的<code>Go</code>的单元测试的例子:<br><code>split.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">    i := strings.Index(s, sep)</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">        s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">        i = strings.Index(s, sep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>split_test.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        got := Split(<span class="string">"a/b/c"</span>, <span class="string">"/"</span>)</span><br><span class="line">        want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, want, got)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Go</code>官方网站有关于单元测试的<a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">写法介绍</a>, 以上面的代码为例:</p>
<ol>
<li><p>一般我们需要单元测试文件和要测试的包的文件需要在同一个目录下，并且以<code>_test.go</code>结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/split/</span><br><span class="line">├── split.go</span><br><span class="line">└── split_test.go</span><br></pre></td></tr></table></figure>
</li>
<li><p>单元测试的函数名为<code>Test</code> + 要测试的函数名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要测试的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">// 单元测试函数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TestSplit</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单元测试函数的参数是固定的 (<a href="https://golang.org/pkg/testing/#T" target="_blank" rel="noopener">*testing.T</a>):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p><code>Go</code>语言的工具链中提供了很强大的<a href="https://golang.org/cmd/go/#hdr-Test_packages" target="_blank" rel="noopener">单元测试工具</a>:<code>go test</code>, 如果想要运行刚才的单元测试，我们只需要在<code>split</code>文件夹下执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure></p>
<p>就可以得出测试结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">PASS</span><br><span class="line">ok      split   0.008s</span><br></pre></td></tr></table></figure></p>
<h3 id="运行多个单元测试"><a href="#运行多个单元测试" class="headerlink" title="运行多个单元测试"></a>运行多个单元测试</h3><p>有是有我们需要同时运行多个单元测试, 如果这些单元测试在同一个包下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/xml/</span><br><span class="line">├── atom_test.go</span><br><span class="line">├── example_marshaling_test.go</span><br><span class="line">├── example_test.go</span><br><span class="line">├── example_text_marshaling_test.go</span><br><span class="line">├── marshal.go</span><br><span class="line">├── marshal_test.go</span><br><span class="line">├── read.go</span><br><span class="line">├── read_test.go</span><br><span class="line">├── typeinfo.go</span><br><span class="line">├── xml.go</span><br><span class="line">└── xml_test.go</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接运行: <code>go test</code><br>如果这些单元测试文件不在同一个包下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/</span><br><span class="line">├── ascii85</span><br><span class="line">│   ├── ascii85.go</span><br><span class="line">│   └── ascii85_test.go</span><br><span class="line">├── asn1</span><br><span class="line">│   ├── asn1.go</span><br><span class="line">│   ├── asn1_test.go</span><br><span class="line">│   ├── common.go</span><br><span class="line">│   ├── marshal.go</span><br><span class="line">│   └── marshal_test.go</span><br><span class="line">├── base32</span><br><span class="line">│   ├── base32.go</span><br><span class="line">│   ├── base32_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">├── base64</span><br><span class="line">│   ├── base64.go</span><br><span class="line">│   ├── base64_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们需要在这些包的外面运行: <code>go test ./...</code></p>
<h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>如果我们想要查看单元测试的覆盖率，<code>Go</code> 工具链也是支持的, 详情可以参考官方的Blog: <a href="https://blog.golang.org/cover" target="_blank" rel="noopener">The cover story</a><br>如果要查看单元测试覆盖率，我们可以运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      split   0.013s</span><br></pre></td></tr></table></figure></p>
<p>但是上面的测试只给出了覆盖率的值，并没有看到详细的信息，如果我们需要查看覆盖率的详细信息，可以把测试覆盖率的内容输出到文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go test -coverprofile=coverage.out</span><br></pre></td></tr></table></figure></p>
<p>这样，测试覆盖率的详细信息就输出到了文件<code>coverage.out</code>中。<br>如过要查看每个函数的测试覆盖率，可以利用刚才的<code>coverage.out</code>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -func=coverage.out</span><br><span class="line">split/split.go:7:       Split           100.0%</span><br><span class="line">total:                  (statements)    100.0%</span><br></pre></td></tr></table></figure></p>
<p>如果要想可视化测试覆盖率，还可以生成<code>html</code>格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -html=coverage.out</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到每行的覆盖情况:<br><img src="https://blog.golang.org/cover/set.png" alt="覆盖率"><br>其中红色代表没有覆盖到，绿色代表覆盖到，灰色代表不计入测试覆盖率的范围</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="多个case"><a href="#多个case" class="headerlink" title="多个case"></a>多个case</h3><p>前面我们讲了如何进行基本的单元测试，但是现实中往往我们需要对同一个函数进行多个<code>case</code>的测试，那么其实有两种写法:</p>
<h4 id="针对每个case写一个测试函数"><a href="#针对每个case写一个测试函数" class="headerlink" title="针对每个case写一个测试函数:"></a><strong>针对每个<code>case</code>写一个测试函数:</strong></h4><p>对于比较复杂的函数，其函数的表现可能会收到不同环境因素的影响，他们的单元测试写法差别也比较大，比如<code>beego</code>中 <a href="https://github.com/astaxie/beego/blob/develop/logs/file_test.go" target="_blank" rel="noopener">logs/file</a> 的单元测试, 同样是测试<code>FileDailyRotate</code>函数，<code>TestFileDailyRotate_01</code>测试的是创建文件, <code>TestFileDailyRotate_02</code>测试的是当创建的文件存在时，给文件加后缀。</p>
<h4 id="同一个测试函数里有多个case"><a href="#同一个测试函数里有多个case" class="headerlink" title="同一个测试函数里有多个case:"></a><strong>同一个测试函数里有多个<code>case</code>:</strong></h4><p>一般比较简单的单元测试，只是根据输入的不同而产生不同的输出，则可以使用这种方式。比如前面说的<code>split</code>函数的多个<code>case</code>测试, 我们把<code>split_test.go</code>改为下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep   <span class="keyword">string</span></span><br><span class="line">        want  []<span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tests := []test&#123;</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := Split(tc.input, tc.sep)</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">            t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边界条件测试"><a href="#边界条件测试" class="headerlink" title="边界条件测试"></a>边界条件测试</h3><p>由长期的测试工作经验得知，大量的错误是发生在输入或输出的边界上。因此针对各种边界情况设计测试用例，可以查出更多的错误。上面的<code>case</code>中我们并没有对边界条件进行测试，下面我们加上一个边界条件的测试<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们的单元测试有一个<code>case</code>没有通过，但是这里有一点疑问:<strong>哪个测试<code>case</code>没过?</strong></p>
<h3 id="定位测试case"><a href="#定位测试case" class="headerlink" title="定位测试case"></a>定位测试case</h3><h4 id="通过编号定位"><a href="#通过编号定位" class="headerlink" title="通过编号定位"></a>通过编号定位</h4><p>我们可以给每个case一个编号:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"test %d: expected: %v , got %v"</span>, i+<span class="number">1</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: test 2: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.016s</span><br></pre></td></tr></table></figure>
<p>这里可以定位出 <code>test 2</code> 有问题的，但是编号的问题是 : </p>
<ul>
<li>每个人定义的开始下标可能不同: 有的人是从<code>0</code>开始，有的人从<code>1</code>开始，照成理解不一致</li>
<li>随着case的增多，同样不好定位具体的<code>case</code>: 如果你要从<code>50</code>个<code>case</code>中定位第<code>27</code>个<code>case</code>, 还是比较费时的。</li>
</ul>
<h4 id="通过名字定位"><a href="#通过名字定位" class="headerlink" title="通过名字定位"></a>通过名字定位</h4><p>还有一种方式: 我们给每个<code>case</code>一个名字:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                name  <span class="keyword">string</span></span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;name: <span class="string">"simple"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"trailing sep"</span>, input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"wrong sep"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"no sep"</span>, input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, tc.name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:26: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure>
<p>现在我们可以看到我们可以很好的通过<code>trailing sep</code>快速定位到了具体的<code>case</code></p>
<h3 id="随机测试case"><a href="#随机测试case" class="headerlink" title="随机测试case"></a>随机测试case</h3><p>上面的测试方式看上去很完美了，可以如果我们实现的时候没有注意，<code>case</code>之间可能会相互影响, 比如一个<code>case</code>在函数内部修改了一个全局变量，下一个<code>case</code>的执行就会受到这种影响。为了避免由于测试顺序带来的问题，我们一般都会让每个<code>case</code>之间的顺序是随机的，而不是按照特定的顺序，而<code>slice</code>本身有顺序的，所以不满足我们的条件，这时我们可以使用<code>map</code>, 同时还可以把<code>name</code>放到<code>map</code>的<code>key</code>中，简化我们的写法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:23: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.014s</span><br></pre></td></tr></table></figure></p>
<h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><p>看上去前面的测试更加完美了， <strong>但是……</strong><br>我们的测试<code>case</code>出现错误的时候，我们会调用:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br></pre></td></tr></table></figure></p>
<p>打印我们的错误信息，但是这个错误信息打印后整个测试过程就结束了，如果我们有很多个<code>case</code>需要测试，而前面的<code>case</code>失败后就无法进行后面的测试了，这时候我们如果针对这个出错的<code>case</code>修改后，我们会发现其他的<code>case</code>有报错了，我们反复的修改，但是我们并不知道自己到底有多少个<code>case</code>是有问题的，我们无法一次性把问题修复好，照成我们工作量变大，并且效率变低，那么我们该如何改进这个情况呢?<br>我们知道问题出在<code>t.Fatalf</code>，那么我们可不可以即打印出错误信息又不让程序中断呢？答案是: 可以！ 我们使用<code>f.Errorf</code>替换<code>f.Fatalf</code><br><strong>可是…..</strong><br>如果某个<code>case</code>出现了<code>panic</code>同样会导致整个程序中断，所以这种方式治标不治本。那么我们该如何改进呢? Go 1.7 开始支持了 <a href="https://golang.org/doc/go1.7#testing" target="_blank" rel="noopener">sub test</a>。 下面我们就按照<code>Sub Test</code>的写法进行修改:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        got := Split(tc.input, tc.sep)</span><br><span class="line">                        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>t.Run</code>的源码我们看到:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span> tRunner(t, f)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实会诊对每个<code>case</code>启动一个<code>goroutine</code>， 所以其中一个出现了<code>panic</code>不会影响其他的<code>case</code>执行。</p>
<p>上面这种形态就是目前我们进行单元测试的<strong>最佳实践</strong>了。</p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><h4 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h4><p>外部依赖是指我们的函数需要调用其他的函数，外部依赖有可能涉及到一些数据依赖，网络依赖等。关于单元测试中如何解决外部依赖的问题, 常用的方法是: <strong>Test Double(测试替身)</strong>, 而它也分很多种:</p>
<ul>
<li><strong>Dummy</strong> objects are passed around but never actually used. Usually they are just used to fill parameter lists.</li>
<li><strong>Fake</strong> objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).</li>
<li><strong>Stubs</strong> provide canned answers to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test.</li>
<li><strong>Spies</strong> are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.</li>
<li><strong>Mocks</strong> are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.</li>
</ul>
<p>看上去有点儿头大，分这么多类型而且他们的接线感觉也比较模糊，为了便于理解我们不对这些概念做过多的解读，我们后面把所有我们的工作都看做是<code>Mock</code></p>
<h4 id="编写可测试代码"><a href="#编写可测试代码" class="headerlink" title="编写可测试代码"></a>编写可测试代码</h4><h5 id="函数要短小"><a href="#函数要短小" class="headerlink" title="函数要短小"></a>函数要短小</h5><p><em>函数的第一规则是要短小。第二条规则是还要短小</em> ———— 《代码整洁之道》<br>至于如何才算短小，一般建议是不超过100行，也就是显示器一屏所显示的行数。<br>函数越短小那么单元测试的编写就越简单。</p>
<h5 id="函数功能要单一"><a href="#函数功能要单一" class="headerlink" title="函数功能要单一"></a>函数功能要单一</h5><p><em>函数应该做一件事。做好这件事。只做一件事。</em> ————–《代码整洁之道》<br>一个函数做的事情越少其逻辑越简单，难么对应的单元测试也就越简单。</p>
<h5 id="减少外部依赖"><a href="#减少外部依赖" class="headerlink" title="减少外部依赖"></a>减少外部依赖</h5><p>这里要明确的是我们要测试的是自己的函数而不是调用的函数，所以我们应该把中重点放到自己的函数上，至于外部依赖的函数越少越好，因为每个外部依赖都增加了我们单元测试的不确定性。</p>
<h5 id="依赖模块要方便-Mock"><a href="#依赖模块要方便-Mock" class="headerlink" title="依赖模块要方便 Mock"></a>依赖模块要方便 Mock</h5><p>为了专注我们自己模块的测试，对于外部的模块我们一般都会使用<code>Mock</code>的方法, 所以依赖模块如果好<code>Mock</code>的话测试起来就会方便很多，反之会很麻烦。</p>
<h5 id="方便依赖注入"><a href="#方便依赖注入" class="headerlink" title="方便依赖注入"></a>方便依赖注入</h5><p>一般我们<code>Mock</code>是通过依赖注入的方式，这种方式可以方便的更改依赖的对象的实现，而依赖注入的方式有好几种:</p>
<ul>
<li>通过变量赋值</li>
<li>通过参数传递</li>
<li>通过Set/Get方法</li>
</ul>
<h3 id="一个外部依赖的例子"><a href="#一个外部依赖的例子" class="headerlink" title="一个外部依赖的例子"></a>一个外部依赖的例子</h3><p>一个<code>User</code>包, 有一个通过<code>uid</code>获取分数<code>score</code>的方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">                Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">                Password: <span class="string">""</span>,</span><br><span class="line">                DB:       <span class="number">0</span>,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        _, err := client.Ping().Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">        <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个<code>Class</code>包，通过调用<code>user.Score</code>方法获取分数，根据分数给这个用户一个等级:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们要给<code>UserLevel</code>写单元测试，该怎么写呢？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">5</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestUserLevel (0.02s)</span><br><span class="line">    --- FAIL: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">        class_test.go:24: expected: N, got E</span><br><span class="line">    --- FAIL: TestUserLevel/C_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: C, got E</span><br><span class="line">    --- FAIL: TestUserLevel/B_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: B, got E</span><br><span class="line">    --- FAIL: TestUserLevel/A_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: A, got E</span><br><span class="line">    --- FAIL: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">        class_test.go:24: expected: W, got E</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    class   0.023s</span><br></pre></td></tr></table></figure></p>
<p>可以看到除了<code>Got Error</code>运行成功，其他的都失败了，因为我们本地并没有开启<code>redis</code>服务，所以是连不上的。如果我们要让这个测试用例通过，显然我们不能真的开启一个<code>redis</code>的服务，我们需要对<code>user.Score</code>进行<code>Mock</code></p>
<h4 id="Mock框架"><a href="#Mock框架" class="headerlink" title="Mock框架"></a>Mock框架</h4><p>go中<code>mock</code>的支持也有很多种:</p>
<ul>
<li><a href="https://github.com/golang/mock" target="_blank" rel="noopener">github.com/golang/mock</a></li>
<li><a href="https://github.com/bouk/monkey" target="_blank" rel="noopener">github.com/bouk/monkey</a></li>
<li><a href="https://github.com/smartystreets/goconvey" target="_blank" rel="noopener">github.com/smartystreets/goconvey</a></li>
<li><a href="https://github.com/stretchr/testify" target="_blank" rel="noopener">github.com/stretchr/testify</a></li>
<li><a href="https://github.com/prashantv/gostub" target="_blank" rel="noopener">github.com/prashantv/gostub</a></li>
</ul>
<p>每个框架都有自己的用法， 这里我那<code>github.com/bouk/monkey</code>来举例子, 改造一下我们的单元测试:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"bou.ke/monkey"</span></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        monkey.Patch(user.Score, mockScore)</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mockScore</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.014s</span><br></pre></td></tr></table></figure></p>
<h4 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h4><p>前面通过<code>Mock</code>框架我们可以在测试的时候替换原来的实现，这样就可以很方便的进行单元测试了,但是这种代码的实现方式其实并不符合面相对象设计的原则, 下面提出两个问题:</p>
<ol>
<li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?</li>
<li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？</li>
</ol>
<p>可见上面的方式不太灵活，面对复杂多变的需求无法很好的满足。这时就要求我们改用面相接口编程, 下面是我们使用面相接口编程的方式改进了上面的实现:<br><code>user</code>包增加了一个<code>User</code>接口，这个接口有一个函数<code>Score</code>, 然后定义了一个<code>defaultUser</code>, 并且实现了<code>Score</code>函数，最后定一个<code>New</code>函数向外输出这个<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class</code>包调用由原来的通过包直接调用改为了增加一个<code>u</code>变量, 然后调用<code>u.Score</code>来获取信息:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    score, err := u.Score(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class_test</code>不再依赖<code>mock</code>框架，而是实现了自己的<code>User</code>接口<code>mockUser</code>，替换了<code>user</code>包的<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u = mockUser&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.005s</span><br></pre></td></tr></table></figure></p>
<p>下面再来看上面提出的两个问题:</p>
<ol>
<li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?<br>答: 根据上面的实现可以看到，我们没有借助任何框架同样完成了<code>Mock</code>的效果</li>
<li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？<br>答: 由于面相接口编程，我们可以在user中增加一个实例实现从<code>mysql</code>获取数据的方法，调用者可以根据需求选择不同的实例，而且如果调用者对这个数据来源有自己的需求，甚至可以自己实现这个接口。</li>
</ol>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>上面的实现我们可以看到每次调用<code>var u =  user.New()</code>都会新建一个<code>defaultUser</code>对象，对于有些需要共享<code>defaultUser</code>状态的情况下，例如<code>defaultUser</code>中有一个常驻内存共享的数据, 我们在多个包调用的时候其实那得是不同的对象，为了共享这个数据我们把<code>user.New</code>改成下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样每次返回的其实都是同一个<code>defaultUser</code>。</p>
<h4 id="更方便的调用"><a href="#更方便的调用" class="headerlink" title="更方便的调用"></a>更方便的调用</h4><p>上面我们看出，修改为面相接口编程后我们需要通过依赖注入传递对象，但是这样会对调用者照成麻烦，我们是否可以在优化一下呢?<br>我们在<code>user</code>中增加一个函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以通过<code>user.Score</code>调用<code>du.Score</code>函数了，所以<code>class.go</code>的实现可以改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上去不错，但是我们如何进行依赖注入呢？不然单元测试使用的是默认实现，我们没办法做单元测试了。前面其实我们提过依赖注入的方式有一个<code>Get/Set</code>方式，我们可以再修改一下<code>user</code>包:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> definedUser != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> definedUser.Score(uid)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> definedUser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">    definedUser = u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class</code>不用修改，<code>class_test</code>修改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">int</span></span><br><span class="line">        want  <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">        <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">        <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">        <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">        <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">        <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user.SetUser(mockUser&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := UserLevel(tc.input)</span><br><span class="line">        t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> uid &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过<code>user.SetUser</code>方法用自己的实现替换了之前默认的实现，这样我们就可以方便的进行单元测试了。<br>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.011s</span><br></pre></td></tr></table></figure></p>
<p>在大多数情况下，我们都是使用的默认实现，只有在我们必须要修改依赖的实现，或者单元测试时才会使用其他的实现，所以为了大多数的场景下调用简单，我们应该尽量使用这种方式来实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要回顾了一下关于单元测试的一些理论知识: </p>
<ul>
<li>测试的粒度应该是测试包中的可导出函数</li>
<li>测试的原则告诉我们应该是变测试变开发, 相互交替进行</li>
<li>测试的目的应该是测试行为，而不是测试具体的实现</li>
</ul>
<p>关于Go的单元测试可以分为三个阶段:</p>
<ul>
<li>初级阶段: 主要是认识Go的单元测试基本写法，以及如何利用Go的工具链运行单元测试及查看单元测试覆盖率的情况</li>
<li>进阶阶段: 主要是举一个单元测试的例子，通过不断改进这个单元测试的写法来告诉我们如何写出更好的单元测试</li>
<li>高级阶段: 介绍了如何写出可测试的函数，面对复杂的调用和多变得需求如何利用面相接口编程和依赖注入改进我们的程序的写法</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf" target="_blank" rel="noopener">Test-Driven Development By Example</a><br><a href="https://github.com/gopherchina/conference/blob/master/2019/1.4%20Testing%3B%20how%2C%20what%2C%20why%20-%20Dave%20.pdf" target="_blank" rel="noopener">Testing; how, what, why - Dave</a><br><a href="https://www.youtube.com/watch?v=EZ05e7EMOLM" target="_blank" rel="noopener">TDD, Where Did It All Go Wrong - Lan Cooper</a><br><a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" target="_blank" rel="noopener">The Three Laws of TDD.</a><br><a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">深度解读 - TDD（测试驱动开发）</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">单元测试wiki</a><br><a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">How to Write Go Code - Testing</a><br><a href="https://teamgaslight.com/blog/testing-behavior-vs-testing-implementation" target="_blank" rel="noopener">Testing Behavior vs. Testing Implementation</a><br><a href="http://codebetter.com/iancooper/2011/10/06/avoid-testing-implementation-details-test-behaviours/" target="_blank" rel="noopener">Avoid Testing Implementation Details, Test Behaviours</a><br><a href="https://baike.baidu.com/item/%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">边界条件测试</a><br><a href="https://item.jd.com/10064006.html" target="_blank" rel="noopener">代码整洁之道</a><br><a href="https://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">Mocks Aren’t Stubs</a><br><a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">TestDouble</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/06/Dependency-inversion-principle-in-Go/"><span>Dependency inversion principle in Go</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/06/Dependency-inversion-principle-in-Go/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-06T06:54:25.000Z">
          2019-06-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="依赖反转原则在Go中使用"><a href="#依赖反转原则在Go中使用" class="headerlink" title="依赖反转原则在Go中使用"></a>依赖反转原则在Go中使用</h1><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a>有五个，分别是:</p>
<table>
<thead>
<tr>
<th>首字母</th>
<th>指代</th>
<th>概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>单一功能原则</td>
<td>认为对象应该仅具有一种单一功能的概念。</td>
</tr>
<tr>
<td>O</td>
<td>开闭原则</td>
<td>认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>
</tr>
<tr>
<td>L</td>
<td>里氏替换原则</td>
<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。  参考契约式设计。</td>
</tr>
<tr>
<td>I</td>
<td>接口隔离原则</td>
<td>认为“多个特定客户端接口要好于一个宽泛用途的接口” 的概念。</td>
</tr>
<tr>
<td>D</td>
<td>依赖反转原则</td>
<td>认为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。 依赖注入是该原则的一种实现方式。</td>
</tr>
</tbody>
</table>
<p>这五个原则简称: <code>SOLID</code>。<br>在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。<br>该原则规定：</p>
<ul>
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li>
</ul>
<p>该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。</p>
<p>在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。这种对于低层次组件的依赖限制了高层次组件被重用的可行性。</p>
<p>依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和低层组件划分到不同的包/库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。众多的设计模式，比如插件，服务定位器或者依赖反转，则被用来在运行时把指定的低层组件实现提供给高层组件。</p>
<p>应用依赖反转原则同样被认为是应用了<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">适配器模式</a>，例如：高层的类定义了它自己的适配器接口（高层类所依赖的抽象接口）。被适配的对象同样依赖于适配器接口的抽象（这是当然的，因为它实现了这个接口），同时它的实现则可以使用它自身所在低层模块的代码。通过这种方式，高层组件则不依赖于低层组件，因为它（高层组件）仅间接的通过调用适配器接口多态方法使用了低层组件，而这些多态方法则是由被适配对象以及它的低层模块所实现的。</p>
<blockquote>
<p><strong>前面一大堆其实都是从wiki上copy过来的，自己的理解有以下几点:</strong></p>
<ul>
<li>上层指<strong>调用者</strong>, 下层指<strong>被调用者</strong></li>
<li>原来的编程方式是上层调用下层的时候依赖下层具体的实现方式</li>
<li>依赖反转（或叫:依赖倒置)是指下层的实现依赖上层调用的需求</li>
<li>最终的解决方式是: 把上层的需求抽象成接口，上层依赖接口的抽象进行调用，下层依赖接口的抽象进行实现(下面要介绍的<strong>面相接口编程</strong>)</li>
</ul>
</blockquote>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a>是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</p>
<blockquote>
<p><strong>上面这段也是wiki上的, 自己理解:</strong></p>
<ul>
<li>依赖注入就是: 把下层依赖注入(或叫传递)到上层调用</li>
<li>要把提供服务的一方(也就是前面说的: 下层)作为实例传递给客户端(即:上层)</li>
<li>不要客户端在内部自己实现服务端的实例化。</li>
<li>这种方式的好处是: 可以通过传递不同的实例化对象来实现多态。</li>
</ul>
</blockquote>
<h3 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a>是前面实现依赖反转原则的具体方式。<br>基于接口的编程将应用程序定义为组件的集合，其中组件间的应用程序接口（API）调用可能只通过抽象化接口完成，而没有具体的类。类的实例化一般通过使用如<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener">工厂模式</a>等技术的其他接口完成。</p>
<blockquote>
<p><strong>这里也说一点自己的理解:</strong><br>上面说到要通过依赖注入方式传递实例，这个实例如何生成呢？如果每次都生成一个，如果这个实例是有状态的，那么每个拿到的可能都是不一样的，这样就<strong>无法共享</strong>。所以一般都是通过工厂模式产生一个实例，其他调用方要共享的话都通过这个工厂拿到<strong>同一个实例</strong>。</p>
</blockquote>
<p>另一种定义描述: 在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类</p>
<h4 id="面向接口编程和面向对象编程是什么关系"><a href="#面向接口编程和面向对象编程是什么关系" class="headerlink" title="面向接口编程和面向对象编程是什么关系:"></a>面向接口编程和面向对象编程是什么关系:</h4><p>首先，面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。</p>
<h4 id="接口的本质"><a href="#接口的本质" class="headerlink" title="接口的本质"></a>接口的本质</h4><h5 id="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"><a href="#接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念" class="headerlink" title="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"></a>接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念</h5><p>例如，在自然界中，人都能吃饭，即“如果你是人，则必须能吃饭”。那么模拟到计算机程序中，就应该有一个Person接口，并有一个方法叫Eat()，然后我们规定，每一个表示“人”的类，必须实现Person接口，这就模拟了自然界“如果你是人，则必须能吃饭”这条规则。</p>
<p>从这里，我想各位也能看到些许面向对象思想的东西。面向对象思想的核心之一，就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。</p>
<h5 id="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"><a href="#接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同" class="headerlink" title="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"></a>接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同</h5><p>例如，在我的眼里，我是一个人，和一头猪有本质区别，我可以接受我和我同学是同类这个说法，但绝不能接受我和一头猪是同类。但是，如果在一个动物学家眼里，我和猪应该是同类，因为我们都是动物，他可以认为“人”和“猪”都实现了Animal这个接口，而他在研究动物行为时，不会把我和猪分开对待，而会从“动物”这个较大的粒度上研究，但他会认为我和一棵树有本质区别。</p>
<h4 id="面相接口编程的优点"><a href="#面相接口编程的优点" class="headerlink" title="面相接口编程的优点"></a>面相接口编程的优点</h4><ul>
<li>首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。</li>
<li>使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工。</li>
</ul>
<blockquote>
<p><strong>关于面相接口编程的归纳:</strong></p>
<ul>
<li>面相接口是面向对象编程的重要部分</li>
<li>接口本质上是一组规则的集合，是一定粒度上有相同特指的对象的的抽象</li>
<li>面相接口编程可以提高编程的灵活性, 可以并行开发。</li>
</ul>
</blockquote>
<h2 id="Go-中的应用"><a href="#Go-中的应用" class="headerlink" title="Go 中的应用"></a>Go 中的应用</h2><h3 id="Go-中的接口"><a href="#Go-中的接口" class="headerlink" title="Go 中的接口"></a>Go 中的接口</h3><p>Go语言中，接口(interface)有其特殊的地方, 其他的语言一般要实现一个接口都需要显示的说明<br>例如<code>PHP</code>(这里没有贬低PHP的意思，大多数语言也是这种实现方式例如<code>C++</code>, <code>Python</code>, <code>Rust</code>等):<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare the interface 'iTemplate'</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the interface</span></span><br><span class="line"><span class="comment">// This will work</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span> <span class="keyword">implements</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $vars = <span class="keyword">array</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vars[$name] = $var;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;vars <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">            $template = str_replace(<span class="string">'&#123;'</span> . $name . <span class="string">'&#125;'</span>, $value, $template);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> $template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用到关键字 <code>implements</code>。<br>todo: 对比优缺点</p>
<p>而<code>Go</code>语言中，<code>interface</code>是<code>duck typing</code>(鸭子类型: If it looks like a duck, and it quacks like a duck, then it is a duck), 也就是如果一个对象实现了某个接口的方法，那么这个对象就是这个接口类型了，不需要显示说明是否实现了某个接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Speaker types can say things.</span></span><br><span class="line"><span class="keyword">type</span> Speaker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Say(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person is a strut with filed name</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Say funciton is defined by Speaker and implement by Person</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Say</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  log.Println(p.name+<span class="string">":"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>Person</code>实现了函数<code>Say</code>, 所以<code>Person</code>就是<code>Speaker</code>类型了。</p>
<h3 id="Go-中面相接口编程"><a href="#Go-中面相接口编程" class="headerlink" title="Go 中面相接口编程"></a>Go 中面相接口编程</h3><p>这种编程方式不仅是在 Go 语言中是被推荐的，在几乎所有的编程语言中，我们都会推荐这种编程的方式，它为我们的程序提供了非常强的灵活性，想要构建一个稳定、健壮的 Go 语言项目，不使用接口是完全无法做到的。</p>
<p>如果一个略有规模的项目中没有出现任何 type … interface 的定义，那么作者可以推测出这在很大的概率上是一个工程质量堪忧并且没有多少单元测试覆盖的项目，我们确实需要认真考虑一下如何使用接口对项目进行重构。</p>
<p>事实上官方库也都是按照这个思想来实现的，比如<code>net/http</code>包(对这个包的分析参考 <a href="/2017/07/01/how-golang-webserver-work/">golang 的 webserver 是如何工作的</a>)。当我们要启动一个http server时一般代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个函数的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个参数是<code>Handler</code>类型, 这个函数的类型定义如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义的正是一个接口。这个接口只有一个函数<code>ServeHTTP</code>， 而最终对请求处理调用的也正是这个函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于第二个函数我们一般都会传<code>nil</code>, 所以会执行上面的逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler = DefaultServeMux</span><br></pre></td></tr></table></figure>
<p>而<code>DefaultServeMux</code>就是官方的默认实现。而我们也可以通过传递这个参数来实现自己的处理, 很多Web框架就是怎么做的，比如<code>gin</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    c := engine.pool.Get().(*Context)</span><br><span class="line">    c.writermem.reset(w)</span><br><span class="line">    c.Request = req</span><br><span class="line">    c.reset()</span><br><span class="line"></span><br><span class="line">    engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">    engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gin</code>自己实现了连接的处理方式，并且把这个实现作为参数传给<code>net/http</code>, 具体代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Run</span><span class="params">(addr ...<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; debugPrintError(err) &#125;()</span><br><span class="line"></span><br><span class="line">    address := resolveAddress(addr)</span><br><span class="line">    debugPrint(<span class="string">"Listening and serving HTTP on %s\n"</span>, address)</span><br><span class="line">    err = http.ListenAndServe(address, engine)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现正是前面说讲的: <strong>依赖接口编程</strong>，然后通过<strong>依赖注入</strong>把实例传入</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们有一个<code>user</code>包，里面是处理用户相关的信息, 还有一个<code>bank</code>包，<code>bank</code>会调用<code>user</code>的方法来获取一些用户信息, 刚开始他们的代码实现分别如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">    rows, err := db.Query(sql, uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    name, err := user.UserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在如果我们要给<code>bank</code>的<code>UserInfo</code>添加单元测试应该怎么做呢? 这里有以下几点问题:</p>
<ul>
<li>我们要测试的是<code>bank</code>的<code>UserInfo</code>函数，而不是为了测试这个函数都调用的函数，所以我们其实不太关心<code>user.UserName</code>里面的逻辑</li>
<li>我们要测试<code>UserInfo</code>就必须要从<code>UserName</code>获取一些信息，但是<code>UserName</code>的信息需要调用<code>db</code>才能获取，这里涉及到一些网络访问，会给我们的测试带来很多麻烦</li>
<li>我们需要把<code>UserName</code>给Mock掉<br>关于如何把<code>UserName</code> Mock掉, 其实我们可以借助一些<code>mock</code>的框架(比如<code>bou.ke/monkey</code>)来进行处理， 但是这种方法回避了设计上的一些问题，过度依赖会导致我们的代码质量堪忧，还有一些场景要求我们必须替换这个方法的实现，比如我们不想使用<code>user.UserName</code>的查询方式了，我们换了一种实现，这样我们就无法复用原来的代码了。<br>下面我们介绍如何利用上面介绍的知识来解决这个问题:</li>
</ul>
<h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>我们看一下第二版的代码<br><code>user</code>包:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">        UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DefaultUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">        rows, err := db.Query(sql, uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">                <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bank</code>代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    name, err := u.UserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们都做了那些修改呢?</p>
<ul>
<li>面向接口编程<br>我们定义了一个接口类型<code>User</code>:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">        UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后<code>user</code>包用<code>DefaultUser</code>来实现了这个方法，所以<code>DefaultUser</code>就是这个类型的包了<br><code>bank</code>中定义了一个变量<code>var u = user.New()</code>, 由于<code>user.New()</code>的类型也是<code>User</code>，所以<code>u</code>的类型就是<code>User</code>, 然后在<code>UserInfo</code>函数中调用<code>User</code>类型的<code>UserName</code>方法<br>也就是说<code>user</code>和<code>bank</code>都是面向<code>User</code>来进行编程的</p>
<ul>
<li>依赖注入<br>我们第一个版本是直接调用<code>user.UserName</code>函数, 但是我们无法自己去修改这个函数的实现，所以我们通过<code>var u = user.New()</code>来获取<code>user</code>给我传递的一个对象，这样我们就可以通过<code>u</code>来调用<code>UserName</code>函数了，这时<code>user.New</code>就实现了依赖注入，这样做我们就可以通过覆盖<code>u</code>这个实例，来完成自己的实现了，下面</li>
</ul>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>面对版本二, 我们怎么实现<code>bank.UserInfo</code>的单元测试呢？<br><code>bank_test.go</code>来看一下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u mockUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"John"</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserInfo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    u = mockUser&#123;&#125;</span><br><span class="line">    cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        uid  <span class="keyword">int</span></span><br><span class="line">        res  <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">"test1"</span>, <span class="number">1</span>, <span class="string">"something was wrong"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test2"</span>, <span class="number">2</span>, <span class="string">"not found this user"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test3"</span>, <span class="number">3</span>, <span class="string">"user name is John"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        t.Run(v.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            info := UserInfo(v.uid)</span><br><span class="line">            <span class="keyword">if</span> info != v.res &#123;</span><br><span class="line">                t.Errorf(<span class="string">"got %s; want %s"</span>, info, v.res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go test -v</span><br><span class="line">=== RUN   TestUserInfo</span><br><span class="line">=== RUN   TestUserInfo/test1</span><br><span class="line">=== RUN   TestUserInfo/test2</span><br><span class="line">=== RUN   TestUserInfo/test3</span><br><span class="line">--- PASS: TestUserInfo (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test1 (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test2 (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test3 (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      bank    0.013s</span><br></pre></td></tr></table></figure>
<p>首先我们定义了一个<code>mockUser</code>, 然后实现了<code>UserName</code>函数，所以这时<code>mockUser</code>已经是<code>User</code>类型了，然后我们在测试函数里通过<code>u = mockUser</code>替换掉了运来的<code>var u = user.New()</code>, 这时候在执行<code>UserInfo</code>调用的其实就是<code>mockUser.UserName</code>函数了，完美的完成了我们的单元测试。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>前面我们虽然用依赖注入的方式完成了调用，但是还有一个问题, 当我们依赖注入的时候用的是<code>var u = user.New()</code>的方式来获取的，但是在错综复杂的调用过程中，我们难免会多次调用<code>user.New()</code>函数，而且我们还要共享同一个<code>User</code>， 这时候就要求我们使用工厂模式保证不管多少次调用，返回的都是同一个<code>User</code>, 在上面的代码中其实很好改:<br>我们把<code>user</code>中的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改为下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultUser = DefaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们每次返回的都是<code>user</code>内部的<code>defaultUser</code>这个实例，而这个实例只初始化了一次, 所有通过这个方法获取的实例都是同一个实例</p>
<h4 id="简化调用"><a href="#简化调用" class="headerlink" title="简化调用"></a>简化调用</h4><p>有时候我们会觉得每次调用都通过依赖注入的传递一个对象，会使得调用变的复杂起来，比如本来我们调用的时候只需要<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.UserName()</span><br></pre></td></tr></table></figure></p>
<p>而现在可能我们的调用变成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var u = user.New()</span><br><span class="line">u.UserName()</span><br></pre></td></tr></table></figure></p>
<p>那么我们如何使用更符合<code>go</code>的方式，直接使用包调用而不是每次都传递一个对象呢？我们可以改为下面的方式:<br><code>user</code>的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultUser = DefaultUser&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> definedUser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultUser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">        definedUser = u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DefaultUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">        rows, err := db.Query(sql, uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">                <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> definedUser == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defaultUser.UserName(uid)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> definedUser.UserName(uid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们新增加了一个变量<code>definedUser</code>来表示用户自定义的实例，然后通过<code>SetUser</code>来对其进行复制，我们同时增加了一个包级别的<code>UserName</code>函数，里面的实现会判断如果有<code>definedUser</code>那么我们就是用这个自定义的实现，如果没有我们就调用默认的实现</p>
<p><code>bank</code>的实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        name, err := user.UserName(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bank</code>的实现跟第一个版本一样，如果我们不需要修改默认实现，对于调用来说非常方便，我们不用关系其内部的具体实现。</p>
<p><code>bank_test</code>的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u mockUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"John"</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserInfo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        user.SetUser(mockUser&#123;&#125;)</span><br><span class="line">        cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">                name <span class="keyword">string</span></span><br><span class="line">                uid  <span class="keyword">int</span></span><br><span class="line">                res  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                &#123;<span class="string">"test1"</span>, <span class="number">1</span>, <span class="string">"something was wrong"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"test2"</span>, <span class="number">2</span>, <span class="string">"not found this user"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"test3"</span>, <span class="number">3</span>, <span class="string">"user name is John"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> cases &#123;</span><br><span class="line">                t.Run(v.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        info := UserInfo(v.uid)</span><br><span class="line">                        <span class="keyword">if</span> info != v.res &#123;</span><br><span class="line">                                t.Errorf(<span class="string">"got %s; want %s"</span>, info, v.res)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bank_test</code>由于要对<code>UserName</code>进行Mock, 用自己的实现来替换原来的实现，我们只需要在测试的时候调用<code>SetUser</code>函数，就完成了替换。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a><br><a href="https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html" target="_blank" rel="noopener">面向接口编程详解（一）——思想基础</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://gocn.vip/article/1764" target="_blank" rel="noopener">使用Golang的interface接口设计原则</a><br><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d" target="_blank" rel="noopener">Duck typing in Go</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/05/28/go-scheduler-preemption/"><span>Go 调度器抢占方式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/05/28/go-scheduler-preemption/" rel="bookmark">
        <time class="entry-date published" datetime="2019-05-28T02:35:56.000Z">
          2019-05-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="OS-调度"><a href="#OS-调度" class="headerlink" title="OS 调度"></a>OS 调度</h2><h2 id="Go-调度"><a href="#Go-调度" class="headerlink" title="Go 调度"></a>Go 调度</h2><p>被抢占后把 g 状态从 <code>_Grunning</code> 改为 <code>_Grunnable</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">"bad g status"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">    dropg()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    globrunqput(gp)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Go-调度的问题"><a href="#Go-调度的问题" class="headerlink" title="Go 调度的问题"></a>Go 调度的问题</h2><h3 id="deadloop"><a href="#deadloop" class="headerlink" title="deadloop"></a>deadloop</h3><p>Go的抢占需要依赖函数的调用，只有在函数调用(准确的说是函数调用产生morestack调用的时候)的时候才会进行真正的强占，那么对于下面的这个方式:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个死循环，而且里面没有任何函数调用，也不会进行栈的扩张，所以这个goroutine永远不会被抢占。<br>参考<a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a> 这篇文档的说明，我们看一下具体的问题及解决方案。<br>// todo: 继续完善上篇文章中的例子</p>
<h3 id="deadloop-amp-GC"><a href="#deadloop-amp-GC" class="headerlink" title="deadloop &amp; GC"></a>deadloop &amp; GC</h3><p>还有这样一个<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">88</span> &#123;</span><br><span class="line">                runtime.GC()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// the wrong part</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">                sum += &lt;-ch</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序也会hang死。</p>
<p>下面这段代码在主goroutine中运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// the wrong part</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">            sum += &lt;-ch</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序由于没有函数的调用和<code>Goshced()</code>的主动调用所以会通过<code>阻塞监控</code>的方式被动弃权。</p>
<h4 id="runtime-GC"><a href="#runtime-GC" class="headerlink" title="runtime.GC"></a>runtime.GC</h4><p>当执行 <code>runtime.GC()</code>的时候都发生了什么？我们来看一下<br>通过<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">dlv</a>这个工具我们可以对这个程序进行断点调试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv debug go run gc.go</span><br></pre></td></tr></table></figure></p>
<p>函数会执行到 <code>stopTheWorldWithSema</code> 这个函数，这个函数主要作用是停止所有的P，然后进行垃圾回收，我们通过一步一步调试发现, 这个函数会下面这个循环中无法出来:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么会在这个地方无法出来？下面分析一下具体原因。</p>
<p>GC种一个步骤是要把所有的 p 都设置为<code>_Pgcstop</code> 状态后才能继续进行。 下面看看这个步骤是否能够完成。</p>
<p><code>stopTheWorldWithSema</code>函数更加详细的执行过程如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we hold a lock, then we won't be able to stop another M</span></span><br><span class="line">    <span class="comment">// that is blocked trying to acquire the lock.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"stopTheWorld: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.stopwait = gomaxprocs <span class="comment">// 设置stopwait的初始值为最大的 p 的个数</span></span><br><span class="line">    atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>) <span class="comment">// 设置 gcwaiting = 1, 表示正在进入GC状态</span></span><br><span class="line">    preemptall() <span class="comment">// 给所有的 p 发送抢占信号，如果成功，则对应的 p 进入 idle 状态</span></span><br><span class="line">    <span class="comment">// stop current P</span></span><br><span class="line">    _g_.m.p.ptr().status = _Pgcstop <span class="comment">// Pgcstop is only diagnostic.</span></span><br><span class="line">    sched.stopwait-- <span class="comment">// 给他当前的设置状态后，stopwait个数减一 </span></span><br><span class="line">    <span class="comment">// try to retake all P's in Psyscall status</span></span><br><span class="line">    <span class="comment">// 遍历所有的 p 如果满足条件(p的状态为 _Psyscall)则释放这个 p , 并且把 p 的状态都设置成 _Pgcstop ; 然后stopwait--</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := p.status</span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                traceGoSysBlock(p)</span><br><span class="line">                traceProcStop(p)</span><br><span class="line">            &#125;</span><br><span class="line">            p.syscalltick++</span><br><span class="line">            sched.stopwait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stop idle P's</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := pidleget() <span class="comment">//获取idle 状态的 p, 从 _Pidle list 获取</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        p.status = _Pgcstop <span class="comment">// 把 p 状态设置为 _Pgcstop</span></span><br><span class="line">        sched.stopwait-- <span class="comment">// 计数 stopwait --</span></span><br><span class="line">    &#125;</span><br><span class="line">    wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                noteclear(&amp;sched.stopnote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再次给所有的 p 发送 抢占信号</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面函数把所有非<code>_Prunning</code>状态的 p 都设置为了 <code>_Pgcstop</code> 状态，对于 <code>_Prunning</code> 状态的 p 如何设置其为 <code>_Pgcstop</code> 状态呢? 主要是通过 <code>preemptall()</code>函数给每个 p 发送抢占信号<br><code>preemptall()</code> 其实时调用了 <code>preemptone()</code> 前面我们已经讲了具体的原理。被抢占后 p 重新进入调度阶段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        stoplockedm()</span><br><span class="line">        execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不应该调度一个正在执行 cgo 调用的 g</span></span><br><span class="line">    <span class="comment">// 因为 cgo 在使用当前 m 的 g0 栈</span></span><br><span class="line">    <span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line">    <span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">        throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果还在等待 gc，则</span></span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top <span class="comment">// 循环执行</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面说调度器会会把 <code>gcwaiting</code>设置为<code>1</code>, 所以这里会进入 <code>gcstopm()</code>, 直到所有的 m 都被<code>stop</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcstopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"gcstopm: not waiting for gc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// OK to just drop nmspinning here,</span></span><br><span class="line">        <span class="comment">// startTheWorld will unpark threads as necessary.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"gcstopm: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _p_ := releasep()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    _p_.status = _Pgcstop <span class="comment">//设置 p 状态为 _Pgcstop</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">        notewakeup(&amp;sched.stopnote)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>gcstopm()</code> 会把 p 的状态置为 <code>_Pgcstop</code>。</p>
<p><strong>但是死循环的 g 不会被抢占，所以其 p 状态会一直是  Prunning 无法被设置为 Pgcstop</strong></p>
<p>再回到前面进入死循环的地方:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里进入死循环的原因是条件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) == <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>不满足<br><code>notetsleep</code>函数内部每隔一段时间就会返回:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> atomic.Load(key32(&amp;n.key)) != <span class="number">0</span> <span class="comment">// n.key 为参数 &amp;shced.stopnote.key的值</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数意思是<code>&amp;sched.stopnote.key != 0</code><br>如果要想让返回值为 <code>true</code> 就需要满足上面的条件。 <code>stopnote.key</code>的值有两个函数可以控制:</p>
<ul>
<li><code>notewakeup</code> 把 <code>stopnote</code> 设置为 1</li>
<li><code>noteclear 把</code>stopnote<code>设置为 0
所以我们需要调用</code>notewakeup<code>才行。而这个函数我们可以看到是在</code>gcstopm()`种有调用:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sched.stopwait--</span><br><span class="line"><span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">    notewakeup(&amp;sched.stopnote)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于存在 g 无法被抢占，所以其对应的 p 不会释放, <code>stopwait</code>也就不能为<code>0</code>, 所以也就无法执行<code>notewakeup</code>,最终导致上面的循环无法出来。</p>
<p>死锁状态的发生:</p>
<ul>
<li>GC: 要想进行<code>GC</code>就需要所有的P都转为空闲状态，而主<code>goroutine</code>无法被抢占，对应的<code>P</code>也无法进入空闲。所以<code>GC</code>会一直阻塞。</li>
<li>新启动的<code>goroutine</code>: 由于新启动的<code>goroutine</code>也进入了空闲状态</li>
<li>主<code>goroutine</code>: 由于新启动的<code>goroutine</code>进入了空闲状态,无法再给<code>chan</code>发信号，所以主<code>goroutine</code>也无法退出。<br>由于上面三个都进入了阻塞状态，导致了整个程序进入了死锁状态。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html" target="_blank" rel="noopener">scheduling-in-go-part1</a><br><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html" target="_blank" rel="noopener">scheduling-in-go-part2</a><br><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html" target="_blank" rel="noopener">scheduling-in-go-part3</a><br><a href="https://github.com/two/go-under-the-hood/blob/master/book/part2runtime/ch06sched/preemptive.md" target="_blank" rel="noopener">go-under-the-hood</a><br><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">non-cooperative-preemption</a><br><a href="https://gocn.vip/article/441" target="_blank" rel="noopener">如何定位 golang 进程 hang 死的 bug</a><br><a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/"><span>【译】 Go 语言机制之栈和指针 (1)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-04T05:29:19.000Z">
          2019-03-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列的文章主要是帮助你理解指针，栈，堆，逃逸分析和值/指针语义的设计和机制。本系列一共有四篇，这是第一篇。本篇主要是介绍栈和指针。</p>
<p>本系列文章索引:<br>1) Go 语言机制之栈和指针<br>2) Go 语言机制之逃逸分析<br>3) Go 语言机制之内存性能分析<br>4) Go 语言机制之数据和语义的使用原则</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我并不打算美化指针，因为指针真的很难理解。如果我们使用不当，指针能够产生很难理解的 bug 甚至影响性能。 在写并发程序或者多线程程序时这种问题更为明显。这也难怪很多语言试图对开发者隐藏指针的使用。尽管如此，如果你是用 Go 来开发程序，你是没有办法避免使用指针的。相对于深入的理解指针，你更应该关注如何写出干净，简单并且有效的代码。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/01/golang-http-client-connection-pool/"><span>golang http client 连接池</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/01/golang-http-client-connection-pool/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-01T02:44:03.000Z">
          2018-06-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>golang标准库<code>net/http</code>做为<code>client</code>时有哪些细节需要注意呢，这里做一个详细的分析。</p>
</blockquote>
<h2 id="net-http-client工作流程"><a href="#net-http-client工作流程" class="headerlink" title="net/http client工作流程"></a>net/http client工作流程</h2><p>首先分析一下<code>client</code>的工作流程。 下面是一般我们进行一个请求时的代码事例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoRequest</span><span class="params">(req *http.Request)</span> <span class="params">(MyResponse, error)</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response := MyResponse&#123;&#125;</span><br><span class="line">    response.Header = resp.Header</span><br><span class="line">    ...</span><br><span class="line">    response.Body = body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们首先创建一个<code>http.Client</code>, 所有的值都是默认值，然后调用<code>client.Do</code>发请求，<code>req</code>是我们请求的结构体。这里我们也可以用<code>client.Get</code>, <code>client.Post</code>等函数来调用，从他们的源码来看都是调用的<code>client.Do</code>。<br><code>client.Do</code>的实现在<code>net/http</code>包的<code>go/src/net/http/client.go</code>源文件中。可以看到函数内部主要是实现了一些参数检查，默认值设置，以及对于多跳请求的处理，最为核心的就是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// c.send() always closes req.Body</span></span><br><span class="line">            reqBodyClosed = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">                err = &amp;httpError&#123;</span><br><span class="line">                    err:     err.Error() + <span class="string">" (Client.Timeout exceeded while awaiting headers)"</span>,</span><br><span class="line">                    timeout: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shouldRedirect <span class="keyword">bool</span></span><br><span class="line">redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !shouldRedirect &#123;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里真正发请求的函数就是<code>c.send</code>, 这个函数的实现也比较简单, 主要是调用了<code>send</code>函数，这个函数的实现主要如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// didTimeout is non-nil only if err != nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send issues an HTTP request.</span></span><br><span class="line"><span class="comment">// Caller should close resp.Body when done reading from it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line">    ...</span><br><span class="line">        resp, err = rt.RoundTrip(req)</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里真正进行网络交互的定位到的函数是<code>rt.RoundTrip</code>,这个函数的定义是一个<code>interface</code>，从其注释也可以看出他的主要作用是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// RoundTrip executes a single HTTP transaction, returning</span><br><span class="line">// a Response for the provided Request.`</span><br></pre></td></tr></table></figure></p>
<p>由于这个函数是一个<code>interface</code>我们需要知道是谁实现了这个函数，看一下<code>send</code>的参数就可以找到，实现这个函数的是<code>c.transport()</code>的返回值，这个函数的实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到，返回的对象是<code>c.Transport</code>或者<code>DefaultTransport</code>, 由于我们创建<code>client</code>的时候没有设置<code>c.Transport</code>参数，所以这里返回的应该是<code>DefaultTransport</code>对象, 这个对象对<code>RoundTripper</code>函数的实现大概如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip implements the RoundTripper interface.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For higher-level HTTP client support (such as handling of cookies</span></span><br><span class="line"><span class="comment">// and redirects), see Get, Post, and the Client type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">                pconn, err := t.getConn(treq, cm)</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// HTTP/2 path.</span></span><br><span class="line">                    t.setReqCanceler(req, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">                        resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp, err = pconn.roundTrip(treq)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面具体的细节我们先不关系，对于<code>HTTP/2</code>的处理我们也先不关心。这里需要重点关注的是<code>t.getConn</code>这个函数。<code>t.getConn</code>的作用是获取一个链接，这个链接该怎么获取，是一个值得深究的问题。下面看一下这个函数的关键实现细节:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getConn dials and creates a new persistConn to the target as</span></span><br><span class="line"><span class="comment">// specified in the connectMethod. This includes doing a proxy CONNECT</span></span><br><span class="line"><span class="comment">// and/or setting up TLS.  If this doesn't return an error, the persistConn</span></span><br><span class="line"><span class="comment">// is ready to write requests to.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">req := treq.Request</span><br><span class="line">         trace := treq.trace</span><br><span class="line">         ctx := req.Context()</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GetConn(cm.addr())</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">if</span> pc, idleSince := t.getIdleConn(cm); pc != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GotConn(pc.gotIdleConnTrace(idleSince))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// set request canceler to some non-nil function so we</span></span><br><span class="line">         <span class="comment">// can detect whether it was cleared between now and when</span></span><br><span class="line">         <span class="comment">// we enter roundTrip</span></span><br><span class="line">         t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;&#125;)</span><br><span class="line">             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">         handlePendingDial := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             testHookPrePendingDial()</span><br><span class="line">                 <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> v := &lt;-dialc; v.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                         t.putOrCloseIdleConn(v.pc)</span><br><span class="line">                     &#125;</span><br><span class="line">                     testHookPostPendingDial()</span><br><span class="line">                 &#125;()</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">cancelc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">             t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123; cancelc &lt;- err &#125;)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                 pc, err := t.dialConn(ctx, cm)</span><br><span class="line">                     dialc &lt;- dialRes&#123;pc, err&#125;</span><br><span class="line">             &#125;()</span><br><span class="line">idleConnCh := t.getIdleConnCh(cm)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> v := &lt;-dialc:</span><br><span class="line">                            <span class="comment">// Our dial finished.</span></span><br><span class="line">                            <span class="keyword">if</span> v.pc != <span class="literal">nil</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &amp;&amp; v.pc.alt == <span class="literal">nil</span> &#123;</span><br><span class="line">                                    trace.GotConn(httptrace.GotConnInfo&#123;Conn: v.pc.conn&#125;)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> v.pc, <span class="literal">nil</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Our dial failed. See why to return a nicer error</span></span><br><span class="line">                            <span class="comment">// value.</span></span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                    <span class="comment">// It was an error due to cancelation, so prioritize that</span></span><br><span class="line">                                    <span class="comment">// error value. (Issue 16049)</span></span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                                <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                                          <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                              err = errRequestCanceledConn</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                              <span class="comment">// It wasn't an error due to cancelation, so</span></span><br><span class="line">                                              <span class="comment">// return the original error message:</span></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">nil</span>, v.err</span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="keyword">case</span> pc := &lt;-idleConnCh:</span><br><span class="line">                             <span class="comment">// Another request finished first and its net.Conn</span></span><br><span class="line">                             <span class="comment">// became available before our dial. Or somebody</span></span><br><span class="line">                             <span class="comment">// else's dial that they didn't use.</span></span><br><span class="line">                             <span class="comment">// But our dial is still going, so give it away</span></span><br><span class="line">                             <span class="comment">// when it finishes:</span></span><br><span class="line">                             handlePendingDial()</span><br><span class="line">                                 <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">                                     trace.GotConn(httptrace.GotConnInfo&#123;Conn: pc.conn, Reused: pc.isReused()&#125;)</span><br><span class="line">                                 &#125;</span><br><span class="line">                             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                 handlePendingDial()</span><br><span class="line">                                     <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                     handlePendingDial()</span><br><span class="line">                                         <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                    <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                              handlePendingDial()</span><br><span class="line">                                  <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                      err = errRequestCanceledConn</span><br><span class="line">                                  &#125;</span><br><span class="line">                              <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是这个过程的流程图:<br><img src="http://www.plantuml.com/plantuml/svg/NP3DYi8m58NNvYcohA-WIv-as5I39HbCD-vcm9_IHHsm54P1Pa2NC-fcb2deopHf-XRUDjQ1XcnoxpddVhd2jyS-eYwsiZJIjwsAzkhqgQEpN2R5wWhFDlQ7X65hGaGROJWTVOlbPckwNKGyGR35UDbq-NY4MXqPR6JwfvAZ2UmQcmf3ur7nLGR7_EUhU5ivrFRwsUNxeG68kc8O_XFAR6mFRCfW0kYCdpeUwN76UiE6HGPhkCKYX6dvUbhJrYG0PoYXz_XsHVLSWGeI_JhhUroGnlGgGiv-ipGfuWzzECZTD7-Vboh27BC3KE36cfX3NIHy_d87"><br>从上面可以看到，获取链接会优先从连接池中获取，如果连接池中没有可用的连接，则会创建一个连接或者从刚刚释放的连接中获取一个，这两个过程时同时进行的，谁先获取到连接就用谁的。<br>当新创建一个连接, 创建连接的函数定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error)</span><br></pre></td></tr></table></figure></p>
<p>最后这个函数会通过goroutine调用两个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go pconn.readLoop()</span><br><span class="line">go pconn.writeLoop()</span><br></pre></td></tr></table></figure></p>
<p>其中<code>readLoop</code>主要是读取从server返回的数据,<code>writeLoop</code>主要发送请求到server,在<code>readLoop</code>函数中有这么一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Put the idle conn back into the pool before we send the response</span><br><span class="line">// so if they process it quickly and make another request, they&apos;ll</span><br><span class="line">// get this same conn. But we use the unbuffered channel &apos;rc&apos;</span><br><span class="line">// to guarantee that persistConn.roundTrip got out of its select</span><br><span class="line">// potentially waiting for this persistConn to close.</span><br><span class="line">// but after</span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">    pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br></pre></td></tr></table></figure></p>
<p>这里可以看出，在处理完请求后，会立即把当前连接放到连接池中。</p>
<p>上面说到连接池，每个<code>client</code>的连接池结构是这样的:<code>idleConn   map[connectMethodKey][]*persistConn</code>。其中<code>connectMethodKey</code>的值就是<code>client</code>连接的server的<code>host</code>值, map的值是一个<code>*persistConn</code>类型的<code>slice</code>结构，这里就是存放连接的地方，<code>slice</code>的长度由<code>MaxIdleConnsPerHost</code>这个值指定的，当我们不设置这个值的时候就取默认的设置:<code>const DefaultMaxIdleConnsPerHost = 2</code>。</p>
<p>另外这里我们插一个知识点，对于HTTP协议，有一个header值”Connections”, 这个值的作用就是<code>client</code>向<code>server</code>端发请求的时候，告诉<code>server</code>是否要保持连接。具体的可以参考<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank" rel="noopener">rfc2616</a>。 这个协议头的值有两种可能(参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">MDN文档</a>):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p>
<p>当值为<code>keep-alive</code>时，<code>server</code>端会保持连接，一直到连接超时。当值为<code>close</code>时,<code>server</code>端会在传输完<code>response</code>后主动断掉<code>TCP</code>连接。在<code>HTTP/1.1</code>之前，这个值默认是<code>close</code>, 之后是默认<code>keep-alive</code>, 而<code>net/http</code>默认的协议是<code>HTTP/1.1</code>也就是默认<code>keep-alive</code>, 这个值可以通过<code>DisableKeepAlives</code>来设置。</p>
<p>从上面的介绍我们可以看出，<code>net/http</code>默认是连接复用的，对于每个server会默认的连接池大小是2。<br>接下来我们看一下连接是如何放进连接池的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">putOrCloseIdleConn</span><span class="params">(pconn *persistConn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span></span><br><span class="line"><span class="comment">// a new request.</span></span><br><span class="line"><span class="comment">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span></span><br><span class="line"><span class="comment">// an error explaining why it wasn't registered.</span></span><br><span class="line"><span class="comment">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errKeepAlivesDisabled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.isBroken() &#123;</span><br><span class="line">        <span class="keyword">return</span> errConnBroken</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errNotCachingH2Conn</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.markReused()</span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line"></span><br><span class="line">    t.idleMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> t.idleMu.Unlock()</span><br><span class="line">    waitingDialer := t.idleConnCh[key]</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> waitingDialer &lt;- pconn:</span><br><span class="line">        <span class="comment">// We're done with this pconn and somebody else is</span></span><br><span class="line">        <span class="comment">// currently waiting for a conn of this type (they're</span></span><br><span class="line">        <span class="comment">// actively dialing, but this conn is ready</span></span><br><span class="line">        <span class="comment">// first). Chrome calls this socket late binding. See</span></span><br><span class="line">        <span class="comment">// https://insouciant.org/tech/connection-management-in-chromium/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> waitingDialer != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// They had populated this, but their dial won</span></span><br><span class="line">            <span class="comment">// first, so we can clean up this map entry.</span></span><br><span class="line">            <span class="built_in">delete</span>(t.idleConnCh, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.wantIdle &#123;</span><br><span class="line">        <span class="keyword">return</span> errWantIdle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.idleConn == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.idleConn = <span class="built_in">make</span>(<span class="keyword">map</span>[connectMethodKey][]*persistConn)</span><br><span class="line">    &#125;</span><br><span class="line">    idles := t.idleConn[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(idles) &gt;= t.maxIdleConnsPerHost() &#123;</span><br><span class="line">        <span class="keyword">return</span> errTooManyIdleHost</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, exist := <span class="keyword">range</span> idles &#123;</span><br><span class="line">        <span class="keyword">if</span> exist == pconn &#123;</span><br><span class="line">            log.Fatalf(<span class="string">"dup idle pconn %p in freelist"</span>, pconn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    t.idleLRU.add(pconn)</span><br><span class="line">    <span class="keyword">if</span> t.MaxIdleConns != <span class="number">0</span> &amp;&amp; t.idleLRU.<span class="built_in">len</span>() &gt; t.MaxIdleConns &#123;</span><br><span class="line">        oldest := t.idleLRU.removeOldest()</span><br><span class="line">        oldest.<span class="built_in">close</span>(errTooManyIdle)</span><br><span class="line">        t.removeIdleConnLocked(oldest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IdleConnTimeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pconn.idleTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">            pconn.idleTimer.Reset(t.IdleConnTimeout)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.idleAt = time.Now()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会尝试把连接放入到连接池中，如果不成功则<code>关闭连接</code>,大致流程如下:<br><img src="http://www.plantuml.com/plantuml/svg/XP5FJy8m6CRl-nGzmispauEHWyQO-1LgU8UDIsVMuf-4WqOM5rHYuX914m864gC1528I8F9brcux-HMS82Cxg3sqJVi-lxvF7yQnoHMYeKIQCBoZmoR0_gfE3e2XL0fnCmSedqTR-6WZeyEQGIdR1dFTO1ojeAKauhj0KU8OM591uLWMLY-uRVcJgYmrLGLq1YX1ZVcbVIz6GtTmuWwUl7OzEBqvn8GJcaqJh8FfEO_ki1GAfTFtdY_4LIyuBqhdmxih-6y5ERnMqPIZ6URUT3E5kkEoi6nPBCuU3Uk5rHJsImpj3bhgGX9lSduCD1FX4SvYGXUA36WuftDXru9A8qRs9vN8pUVuCYXtPUiXA8z4lQh-YXDMNxJF0gVYTpgXwEz-mZLo_1tKZy_NcdZlob7zlmnYg7WUix-AU54jqPHe_W80"><br>如果<code>DisableKeepAlives</code>为<code>true</code>表示不使用连接复用，所以请求完后会把连接关掉，但是这里需要注意的是，同时发请求的时候我们会设置<code>Connections: close</code>, 所以<code>server</code>端发送完数据后就会自动断开，所以这种情况的连接其实是<code>server</code>端发起的。</p>
<h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>前面我们已经讲过<code>net/http</code>默认使用<code>HTTP/1.1</code>协议，也就是默认发送<code>Connections: keep-alive</code>的头，让服务端保持连接，就是所谓的长连接。<br>再看<code>DefaultTransport</code>的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// DefaultTransport is the default implementation of Transport and is</span><br><span class="line">// used by DefaultClient. It establishes network connections as needed</span><br><span class="line">// and caches them for reuse by subsequent calls. It uses HTTP proxies</span><br><span class="line">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and</span><br><span class="line">// $no_proxy) environment variables.</span><br><span class="line">var DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment, //代理使用</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   30 * time.Second, //连接超时时间</span><br><span class="line">        KeepAlive: 30 * time.Second, //连接保持超时时间</span><br><span class="line">        DualStack: true, //</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    MaxIdleConns:          100, //client对与所有host最大空闲连接数总和</span><br><span class="line">    IdleConnTimeout:       90 * time.Second, //空闲连接在连接池中的超时时间</span><br><span class="line">    TLSHandshakeTimeout:   10 * time.Second, //TLS安全连接握手超时时间</span><br><span class="line">    ExpectContinueTimeout: 1 * time.Second, //发送完请求到接收到响应头的超时时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用<code>DefaultTransport</code>时，就是默认使用的长连接。但是默认的连接池<code>MaxIdleConns</code>为100， <code>MaxIdleConnsPerHost</code>为2，当超出这个范围时，客户端会主动关闭到连接。<br>如果我们想设置为短连接，有几种方法:</p>
<ol>
<li>设置<code>DisableKeepAlives = true</code>: 这时就会发送<code>Connections:close</code>给server端，在server端响应后就会主动关闭连接。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>: 当<code>MaxIdleConnsPerHost &lt; 0</code>时，连接池是无法放置空闲连接的，所以无法复用,连接直接会在<code>client</code>端被关闭。</li>
</ol>
<h2 id="Server端出现大量的TIME-WAIT"><a href="#Server端出现大量的TIME-WAIT" class="headerlink" title="Server端出现大量的TIME_WAIT"></a>Server端出现大量的<code>TIME_WAIT</code></h2><p>当我们在实际使用时，会发现<code>Server</code>端出现了大量的<code>TIME_WAIT</code>,要想深入了解其原因，我们首先先回顾一下<code>TCP</code>三次握手和四次分手的过程:<br><img src="/assets/img/golang/tcp_3_handshake.png" alt><br><img src="/assets/img/golang/tcp_4_handshake.png" alt><br>图中可以看出，<code>TIME_WAIT</code>只会出现在主动关闭连接的一方,也就是<code>server</code>端出现了大量的主动关闭行为。<br>默认我们是使用长连接的，只有在超时的情况下<code>server</code>端才会主动关闭连接。前面也讲到，如果超出连接池的部分就会在<code>client</code>端主动关闭连接，连接池的连接会复用，看着似乎没有什么问题。问题出在我们每次请求都会<code>new</code>一个新的<code>client</code>,这样每个<code>client</code>的连接池里的连接并没有得到复用，而且这时<code>client</code>也不会主动关闭这个连接，所以<code>server</code>端出现了大量的<code>keep-alive</code>但是没有请求的连接，就会主动发起关闭。</p>
<p>todo:补充tcpdump的分析结果</p>
<p>要解决这个问题以下几个方案:</p>
<ol>
<li><code>client</code>复用，也就是我们尽量复用<code>client</code>，来保证<code>client</code>连接池里面的连接得到复用，而减少出现超时关闭的情况。</li>
<li>设置<code>MaxIdleConnsPerHost &lt; 0</code>：这样每次请求后都会由<code>client</code>发起主动关闭连接的请求，<code>server</code>端就不会出现大量的<code>TIME_WAIT</code></li>
<li><p>修改<code>server</code>内核参数: 当出现大量的<code>TIME_WAIT</code>时危害就是导致<code>fd</code>不够用,无法处理新的请求。我们可以通过设置<code>/etc/sysctl.conf</code>文件中的</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>
<p> 达到快速回收和重用的效果，不影响其对新连接的处理。</p>
</li>
</ol>
<p>另外需要注意的是，虽然<code>DisableKeepAlives = true</code>也能满足连接池中不放空闲连接，但是这时候会发送<code>Connections: close</code>，这时<code>server</code>端还是会主动关闭连接，导致大量的<code>TIME_WAIT</code>出现，所以这种方法行不通。</p>
<p>以上就是我总结的关于<code>net/http</code>中连接池相关的知识。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/03/the-core-technology-of-high-traffic-website/"><span>亿级流量网站架构核心技术总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/03/the-core-technology-of-high-traffic-website/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-03T05:27:30.000Z">
          2017-08-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近读了《亿级流量网站架构核心技术——跟开涛学搭建高可用高并发系统》这本书，总体感觉这本书很实用，作者根据自己负责的项目经历以及业务的发展过程和业界的理论基础相结合讲解了如何搭建一个具有高并发和高可用特征的电商网站。作者是京东的架构师，进来随着京东业务的不断发展，6.18和双十一活动规模的不断扩大，作者都亲身经历了整个电商网站的发展过程，相对于单纯的理论，这本书更多的是能够在业务中快速应用的经验总结。下面就这两方面我把作者的思维导图搬过来，不断提醒自己要注意的整体思想，并能够深入浅出，根据思维导图的每一项都有一个自己更发散更深入的认识。</p>
</blockquote>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><img src="/assets/img/cthtw/High-availability.png" alt="高可用"></p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="/assets/img/cthtw/High-concurrency.png" alt="高并发"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/java/">java</a><a href="/tags/架构/">架构</a><a href="/tags/高并发/">高并发</a><a href="/tags/高可用/">高可用</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/12/golang-goroutines-1/"><span>golang channels 的串联,扇入扇出及控制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/12/golang-goroutines-1/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-12T02:06:03.000Z">
          2017-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。 一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。 channel之间可以进行串联，并联等组合，组成我们想要的运行方式。 不同goroutine之间需要同步，也需要控制，具体该如何处理这些情况，下面分别进行介绍。</p>
</blockquote>
<h2 id="channel基础"><a href="#channel基础" class="headerlink" title="channel基础"></a>channel基础</h2><p>使用内置的make函数，我们可以创建一个channel:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type 'chan int'</span></span><br></pre></td></tr></table></figure></p>
<p>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。<br>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。<br>一个channel有发送和接受两个主要操作，都是通信行为。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch     <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure></p>
<p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></table></figure></p>
<p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的Channels</h3><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。<br>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。</p>
<p>对于不带缓存的Channels，我们使用的是有必须放到goroutine,因为如果直接调用<code>chanx &lt;- 1</code>时，会报错<code>fatal error: all goroutines are asleep - deadlock!</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chanx &lt;- <span class="number">1</span> <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p>
<p>由于主goroutine调用了 <code>chanx &lt;-1</code>, 但是由于是顺序往下执行，执行时还不存在监听<code>chanx</code>的方法存在，所以数据放入<code>chanx</code>后无法唤醒接收的方法，只能等待下去，所以就产生了deadlock。<br>可以修改为下面的形式，把<code>chanx &lt;- 1</code>放入到一个goroutine里，然后主goroutine监听了这个<code>chanx</code>，当往<code>chanx</code>放数据的时候就会有接收的方法被调用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;chanx &lt;- <span class="number">1</span>&#125;() <span class="comment">//right</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p>
<p><strong>当使用<code>range</code>遍历<code>chan</code>时别忘了close</strong>, 下面当没有使用close时:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>output:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive]:</span><br></pre></td></tr></table></figure></p>
<p><code>range</code>会从<code>channel</code>中接收数据直到<code>channel</code>被<code>close</code>为止，正常情况下<code>close</code>并不是必须的，只有在接收者需要知道没有更多的数据进入的时候才需要，而<code>range</code>正是需要知道这个信息的。所以代码改成下面这样就没问题了:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(chanx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="带缓存的Channels"><a href="#带缓存的Channels" class="headerlink" title="带缓存的Channels"></a>带缓存的Channels</h3><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p>
<p><strong>队列元素为1的带缓存Channels与不带缓存的Channels是不同的</strong>，下面的例子可以看出:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan_nobuffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan_nobuffer &lt;- <span class="number">1</span> <span class="comment">//error 必须放到goroutine中</span></span><br><span class="line">    &lt;-chan_nobuffer</span><br><span class="line"></span><br><span class="line">    chan_buffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    chan_buffer &lt;- <span class="number">1</span> <span class="comment">//right</span></span><br><span class="line">    &lt;-chan_buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><p>channel还有两种语法:<code>&lt;-chan int</code>和<code>chan&lt;- int</code>，其意思是单方向的channel, 当定义为<code>out chan&lt;- int</code>表示<code>out</code>只能被往里面放数据，不允许从out拿数据,否则程序会报错<code>receive from send-only type chan&lt;- int</code>,如果定义为<code>in &lt;-chan int</code>则<code>in</code>只能往外输出数据，不允许往<code>in</code>里面放数据，否则报错<code>send to receive-only type &lt;-chan int</code></p>
<h2 id="channel串联"><a href="#channel串联" class="headerlink" title="channel串联"></a>channel串联</h2><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。 这种串联的Channels就是所谓的管道（pipeline）。下图就是一个串联的channel示意:<br><img src="/assets/img/golang/goroutines_0712_1.png" alt="串联channel"><br>第一个goroutine Counter负责生成一个0,1,2,3,…形式的整数序列,然后把整数序列输入到一个channel中，通过这个channel传递个下一个goroutine Squarer, 负责将从channel接收到的数求平方，然后再把得出的结果通过channel传递给goroutine Printer, Printer负责将从channel接收的数据打印出来。<br>其程序实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> Counter(chan1)</span><br><span class="line">    <span class="keyword">go</span> Squarer(chan2, chan1)</span><br><span class="line">    Printer(chan2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中我们创建了两个chan, 然后调用了<code>Counter</code>和<code>Squarer</code>, 由于上面说:<strong>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。</strong>所以我们对chan1和chan2的修改都是全局的。<br><code>Counter</code>往chan1中陆续放入了<code>0,1,2,3,...</code>等数列，然后同步的<code>Squarer</code>接收到数据对其平方并放入<code>chan2</code>,最后<code>Printer</code>从<code>chan2</code>中输出这些数据。<br>对于串联的Channel还有另外一种实现方法:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    out := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            out &lt;- n*n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>gen</code>函数用到了golang的<strong>可变参数</strong>这个特性，跟上面的<code>Counter</code>不一样的是，这个<code>gen</code>会把<code>chan</code>当做返回值返回，而不是作为参数传入。<code>sq</code>函数也跟<code>Squarer</code>函数不一样了:把上一个函数的chan最为参数，下一个输出的chan作为返回值。</p>
<h2 id="channel扇入扇出"><a href="#channel扇入扇出" class="headerlink" title="channel扇入扇出"></a>channel扇入扇出</h2><p><strong>扇出</strong>：同一个 channel 可以被多个函数读取数据，直到channel关闭。 这种机制允许将工作负载分发到一组worker，以便更好地并行使用 CPU 和 I/O。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    c1 := sq(c)</span><br><span class="line">    c2 := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c1 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"-------------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c2 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是几种输出样式，可以知道当调用两次<code>sq</code>时，其实是对chan的扇出操作，既一个channel被多个函数读取了。每次读取的顺序和个数都不能保证。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span> </span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">9</span></span><br><span class="line">#<span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">------------------</span><br><span class="line">#<span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong>扇入</strong>：多个 channel 的数据可以被同一个函数读取和处理，然后合并到一个 channel，直到所有 channel都关闭。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed, then calls wg.Done.</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            out &lt;- n <span class="comment">//对于每个chan其中的元素都放到out中 </span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done() <span class="comment">//减少一个goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs)) <span class="comment">//要执行的goroutine个数</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        <span class="keyword">go</span> output(c) <span class="comment">//对传入的多个channel执行output</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a goroutine to close out once all the output goroutines are</span></span><br><span class="line">    <span class="comment">// done.  This must start after the wg.Add call.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait() <span class="comment">//等待，直到所有goroutine都完成后</span></span><br><span class="line">        <span class="built_in">close</span>(out) <span class="comment">//所有的都放到out后关闭</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>merge</code>函数的参数也是变长的，类型是<code>chan</code>, 这个函数还用到了<code>sync</code>这个包，这里主要的作用就是对一组goroutines进行同步。首先把传入的cs都通过<code>output</code>调用放入<code>out</code>中，每处理完一个<code>c</code>就调用<code>wg.Done()</code>更新剩余的次数, <code>wg.Wait()</code>等到所有的channels把数据放到<code>out</code>中，然后关闭<code>out</code>。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    out2 := sq(c)</span><br><span class="line">    out1 := sq(c)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> merge(out1, out2) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图就展示了扇入扇出的过程:<br><img src="/assets/img/golang/goroutines_0712_2.png" alt="串联channel"></p>
<h2 id="goroutines控制"><a href="#goroutines控制" class="headerlink" title="goroutines控制"></a>goroutines控制</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">The Go Blog - pipelines</a></li>
<li><a href="https://segmentfault.com/a/1190000006261218" target="_blank" rel="noopener">Go语言并发模型：像Unix Pipe那样使用channel</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-04.html" target="_blank" rel="noopener">Go语言圣经-channels</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-05.html" target="_blank" rel="noopener">Go语言圣经-并发的循环</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch5/ch5-07.html" target="_blank" rel="noopener">Go语言圣经-可变参数</a></li>
<li><a href="https://deepzz.com/post/golang-context-package-notes.html" target="_blank" rel="noopener">快速掌握 Golang context 包</a></li>
<li><a href="https://tour.golang.org/concurrency/4" target="_blank" rel="noopener">A Tour of Go - Range and Close</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goroutines/">goroutines</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/01/how-golang-webserver-work/"><span>golang的webserver是如何工作的</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/01/how-golang-webserver-work/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-01T01:29:38.000Z">
          2017-07-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>我们知道golang实现一个webserver非常简单，但是其内部是如何工作的呢，我们深入探究一下其原理。</p>
</blockquote>
<h2 id="实现一个webserver服务"><a href="#实现一个webserver服务" class="headerlink" title="实现一个webserver服务"></a>实现一个webserver服务</h2><p>下面我们就用golang内置的服务实现一个简单的webserver:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        r.ParseForm()       <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">        fmt.Println(r.Form) <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">        fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">        fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">        fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">                fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">                fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        http.HandleFunc(<span class="string">"/hello"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过<code>go run main.go</code>来开启Server服务, 当我们访问<code>http://localhost:8090/</code>或<code>http://localhost:8090/hello</code>都会得到<code>Hello astaxie!</code>, 也就是都执行了<code>sayhelloName</code>函数。<br>下面让我们来分析一下服务的代码:<br>首先我们从<code>main</code>函数入口进入程序执行，首先执行了<code>http.HandleFunc(&quot;/&quot;, sayhelloName)</code>和<code>http.HandleFunc(&quot;/hello&quot;, sayhelloName)</code>两个方法，这两个方法其实就是设置路由及其对应的处理函数。<br>然后执行<code>http.ListenAndServe(&quot;:8090&quot;, nil)</code>这个函数开始监听8090端口并把用户的请求根据之前设置的路由规则交给特定的函数进行处理。<br>下面我将针对这两个函数进行深入的分析。</p>
<h2 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a>http.HandleFunc</h2><p>这个函数是<code>net/http</code>包中定义的, 第一个参数<code>pattern</code>是<code>string</code>类型，表示匹配的URL, 第二个参数<code>handler</code>这是个函数类型，表示一个处理函数。其定义在<code>net/http/server.go</code>中，第一如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数调用了下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HandelrFunc</code>定义如下, 声明为一个函数类型, <code>HandlerFunc(handler)</code>就是把<code>handler</code>强制类型转化为<code>HandlerFunc</code>类型<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>mux.Handle</code>的定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helpful behavior:</span></span><br><span class="line">    <span class="comment">// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span></span><br><span class="line">    <span class="comment">// It can be overridden by an explicit registration.</span></span><br><span class="line">    n := <span class="built_in">len</span>(pattern)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line">        <span class="comment">// If pattern contains a host name, strip it and use remaining</span></span><br><span class="line">        <span class="comment">// path for redirect.</span></span><br><span class="line">        path := pattern</span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line">            <span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">            path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">        &#125;</span><br><span class="line">        url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">        mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出这个函数会把<code>pattern</code>和<code>handler</code>的对应关系读存储到<code>mux.m</code>这个map里了，<code>mux</code>类型是<code>ServeMux</code>,其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">    hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过上面的处理后通过<code>http.HandleFunc</code>设置的<code>pattern</code>与<code>handler</code>的对应关系都被存储到了<code>DefaultServeMux</code>这个对象的<code>m</code>中。</p>
<h2 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a>http.ListenAndServe</h2><p>这个函数也是在<code>net/http/server.go</code>中定义的，其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面函数最终对调用到下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn(srv, l)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srv.trackListener(l, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">defer</span> srv.trackListener(l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过一个for循环不停的接收请求<code>l.Accept()</code>来得到接收的请求，然后再通过<code>go c.serve(ctx)</code>进行请求的处理。这里用到了协程，也就是每个请求其实是由单独的协程进行处理的，这也是golang作为webserver高效的原因所在。<code>c.serve</code>函数中有一个<code>for</code>循环，会不断读取同一个请求的数据，直到出现问题或者正确读取完毕。读取完请求后会调用<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>这个函数来处理请求。这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="当-handler-为-nil"><a href="#当-handler-为-nil" class="headerlink" title="当 handler 为 nil:"></a>当 handler 为 nil:</h3><p>可以看到当我们不在<code>ListenAndServe</code>中传递<code>handler</code>时，也就是<code>sh.srv.Handler = nil</code>时<code>hanlder=DefaultServeMux</code>，这个 <code>DefaultServeMux</code>正式我们前面通过<code>http.HandleFunc</code>来设置的。 下面调用了<code>hanlder.ServeHTTP</code>，这里也就是调用了<code>DefaultServeMux.ServeHTTP</code>, 这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数中的<code>mux.Handler</code>从请求<code>r</code>中找到请求的URL然后在去<code>mux.m</code>的map结构中找到对应的映射关系从而得出<code>h</code>这个处理函数名。<br>由于上面说过<code>h</code>是转换为类型<code>HandlerFunc</code>, 这个类型定义的<code>ServeHTTP</code>函数如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以调用<code>h.ServeHTTP(w,r)</code>就等于调用<code>h(w,r)</code>，也就是我们调用我们自己的写的处理函数。<br>这些都完成后会执行收尾工作，并把得到的结构返回给请求用户。</p>
<h3 id="当-handler-不为-nil"><a href="#当-handler-不为-nil" class="headerlink" title="当 handler 不为 nil:"></a>当 handler 不为 nil:</h3><p>这时调用<code>h.ServerHTTP(w,r)</code>其实就是调用自己传入的<code>handler</code>的<code>ServerHTTP</code>函数，例如web框架<code>revel</code>的源码<code>github.com/revel/cmd/harness/harness.go</code>中执行<code>revel run app</code>是就会执行下面的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the harness, which listens for requests and proxies them to the app</span></span><br><span class="line"><span class="comment">// server, which it runs and rebuilds as necessary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> paths []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> revel.Config.BoolDefault(<span class="string">"watch.gopath"</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">        gopaths := filepath.SplitList(build.Default.GOPATH)</span><br><span class="line">        paths = <span class="built_in">append</span>(paths, gopaths...)</span><br><span class="line">    &#125;</span><br><span class="line">    paths = <span class="built_in">append</span>(paths, revel.CodePaths...)</span><br><span class="line">    watcher = revel.NewWatcher()</span><br><span class="line">    watcher.Listen(h, paths...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        addr := fmt.Sprintf(<span class="string">"%s:%d"</span>, revel.HTTPAddr, revel.HTTPPort)</span><br><span class="line">        revel.INFO.Printf(<span class="string">"Listening on %s"</span>, addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        <span class="keyword">if</span> revel.HTTPSsl &#123;</span><br><span class="line">            err = http.ListenAndServeTLS(</span><br><span class="line">                addr,</span><br><span class="line">                revel.HTTPSslCert,</span><br><span class="line">                revel.HTTPSslKey,</span><br><span class="line">                h)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = http.ListenAndServe(addr, h)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            revel.ERROR.Fatalln(<span class="string">"Failed to start reverse proxy:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kill the app on signal.</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(ch, os.Interrupt, os.Kill)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    <span class="keyword">if</span> h.app != <span class="literal">nil</span> &#123;</span><br><span class="line">        h.app.Kill()</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这里也调用了`</span>http.ListenAndServe<span class="string">`但是第二个参数`</span>hanlder<span class="string">`传入了`</span>h<span class="string">`，所以最终会调用`</span>h.ServerHTTP<span class="string">`函数, 这个函数`</span>revel<span class="string">`中是这么实现的:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="comment">// ServeHTTP handles all requests.</span></span><br><span class="line"><span class="comment">// It checks for changes to app, rebuilds if necessary, and forwards the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Reverse proxy the request.</span></span><br><span class="line">    <span class="comment">// (Need special code for websockets, courtesy of bradfitz)</span></span><br><span class="line">    <span class="keyword">if</span> strings.EqualFold(r.Header.Get(<span class="string">"Upgrade"</span>), <span class="string">"websocket"</span>) &#123;</span><br><span class="line">        proxyWebsocket(w, r, h.serverHost)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h.proxy.ServeHTTP(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/11/The-Design-and-Implementation-of-Redis-4/"><span>Redis设计与实现总结——独立功能的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/11/The-Design-and-Implementation-of-Redis-4/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-11T02:16:04.000Z">
          2017-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>通过执行<code>SUBSCRIBE</code>命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者(subscriber):每当其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息。<br>除了订阅频道之外，客户端还可以通过执行<code>PSUBSCRIBE</code>命令订阅一个或多个模式，从而成为这些模式的订阅者:每当有其他客户端祥某个频道发送消息时，消息不仅会被发送给这个频道所有订阅者，它还会被发送给所有与这个频道匹配的模式的订阅者。<br>Redis将所有频道的订阅管系都保存在服务器状态的<code>pubsub_channels</code>字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。每当执行订阅命令时服务器都会将客户端与被订阅的频道着<code>pubsub_channels</code>字典中进行关联。如果执行退订命令，那么就会从<code>pubsub_channels</code>中删除这个客户端。<br>模式的订阅则是保存在服务器<code>pubsub_patterns</code>这个属性中，其操作过程与上面相同。<br>发送消息是就会遍历频道的<code>pubsub_channels</code>和<code>pubsub_patterns</code>的客户端，将消息发送给订阅了这些频道和模式的客户端。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过<code>MULTI</code>,<code>EXEC</code>,<code>WATCH</code>等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性，按顺序地执行多个命令的机制，并且在事务执行期间(<strong>当接收到EXEC命令后才开始真正执行, 之前只是命令输入</strong>)，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。<br><code>MULTI</code>命令标识事务的开始，除了<code>EXEC</code>,<code>DISCARD</code>,<code>WATCH</code>,<code>MULTI</code>四个命令外的其他命令都会进入事务的队列中，当接收到<code>EXEC</code>命令时开始执行事务队列中的命令。<br><code>WATCH</code>命令是一个乐观锁(optimistic locking), 它可以在<code>EXEC</code>命令执行之前，监视任意数量的数据库键,并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的回复。 (注意<code>WATCH</code>命令执行的顺序是在<code>MULTI</code>之前)。<br><code>WATCH</code>命令执行的过程是:</p>
<ol>
<li>将监控的键保存到<code>watched_keys</code>字典中，字典的值是所有监视相应数据库键的客户端。</li>
<li>所有对数据库进行修改的命令都会对<code>watched_keys</code>进行检查，如果键被修改了，就会把客户端的<code>REDIS_DIRTY_CAS</code>标识打开。</li>
<li>当接收到<code>EXEC</code>执行命令时，如果判断客户端的<code>REDIS_DIRTY_CAS</code>被打开了，标识客户端提交的事务已经不再安全，服务器拒绝客户端提交的事务。 </li>
</ol>
<p>事务的ACID性质: Redis中，事务总是具有原子性(Atomicity), 一致性(Consistency)和隔离性(Isolation)，并且当Redis运行在某种特定持久化模式下时，事务也具有耐久性(Durability)</p>
<ul>
<li>事务的原子性指的是，数据库将事务中的多个操作当做一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。但是Redis的事务和传统的关系型数据库事务的最大区别在于,<strong>Redis不支持事务回滚机制(rollback)</strong>,即事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，知道将事务队列中的所有命令都执行完毕为止。</li>
<li>事务具有一致性指的是，如果数据库在执行事务之前一致的，那么事务在执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。<strong>一致</strong>指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。</li>
<li>事务的隔离性指的是，即时数据库中有多个事务并发地执行，各个事务之间也不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。因为Redis是使用单线程的方式执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此,Redis中的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</li>
<li>事务的耐久性指的是,当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质里面了，即使服务器在事务执行完毕后停机，，执行事务所得的结果也不会丢失。Redis有<code>RDB</code>和<code>AOF</code>两种持久化方案，但是要持久化方案要和性能进行兼顾。</li>
</ul>
<h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本,直接在服务器端原子地执行多个Redis命令。使用<code>EVAL</code>命令可以直接对输入的脚本进行求值，而<code>EVALSHA</code>命令则可以根据脚本的SHA1校验和来对脚本进行求值。<br>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境，并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成:</p>
<ol>
<li>创建一个基础的 Lua环境(通过调用<code>lua_open</code>函数)</li>
<li>载入函数库(基础库,表格库,字符串库等), 让Lua脚本可以使用这些函数库来进行数据操作。</li>
<li>创建全局表格Redis,这个表格包含了对Redis进行操作的函数，比如用于在 Lua脚本中执行Redis命令的redis.call函数</li>
<li>使用Redis自制的随机函数来替换Lua原有的代有副作用的随机函数,从而避免在脚本中引入副作用。(关于副作用，纯函数的概念参考:<a href="https://zh.wikipedia.org/zh-hk/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">wiki</a></li>
<li>创建排序辅助函数，Lua环境使用这个辅助函数来对一部分Redis命令的结果(比如集合)进行排序,从而消除这些命令的不确定性。</li>
<li>创建<code>redis.pcall</code>函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</li>
<li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本过程中，将额外的全局变量添加到Lua环境中。</li>
<li>将完成修改的Lua环境保存到服务器状态的Lua属性中，等待执行服务器传来的Lua脚本。</li>
</ol>
<p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与 Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的<code>lua_scripts</code>字典。</p>
<ul>
<li>伪客户端: 执行Redis命令必须有响应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。下图是Lua脚本执行Redis命令时的通信步骤:<br><img src="/assets/img/redis/redis_lua.png" alt="redis_lua命令执行步骤"></li>
<li><code>lua_scirpts</code>字典: 这个字典的键为某个Lua脚本的SHA1校验和，而字典的值则是SHA1校验和对应的Lua脚本。<br><code>EVAL</code>命令的执行过程可以分为以下三个步骤:</li>
</ul>
<ol>
<li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。</li>
<li>将客户端给定的脚本保存到<code>lua_scripts</code>字典中,等待将来进一步使用。</li>
<li>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</li>
</ol>
<p>Redis还有四个有关Lua脚本的命令:<code>SCRIPT FLUSH</code>, <code>SCRIPT EXISTS</code>, <code>SCRIPT LOAD</code>和<code>SCRIPT KILL</code>命令。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Redis的<code>SORT</code>命令可以对列表建，集合键或者有序集合键的值进行排序。<br>SORT命令的实现原理是(以<code>SORT numbers</code>为例):</p>
<ol>
<li>创建一个和要排序的对象numbers长度相同的数组，该数组的每个项都是一个<code>redis.h/redisSortObject</code>结构。</li>
<li>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间一对一关系</li>
<li>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面</li>
<li>根据数组项u.score属性的值，对数组进行数字值排序(快速排序算法)，排序后的数组项按u.score属性的值从小到大排列</li>
<li>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端。</li>
</ol>
<p>其他的排序方式，比如按照字母顺序排列，降序排列，通过外部键进行排序等原理都差不多，变化的是排列的顺序，排列的依据<code>u.score</code>不一样。<br>更多<code>SORT</code>命令的具体使用和参数可以参考文档:<a href="http://redisdoc.com/key/sort.html" target="_blank" rel="noopener">Redis SORT命令</a></p>
<h2 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h2><p>Redis提供了<code>SETBIT</code>,<code>GETBIT</code>, <code>BITCOUNT</code>, <code>BITOP</code>四个命令用于处理二进制位数组(bit array, 又称为”位数组”)<br>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。<br>具体使用方法参考官方文档。</p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。<br>服务器有两个和慢查询有关的选项:</p>
<ul>
<li><code>slowlog-log-slower-than</code>选项执行执行时间超过多少微秒的命令请求会被记录到日志上。(可以通过<code>CONFIG SET slowlog-log-slower-than N</code>设置)</li>
<li><code>slowlog-max-len</code>选项执行服务器最多保存多少条慢查询日志。(可以通过<code>CONFIG SET slowlog-max-len N</code>设置)</li>
</ul>
<p>使用<code>SLOWLOG GET</code>命令可以查看服务器所保存的慢查询日志, 使用<code>SLOWLOG LEN</code>可以查看当前日志的数量。</p>
<h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>通过执行<code>MONITOR</code>命令，客户端可以将自己变为一个监视器，实时地接收并打印服务器当前处理的命令请求的相关信息。当一个客户端使用<code>MONITOR</code>向服务器发送命令时，这个客户端的<code>REDIS_MONITOR</code>标识会被打开，并且客户端本身会被服务器添加到<code>monitors</code>链表的表尾。当服务器每次接收到请求时(处理命令之前), 都会调用<code>replicationFeedMonitors</code>函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/06/The-Design-and-Implementation-of-Redis-3/"><span>Redis设计与实现总结——多机数据库的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/06/The-Design-and-Implementation-of-Redis-3/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-06T11:19:41.000Z">
          2017-03-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在Redis中用户可以通过执行<code>SLAVEOF</code>命令或者设置<code>slaveof</code>选项，让一个服务器去复制(repliacte)另一个服务器，被复制的服务器称为主服务器(master),而对服务器进行复制的服务器被称为从服务器(salve)。<br>复制功能分为同步(sync)和命令传播(command propagate)两个操作:</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。(从服务器主动向主服务器请求数据)</li>
<li>命令传播操作用于在主服务器的数据库状态被修改，导致主从服务器数据库状态出现不一致时，让主服务器的数据库重新回到一致状态。</li>
</ul>
<p><img src="/assets/img/redis/redis_sync.png" alt="redis旧版复制"></p>
<ul>
<li>同步过程:<ul>
<li>主服务器接收到从服务器发来的SYNC命令,执行BGSAVE命令,创建RDB文件,并使用缓冲区记录接下来执行的所有写命令。</li>
<li>从服务器接收并载入主服务器发来的RDB文件。</li>
<li>主服务器接着发送缓冲区的写命令到从服务器。</li>
<li>从服务器接收命令。</li>
</ul>
</li>
<li>命令传播:<br>  每当主服务器执行写命令时，主服务器的数据库状态就可能被修改，并导致主从服务器不一致。为了再次回到一致状态，主服务器需要对从服务器执行命令传播操作: 主服务器会将自己执行的写命令发送给从服务器执行，当从服务器执行了相同的写命令后，主从服务器再次回到一致状态。</li>
</ul>
<p>从服务器初次复制主服务器或者从服务器当前要复制的主服务器和上一次不一样时，RDB文件会完整的传输。在处于命令传播阶段的主从服务器因为网络原因而中断了复制，再次连接上时会重头开始复制。但是第二种情况的效率非常低，很多已经复制过的数据需要再次进行复制。这就是旧版复制功能的缺陷。<br>新版复制功能为了解决重复复制的问题，提出了一个<code>PSYNC</code>命令代替之前的<code>SYNC</code>命令。完整的复制与上面的第一种情况初次复制是一样的，部分重同步则用于处理断线后的情况: 断线再连接后，主服务器只发送断线期间的写命令到从服务器。<br>部分重同步的实现是通过<code>复制偏移量</code>:</p>
<ul>
<li>主服务器每次向从服务器转播N个字节的数据时，就将自己的复制偏移量的值+N</li>
<li>从服务器每次收到主服务器传播来的N个字节数据时，就将自己的复制偏移量的值+N</li>
</ul>
<p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态:</p>
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>
<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li>
</ul>
<p>复制积压缓冲区是一个由主服务器维护的固定长度，先进先出队列，默认大小为1MB。当主从断开连接，再次连接时,从服务器会通过<code>PSYNC</code>将自己的复制偏移量<code>offset</code>发送给主服务器:</p>
<ul>
<li>如果<code>offset</code>偏移量之后的数据存在于复制积压缓冲区，那么主服务器将对从服务器执行部分重同步操作。</li>
<li>如果<code>offset</code>偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器会对从服务器执行完整重同步操作。</li>
</ul>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率，祥主服务器发送命令<code>REPLICONF ACK &lt;replication_offset&gt;</code>, 其中<code>replication_offset</code>是当前从服务器的复制偏移量, 这个<code>心跳检测</code>的作用如下:</p>
<ul>
<li><strong>检测主从服务器的网络状态</strong>:如果主服务器超过一秒钟没收到从服务器发送的<code>REPLICONF ACK</code>命令，那么主服务器就知道主从服务器之间的连接出现问题了。</li>
<li><strong>辅助实现min-slaves选项</strong>:Redis的<code>min-slaves-to-write</code>和<code>min-slaves-max-log</code>两个选项可以防止主服务器在不安全的情况下执行写命令。</li>
<li><strong>检测命令丢失</strong>:如果因为网络故障，主服务器传播给从服务器的写命令半路丢失，那么从服务器发送的偏移量就会小于主服务器的偏移量，这时候主服务器会从复制积压缓冲区中重新把命令发送给从服务器。(2.8版本之前没有这个功能，所以会出现丢失的情况)</li>
</ul>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel(哨岗，哨兵)是Redsi的高可用性(high availability)解决方案:由一个或多个Sentinel实例(instance)组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。另外Sentinel还会继续监视已下线的服务器，并在它重新上时，将它设置为新的主服务器的从服务器(降级)。<br>启动Sentinel可以使用命令: <code>redis-sentinel /path/to/your/sentinel.conf</code> 或 <code>redis-server /path/to/your/sentinel.conf --sentinel</code>, 启动时需要执行一下步骤:</p>
<ul>
<li>初始化服务器: Sentinel本质上是一个运行在特殊模式下的Redis服务器，启动初始换与原来有所不同。</li>
<li>将普通Redis服务器使用的代码替换成Sentinel专用代码:初始换Sentinel可以执行的命令，替换之前的默认命令。</li>
<li>初始化Sentinel状态:初始化<code>sentinel.c/sentinelState</code>结构，这个结构保存了服务器中所有Sentinel相关的状态。</li>
<li>根据跟定的配置文件，初始化Sentinel的监视主服务器列表:Sentinel状态中的<code>masters</code>字典记录了所有被Sentinel监视的主服务器的相关信息，其中字典的键是被监视主服务器的名字；而字典的值则是被监视主服务器对应的<code>sentinel.c/sentinelRedisInstance</code>结构。</li>
<li>创建连向主服务器的网络连接: 最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息。对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接:<ul>
<li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li>
<li>另一个是订阅连接，这个链接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么有两个连接?<br>在Redis目前的发布与订阅功能中，被发送的信息不回保存在Redis服务器里，如果发送信息时，接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。<strong>为了不丢失任何信息，必须专门用一个订阅连接来接收该频道的信息</strong>(原理?)。另外除了订阅频道，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接。</p>
</blockquote>
<h3 id="Sentinel网络拓扑"><a href="#Sentinel网络拓扑" class="headerlink" title="Sentinel网络拓扑"></a>Sentinel网络拓扑</h3><p>Sentinel与主服务器，从服务器及其他Sentinel之间都是彼此连接的:</p>
<ul>
<li>首先Sentinel默认<code>每10秒一次</code>向主服务器发送INFO命令，Sentinel可以得到主服务器信息以及主服务器的从服务器信息;</li>
<li>Sentinel会更新自己的主服务器和从服务器信息，还会创建连接到从服务器的命令连接和订阅连接。</li>
<li>Sentinel还会默认<code>每2秒一次</code>通过命令连接向所有被监视的主服务器和从服务器发送命令，这条命令会向服务器的<code>__sentinel__:hello</code>频道发送一条信息</li>
<li>由于Sentinel订阅了主服务器和从服务器的消息，所以所有订阅的Sentinel都会收到上面的信息，接收消息的Sentinel就会感知到发消息的Sentinel存在，并记录到<code>sentinels</code>属性中(可以实现自动发现功能)</li>
</ul>
<h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><h4 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h4><p>默认情况下Sentinel会以<code>每秒一次</code>的频率向所有与它创建了命令连接的实例(包括主服务器，从服务器，其他Sentinel等)发送PING命令, 并通过实例返回的PING命令回复判断是否在线。由于每个Sentinel设置的下线时间标准可能不一样，所以会出现不同的Sentinel认为服务器的状态不一致，所以这种情况称为主观下线状态。</p>
<h4 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h4><p>当Sentinel从其他Sentinel那里接收的足够数量的已下线判断之后，Sentinel就会认为将主服务器判定为客观下线状态，并对主服务器执行故障转移操作。</p>
<h4 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h4><p>当主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头的Sentinel，并由领头Sentinel对下线服务器执行故障转移。<br>选举策略是每个检测到主服务器下线的Sentinel都向其他Sentinel发送想要成为领头的命令，收到命令的Sentinel会将发送命令的Sentinel设置为局部领头，如果一个Sentinel被半数以上的Sentinel设置为局部领头，它就胜出，否则会进行再次选举。</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>选举出领头Sentinel后，领头Sentinel将对已下线的主服务器执行故障转移操作:</p>
<ul>
<li>在已下线服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器: 选择优先级高，复制偏移量大的从服务器，使用命令<code>SLAVE of one</code>使其变为主服务器。</li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器: 领头Sentinel向其他从服务器发送<code>SLAVEOF</code>命令。</li>
<li>将已下线的主服务器设置为心的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p>
<h3 id="节点与槽"><a href="#节点与槽" class="headerlink" title="节点与槽"></a>节点与槽</h3><p>Redis集群通常由多个节点(node)组成，开始每个节点都是图例的，它们都处于一个只包含自己的集群中，当要组建一个真正可工作的集群，我们必须将节点连接起来，构成一个包含多个节点的集群。使用<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>命令来完成。另外Redis服务器启动时也可以根据<code>cluster-enabled</code>配置选项来判断是否开启集群模式。节点信息保存在<code>cluster.h/clusterNode</code>结构中，<code>clusterNode</code>结构保存了一个节点的当前状态，比如节点的创建时间，节点的名等;<code>clusterNode</code>的<code>link</code>属性是一个<code>clusterLink</code>结构，该结构保存了连接节点所需的有关信息,比如套接字描述符，输入缓冲区和输出缓冲区; 每个节点都保存着一个<code>clusterState</code>结构，这个结构记录了当前节点的视角下，集群目前所处的状态，例如机器是在线还是下线，集群包含多少节点等。<br>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为<code>16384</code>(=2048*8)个槽(slot),数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。当数据库中的16384个槽有节点在处理时，集群处于一个上线状态(ok);相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态(fail)。<br>槽指派信息记录在<code>clusterNode.slots[16384/8]</code>属性中, <code>numslots</code>记录了节点负责处理的槽的数量。Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位来判断节点是否负责处理槽i:</p>
<ul>
<li>如果slots数组在索引i上的二进制位值为1，那么表示节点负责处理槽i。</li>
<li>如果slots数组在索引i上的二进制位值为0, 那么表示节点不负责处理槽i。</li>
</ul>
<p>节点会把自己处理的槽信息发送给其他集群中的其他节点，因此集群中的每个节点都会知道数据库中16384个槽分别被指派给了集群中哪些节点。<br><code>clusterState</code>结构中的<code>slots[16384]</code>数组则更上面的正好反过来，它记录了每个槽是由哪个节点在管理的。之所以会有这两种结构是为了在查找节点管理了哪些槽和槽由哪个节点管理的复杂度都降低了。</p>
<h3 id="集群中的执行命令"><a href="#集群中的执行命令" class="headerlink" title="集群中的执行命令"></a>集群中的执行命令</h3><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽(使用crc16(key)&amp;16383算法得出槽位置)，并检查这个槽是否指派给了自己(clusterState.slots[i]是否为自己):</p>
<ul>
<li>如果键所在的槽正好指派给了当前节点，那么节点直接执行这个命令。</li>
<li>如果键所在的槽没有指派给了当前节点，那么节点回向客户端返回一个MOVED错误，指引客户端转向(redirect)至正确的节点，并再次发送之前想要执行的命令。</li>
</ul>
<p>节点与单机服务器在数据库方面的区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制。<br>节点还会使用<code>clusterState</code>结构中的<code>slots_to_keys</code>跳跃表来保存槽和键之间的关系，主要目的是方便节点对属于某个或某些槽的所有数据库键进行批量操作。</p>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目的节点)，并且相关槽所属的键值对也会从源节点移动到目的节点。这个过程可以在线进行，在重新分片过程中，集群不需要下线，并且源节点和目的节点都可以继续处理命令请求。<br>Redis的重新分片操作是由Redis的集群管理软件<code>redis-trib</code>负责执行的。迁移过程如下:<br><img src="/assets/img/redis/redis_trib.png" alt="redis-trib"><br>在执行第四步迁移的过程中，如果客户端向源节点发送一个与数据库键有关的命令，那么:</p>
<ul>
<li>源节点先在自己数据库里查找指定的键，如果找到就直接执行客户端发送的命令.</li>
<li>如果没找到，那么这个键可能已经被迁移到了目标节点，源节点向客户端返回一个ASK错误，指引客户端转向正在导入槽的目的节点，并再次发送之前想要执行的命令。<br>当客户端接收到ASK错误并转向正在执行导入槽节点时，客户端会先向节点发送一个<code>ASKING</code>命令，然后才重新发送想要执行的命令。ASKING命令会打开发送客户端的<code>REDIS_ASKING</code>标识。<br>一般情况下如果客户端向节点发送一个关于槽i的命令，如果节点没有这个槽，那么就会返回<code>MOVED</code>，但是如果节点的<code>clusterState.importing_slots_from[i]</code>显示节点正在导入槽i,并且发送命令的客户端带有<code>REDIS_ASKING</code>（通过<code>ASKING</code>命令打开)标识，那么节点将执行这个关于槽i的命令一次</li>
</ul>
<p>关于ASK错误与MOVED错误的区别:</p>
<ul>
<li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点，客户端收到关于槽i的MOVED错误后，每次遇到槽i请求是，都可以直接将命令发送至MOVED错误所指向的节点。</li>
<li>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施, 不会影响后面命令的发送。</li>
</ul>
<h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分为主节点(master)和从节点(slave),其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。设置从节点的命令:<code>CLUSTER REPLICATE &lt;node_id&gt;</code><br>集群中的每个节点都会定期地祥集群中其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记位疑似下线(probable fail, PFAIL)。如果一个集群里，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线(FAIL), 将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点X标记为下线。<br>当一个从节点发现自己正在复制的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，下面是故障转移执行的步骤:</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中:选举过程和Sentinel差不多。</li>
<li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条PONG消息，可以让集群中其他节点立即知道这个节点从从节点变为了主节点，并且这个主节点已经接管了原本由已下线主节点负责处理的槽。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面主要讲了Redis在多机数据库下的功能特性，其中复制是实现数据备份，数据可靠性的保证。Sentinel实现高可用性的保证。在3.0版本之前的分布式方案都是自己实现的，然后利用Sentinel进行监控。后来Redis自己实现了集群方案，可以用其默认的集群方案来代替之前的自己实现方案。他们之间是相辅相成的，根据自己的需要进行选择。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.zhihu.com/question/21419897" target="_blank" rel="noopener">Redis集群方案应该怎么做?</a></li>
<li><a href="http://rdc.hundsun.com/portal/article/669.html" target="_blank" rel="noopener">如何部署高可用的Redis集群架构</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>