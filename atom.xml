<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OohCode</title>
  
  <subtitle>ooh my code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://oohcode.com/"/>
  <updated>2019-06-28T04:51:25.653Z</updated>
  <id>http://oohcode.com/</id>
  
  <author>
    <name>sean chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go channel 原理</title>
    <link href="http://oohcode.com/2019/06/27/go-channel/"/>
    <id>http://oohcode.com/2019/06/27/go-channel/</id>
    <published>2019-06-27T09:27:24.000Z</published>
    <updated>2019-06-28T04:51:25.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要介绍<code>chan</code>的内部实现原理(基于go1.12), 通过源码和图形的方式展示<code>chan</code>的内部结构及对<code>chan</code>进行操作的过程。</p></blockquote><h2 id="make-chan"><a href="#make-chan" class="headerlink" title="make chan"></a>make chan</h2><p>在进入源码分析之前，我们假设自己并不知道去哪里看其源码，我们先简单的创建一个<code>chan</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了分析其内部实现，我们可以通过<code>compile</code>工具对其编译生成伪汇编代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S chan.go</span><br></pre></td></tr></table></figure></p><p>生成的汇编代码重点的内容入下:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">71</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (chan1.go:<span class="number">3</span>)   TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$32</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0031</span> <span class="number">00049</span> (chan1.go:<span class="number">4</span>)   <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0045</span> <span class="number">00069</span> (chan1.go:<span class="number">3</span>)   <span class="keyword">JMP</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>可以看到执行<code>make</code>其实最终执行的是<code>runtime.makechan</code>这个函数，这个函数的实现在<code>runtime/chan.go</code>文件中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line">    ...</span><br><span class="line">    mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Queue or element size is zero.</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">        <span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Elements contain pointers.</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></p><p>可以看到最终会返回一个<code>*hchan</code>类型，这个就是<code>chan</code>的结构体:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 队列中有数据的个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 循环队列的大小z</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向循环队列的地址</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         </span><br><span class="line">    closed   <span class="keyword">uint32</span> <span class="comment">// chan的关闭状态</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// 队列中下一个要发送的数据的下标</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// 队列中下一个要接收的数据的下标</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 等待接受的G队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 等待发送的G队列</span></span><br><span class="line">    lock     mutex  <span class="comment">// 操作chan是需要加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完上面的<code>make</code>后，生成的<code>chan</code>如下:<br><img src="/assets/img/go/channel/makechan.png" alt></p><h2 id="send-chan"><a href="#send-chan" class="headerlink" title="send chan"></a>send chan</h2><p>为了了解我们往<code>chan</code>发送的时候都做了什么我可能先写一个demo:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看其汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">97</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (chan2.go:<span class="number">3</span>)   TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$32</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0031</span> <span class="number">00049</span> (chan2.go:<span class="number">4</span>)   <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x004b</span> <span class="number">00075</span> (chan2.go:<span class="number">5</span>)   <span class="keyword">CALL</span>    runtime.chansend1(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x005f</span> <span class="number">00095</span> (chan2.go:<span class="number">3</span>)   <span class="keyword">JMP</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>可以看出我们往<code>chan</code>发送数据其实执行的是<code>runtime.chansend1</code>函数，这个函数很简简单，只是调用了<code>runtime.chansend</code>函数,我们主要看一下<code>runtime.chansend</code>函数的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 往已经 closed 的 chan 发送数据会直接 panic</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果有接收队列，则进入send函数</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 没有接收队列，buf还没有满，则直接往里放数据</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123; <span class="comment">//如果sendx == dataqsize, 证明buf满了，</span></span><br><span class="line">            c.sendx = <span class="number">0</span> <span class="comment">// c.sendx=0保证了又从头开始，形成了一个循环队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个sudog结构, 把当前发送数据所在的g和要发送的数据都放到这里</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.sendq.enqueue(mysg) <span class="comment">// 把这个sudog结构体放到发送对队列中</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>) <span class="comment">//阻塞当前g,直到由于可以发送数据而被唤醒</span></span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们有一个图来表示其过程，图中主要分为下面几个步骤:</p><ol><li>往上面初始化好的<code>hchan</code>结构体发送第 1 个数据: 数据放到<code>buf[0]</code>的位置</li><li>往<code>hchan</code>结构体发送第 2 个数据: 数据放到<code>buf[1]</code>的位置</li><li>往<code>hchan</code>结构体发送第 3 个数据: 数据放到<code>buf[2]</code>的位置, 这时<code>buf</code><strong>满了</strong></li><li>往<code>buf</code>满了的<code>hchan</code>结构体发送第 4 个数据: <code>g1</code>会放到<code>sudog</code>结构体中，并放到<code>sendq</code>队列中，等待被唤醒</li><li>往<code>buf</code>满了的<code>hchan</code>结构体发送第 5 个数据: <code>g2</code>会放到<code>sudog</code>结构体中，并放到<code>sendq</code>队列中，等待被唤醒</li></ol><p><img src="/assets/img/go/channel/send.gif" alt></p><h2 id="recv-chan"><a href="#recv-chan" class="headerlink" title="recv chan"></a>recv chan</h2><p>同上面一样，我们先写一个<code>demo</code>看看<code>recv</code>调用的是哪个函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">94</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0031</span> <span class="number">00049</span> (chan3.go:<span class="number">4</span>)       <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0048</span> <span class="number">00072</span> (chan3.go:<span class="number">5</span>)       <span class="keyword">CALL</span>    runtime.chanrecv1(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x005c</span> <span class="number">00092</span> (chan3.go:<span class="number">3</span>)       <span class="keyword">JMP</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>同样<code>runtime.chanrecv1</code>也是简单调用了<code>runtime.chanrecv</code>函数，具体代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">        c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 如果chan已经被关闭，并且qcount==0, 则返回默认零值+false(如x, ok := &lt;- c, x是零值，ok=false)</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在接收的时候有发送队列存在，则执行recv函数</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">        <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">        <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">        <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在buf, 存在数据</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Receive directly from queue</span></span><br><span class="line">        qp := chanbuf(c, c.recvx) <span class="comment">//获取recvx位置的地址</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp) <span class="comment">// 把recvx位置的数据copy到接收的变量中</span></span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp) <span class="comment">// 清空原来recvx位置的数据</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123; <span class="comment">// 如果recvx == dataqsiz 证明已经到达最后一个，需要从头开始</span></span><br><span class="line">            c.recvx = <span class="number">0</span> <span class="comment">//从头开始，形成一个循环队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog() <span class="comment">// 获取一个sudog结构，把对应的g和接收数据的变量地址放到sudog中</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.recvq.enqueue(mysg) <span class="comment">// 把sudog放入接收队列中</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>) <span class="comment">//阻塞当前g，直到被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closed := gp.param == <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面说到如果存在发送队列就会执行<code>recv</code>函数，下面看一下这个函数的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//对于nobuf的chan, 直接copy数据</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racesync(c, sg)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// copy data from sender</span></span><br><span class="line">            recvDirect(c.elemtype, sg, ep)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">        <span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">        <span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">        <span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">        qp := chanbuf(c, c.recvx) <span class="comment">// 获取接收数据的位置</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy data from queue to receiver</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp) <span class="comment">//把recvx位置的数据copy到接收的变量中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy data from sender to queue</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, sg.elem) <span class="comment">// 把发送队列的数据copy到当前recvx的位置</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为上面把发送队列的数据copy到了recvx, 为了保证下一个位置属按照顺序的，需要sendx = recvx</span></span><br><span class="line">        <span class="comment">// 这几步保证了chan是一个FIFO的过程</span></span><br><span class="line">        c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz </span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 把出队的g放到ready中，下次调度就可以运行了，不再阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们有一个图来表示接收数据的过程，图中主要分为下面几个步骤:</p><ol><li>初始的<code>hchan</code>是上面<code>send</code>之后的结构</li><li><code>g3</code>执行接收操作，首先会把发送队列中的第 1 个<code>g1</code>出队，然后把<code>buf[0]</code>的数据赋值到<code>g3</code>中，再把<code>g1</code>的数据赋值到<code>buf[0]</code>中</li><li><code>g3</code>执行接收操作，首先会把发送队列中的第 2 个<code>g2</code>出队，然后把<code>buf[1]</code>的数据赋值到<code>g3</code>中，再把<code>g2</code>的数据赋值到<code>buf[1]</code>中</li><li>这个时候没有发送队列了，所以可以直接把<code>buf[2]</code>中的书赋值到<code>g3</code>中</li><li>把下一个数据<code>buf[0]</code>中的书赋值到<code>g3</code>中</li><li>把最后一个数据<code>buf[1]</code>中的书赋值到<code>g3</code>中</li><li>已经没有数据可以赋值给<code>g3</code>了，所以<code>g3</code>被放入<code>sudog</code>结构体中，入队到了接收队列, 进入阻塞状态</li></ol><p><img src="/assets/img/go/channel/recv.gif" alt></p><h2 id="send-chan-again"><a href="#send-chan-again" class="headerlink" title="send chan again"></a>send chan again</h2><p>上面介绍<code>send</code>说到如果发送数据的时候有<code>recvq</code>队列就会调用<code>send</code>函数，这个函数的具体实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">            racesync(c, sg) <span class="comment">// no buf 直接同步</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Pretend we go through the buffer, even though</span></span><br><span class="line">            <span class="comment">// we copy directly. Note that we need to increment</span></span><br><span class="line">            <span class="comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">            qp := chanbuf(c, c.recvx) <span class="comment">// 获取recvx位置</span></span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">            c.recvx++</span><br><span class="line">            <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">                c.recvx = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep) <span class="comment">//直接把要发送的数据 copy 到 recvq 队列出队的 g 中</span></span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 把g放到ready队列中，下次有机会被调度，不再阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/go/channel/send-recv.gif" alt></p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>当我们<code>close</code>掉一个<code>chan</code>都发生了什么呢? 下面写一个<code>close</code>的<code>demo</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">85</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0031</span> <span class="number">00049</span> (chan4.go:<span class="number">4</span>)       <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x003f</span> <span class="number">00063</span> (chan4.go:<span class="number">5</span>)       <span class="keyword">CALL</span>    runtime.closechan(SB)</span><br><span class="line">        <span class="number">0x0053</span> <span class="number">00083</span> (chan4.go:<span class="number">3</span>)       <span class="keyword">JMP</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以调用了<code>runtime.closechan</code>函数，对应的代码为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>)) <span class="comment">// 已经关闭的 chan 不能再关闭</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">        racerelease(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.closed = <span class="number">1</span> <span class="comment">// 关闭状态设置为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line">    <span class="comment">// release all readers</span></span><br><span class="line">    <span class="comment">// 遍历所有recvq 队列, 从队列中去掉，并清空其内容，把所有g都放到glist结构中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">            sg.elem = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有 sendq 队列, 从队列中去掉，把所有g都放到glist结构中</span></span><br><span class="line">    <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">    <span class="comment">// 把刚才所有放到 glist 中的 g 都改为ready 状态，使其不再阻塞</span></span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们分别看一下:</p><ol><li><p>当存在<code>recvq</code>队列时:<br><img src="/assets/img/go/channel/close-recv.gif" alt></p></li><li><p>当存在<code>sendq</code>队列时:</p></li></ol><p><img src="/assets/img/go/channel/close-send.gif" alt></p><h2 id="no-buffer-chan"><a href="#no-buffer-chan" class="headerlink" title="no buffer chan"></a>no buffer chan</h2><p>前面讲的都是带<code>buffer</code>的<code>chan</code>, 还有一种是经常使用的不带<code>buffer</code>的<code>chan</code>，其实处理起来更简单，前面源码部分已经有涉及了，下面看一下操作过程:</p><ol><li><code>make</code>一个不带<code>buffer</code>的<code>chan</code></li><li><code>g1</code>向这个<code>chan</code>发送数据, 由于没有接收者而被阻塞，放到<code>sendq</code>中</li><li><code>g2</code>继续想这个<code>chan</code>发送数据，继续放到<code>sendq</code>中</li><li>来一个接收者<code>g3</code>, 这时把<code>g1</code>从<code>sendq</code>中出队，并把<code>elem</code>的值赋值给<code>g3</code>的<code>x</code></li><li><code>g3</code>继续接收,把<code>g2</code>从<code>sendq</code>中出队，并把<code>elem</code>的值赋值给<code>g3</code>的<code>x</code></li><li>没有发送队列存在，<code>g3</code>也进入了阻塞状态，放到了<code>recvq</code>队列中</li></ol><p>下面是其图形化展示:<br><img src="/assets/img/go/channel/no-buf-chan.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇主要介绍&lt;code&gt;chan&lt;/code&gt;的内部实现原理(基于go1.12), 通过源码和图形的方式展示&lt;code&gt;chan&lt;/code&gt;的内部结构及对&lt;code&gt;chan&lt;/code&gt;进行操作的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go 单元测试</title>
    <link href="http://oohcode.com/2019/06/10/unit-test-in-go/"/>
    <id>http://oohcode.com/2019/06/10/unit-test-in-go/</id>
    <published>2019-06-10T02:11:19.000Z</published>
    <updated>2019-06-27T09:26:56.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go单元测试"><a href="#Go单元测试" class="headerlink" title="Go单元测试"></a>Go单元测试</h1><p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。<br>我们为何要进行单元测试呢？其实如果你不添加单元测试的话，别人调用你提供的函数是，其实就是帮你做测试，但是这种测试我们越早做越能发现问题.</p><h3 id="单元测试的粒度"><a href="#单元测试的粒度" class="headerlink" title="单元测试的粒度"></a>单元测试的粒度</h3><p>程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。在 Go 中程序单元指的是<code>Package</code>中的方法。<br>那么我们对于 Go 中改对那些函数写单元测试呢？这里的答案是: 包中可导出的函数。 因为这些函数是对外可见的，这些是我们包的入口。那么对于不可导出的函数我们是否需要些单元测试呢？答案是不用。有些人可能会有一位，如果我们不对不可导出的函数写单元测试，那么如何保证单元测试的覆盖率呢？因为有些不可导出函数的覆盖率达不到要求。这里要说的是: 如果有些不可导出函数单元测试覆盖率达不到，有两点可能性:</p><ul><li>这些逻辑是不需要的，你可以直接去掉</li><li>你的测试用例不够，你需要增加可导出函数的测试用例</li></ul><h3 id="单测的三个原则"><a href="#单测的三个原则" class="headerlink" title="单测的三个原则"></a>单测的三个原则</h3><p>还有一个问题是: 我该先开发功能在写单元测试，还是先写单元测试再开发功能？<br>其实关于TDD有三个定律:</p><ol><li>You are not allowed to write any production code unless it is to make a failing unit test pass.</li><li>You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.</li><li>You are not allowed to write any more production code than is sufficient to pass the one failing unit test.</li></ol><p>关于这三条定律，我发现每个人翻译的都不一样，我觉得比较符合我的理解的翻译是:</p><ol><li>除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</li><li>在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</li><li>只允许编写刚好能够使一个失败的 unit test 通过的产品代码</li></ol><p>如果违反了会怎么样呢？<br>违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p><p>还是针对上面的问题: 先写单元测试还是先写功能？<br>我的答案是: <strong>单元测试-&gt; 功能开发 -&gt; 单元测试 -&gt; 功能开发…</strong><br>它们应该是交替进行的，既: 先写小范围的单元测试，然后针对这些测试进行开发功能，等所有测试通过后继续增加测试<code>case</code>, 然后针对新增的<code>case</code>继续编写功能，直到功能满足了需求为止。</p><h3 id="测试行为-而非实现"><a href="#测试行为-而非实现" class="headerlink" title="测试行为, 而非实现"></a>测试行为, 而非实现</h3><p>Avoid Testing Implementation Details, Test Behaviours<br>当我们测试行为时，我们的意思是 : “我不在乎你是如何得出答案的，只要确保在这种情况下答案是正确的”<br>当我们测试实现时，我们的意思是 : “我不在乎答案是什么，只要确保它是按照你规定的方式工作的。”</p><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="单元测试编写"><a href="#单元测试编写" class="headerlink" title="单元测试编写"></a>单元测试编写</h3><p>下面给出一个完整的<code>Go</code>的单元测试的例子:<br><code>split.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">    i := strings.Index(s, sep)</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">        s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">        i = strings.Index(s, sep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>split_test.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        got := Split(<span class="string">"a/b/c"</span>, <span class="string">"/"</span>)</span><br><span class="line">        want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, want, got)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Go</code>官方网站有关于单元测试的<a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">写法介绍</a>, 以上面的代码为例:</p><ol><li><p>一般我们需要单元测试文件和要测试的包的文件需要在同一个目录下，并且以<code>_test.go</code>结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/split/</span><br><span class="line">├── split.go</span><br><span class="line">└── split_test.go</span><br></pre></td></tr></table></figure></li><li><p>单元测试的函数名为<code>Test</code> + 要测试的函数名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要测试的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">// 单元测试函数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TestSplit</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure></li><li><p>单元测试函数的参数是固定的 (<a href="https://golang.org/pkg/testing/#T" target="_blank" rel="noopener">*testing.T</a>):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p><code>Go</code>语言的工具链中提供了很强大的<a href="https://golang.org/cmd/go/#hdr-Test_packages" target="_blank" rel="noopener">单元测试工具</a>:<code>go test</code>, 如果想要运行刚才的单元测试，我们只需要在<code>split</code>文件夹下执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure></p><p>就可以得出测试结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">PASS</span><br><span class="line">ok      split   0.008s</span><br></pre></td></tr></table></figure></p><h3 id="运行多个单元测试"><a href="#运行多个单元测试" class="headerlink" title="运行多个单元测试"></a>运行多个单元测试</h3><p>有是有我们需要同时运行多个单元测试, 如果这些单元测试在同一个包下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/xml/</span><br><span class="line">├── atom_test.go</span><br><span class="line">├── example_marshaling_test.go</span><br><span class="line">├── example_test.go</span><br><span class="line">├── example_text_marshaling_test.go</span><br><span class="line">├── marshal.go</span><br><span class="line">├── marshal_test.go</span><br><span class="line">├── read.go</span><br><span class="line">├── read_test.go</span><br><span class="line">├── typeinfo.go</span><br><span class="line">├── xml.go</span><br><span class="line">└── xml_test.go</span><br></pre></td></tr></table></figure></p><p>我们可以直接运行: <code>go test</code><br>如果这些单元测试文件不在同一个包下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/</span><br><span class="line">├── ascii85</span><br><span class="line">│   ├── ascii85.go</span><br><span class="line">│   └── ascii85_test.go</span><br><span class="line">├── asn1</span><br><span class="line">│   ├── asn1.go</span><br><span class="line">│   ├── asn1_test.go</span><br><span class="line">│   ├── common.go</span><br><span class="line">│   ├── marshal.go</span><br><span class="line">│   └── marshal_test.go</span><br><span class="line">├── base32</span><br><span class="line">│   ├── base32.go</span><br><span class="line">│   ├── base32_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">├── base64</span><br><span class="line">│   ├── base64.go</span><br><span class="line">│   ├── base64_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们需要在这些包的外面运行: <code>go test ./...</code></p><h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>如果我们想要查看单元测试的覆盖率，<code>Go</code> 工具链也是支持的, 详情可以参考官方的Blog: <a href="https://blog.golang.org/cover" target="_blank" rel="noopener">The cover story</a><br>如果要查看单元测试覆盖率，我们可以运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      split   0.013s</span><br></pre></td></tr></table></figure></p><p>但是上面的测试只给出了覆盖率的值，并没有看到详细的信息，如果我们需要查看覆盖率的详细信息，可以把测试覆盖率的内容输出到文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go test -coverprofile=coverage.out</span><br></pre></td></tr></table></figure></p><p>这样，测试覆盖率的详细信息就输出到了文件<code>coverage.out</code>中。<br>如过要查看每个函数的测试覆盖率，可以利用刚才的<code>coverage.out</code>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -func=coverage.out</span><br><span class="line">split/split.go:7:       Split           100.0%</span><br><span class="line">total:                  (statements)    100.0%</span><br></pre></td></tr></table></figure></p><p>如果要想可视化测试覆盖率，还可以生成<code>html</code>格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -html=coverage.out</span><br></pre></td></tr></table></figure></p><p>我们可以看到每行的覆盖情况:<br><img src="https://blog.golang.org/cover/set.png" alt="覆盖率"><br>其中红色代表没有覆盖到，绿色代表覆盖到，灰色代表不计入测试覆盖率的范围</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="多个case"><a href="#多个case" class="headerlink" title="多个case"></a>多个case</h3><p>前面我们讲了如何进行基本的单元测试，但是现实中往往我们需要对同一个函数进行多个<code>case</code>的测试，那么其实有两种写法:</p><h4 id="针对每个case写一个测试函数"><a href="#针对每个case写一个测试函数" class="headerlink" title="针对每个case写一个测试函数:"></a><strong>针对每个<code>case</code>写一个测试函数:</strong></h4><p>对于比较复杂的函数，其函数的表现可能会收到不同环境因素的影响，他们的单元测试写法差别也比较大，比如<code>beego</code>中 <a href="https://github.com/astaxie/beego/blob/develop/logs/file_test.go" target="_blank" rel="noopener">logs/file</a> 的单元测试, 同样是测试<code>FileDailyRotate</code>函数，<code>TestFileDailyRotate_01</code>测试的是创建文件, <code>TestFileDailyRotate_02</code>测试的是当创建的文件存在时，给文件加后缀。</p><h4 id="同一个测试函数里有多个case"><a href="#同一个测试函数里有多个case" class="headerlink" title="同一个测试函数里有多个case:"></a><strong>同一个测试函数里有多个<code>case</code>:</strong></h4><p>一般比较简单的单元测试，只是根据输入的不同而产生不同的输出，则可以使用这种方式。比如前面说的<code>split</code>函数的多个<code>case</code>测试, 我们把<code>split_test.go</code>改为下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep   <span class="keyword">string</span></span><br><span class="line">        want  []<span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tests := []test&#123;</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := Split(tc.input, tc.sep)</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">            t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="边界条件测试"><a href="#边界条件测试" class="headerlink" title="边界条件测试"></a>边界条件测试</h3><p>由长期的测试工作经验得知，大量的错误是发生在输入或输出的边界上。因此针对各种边界情况设计测试用例，可以查出更多的错误。上面的<code>case</code>中我们并没有对边界条件进行测试，下面我们加上一个边界条件的测试<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure></p><p>可以看到我们的单元测试有一个<code>case</code>没有通过，但是这里有一点疑问:<strong>哪个测试<code>case</code>没过?</strong></p><h3 id="定位测试case"><a href="#定位测试case" class="headerlink" title="定位测试case"></a>定位测试case</h3><h4 id="通过编号定位"><a href="#通过编号定位" class="headerlink" title="通过编号定位"></a>通过编号定位</h4><p>我们可以给每个case一个编号:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"test %d: expected: %v , got %v"</span>, i+<span class="number">1</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: test 2: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.016s</span><br></pre></td></tr></table></figure><p>这里可以定位出 <code>test 2</code> 有问题的，但是编号的问题是 : </p><ul><li>每个人定义的开始下标可能不同: 有的人是从<code>0</code>开始，有的人从<code>1</code>开始，照成理解不一致</li><li>随着case的增多，同样不好定位具体的<code>case</code>: 如果你要从<code>50</code>个<code>case</code>中定位第<code>27</code>个<code>case</code>, 还是比较费时的。</li></ul><h4 id="通过名字定位"><a href="#通过名字定位" class="headerlink" title="通过名字定位"></a>通过名字定位</h4><p>还有一种方式: 我们给每个<code>case</code>一个名字:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                name  <span class="keyword">string</span></span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;name: <span class="string">"simple"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"trailing sep"</span>, input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"wrong sep"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"no sep"</span>, input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, tc.name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:26: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure><p>现在我们可以看到我们可以很好的通过<code>trailing sep</code>快速定位到了具体的<code>case</code></p><h3 id="随机测试case"><a href="#随机测试case" class="headerlink" title="随机测试case"></a>随机测试case</h3><p>上面的测试方式看上去很完美了，可以如果我们实现的时候没有注意，<code>case</code>之间可能会相互影响, 比如一个<code>case</code>在函数内部修改了一个全局变量，下一个<code>case</code>的执行就会受到这种影响。为了避免由于测试顺序带来的问题，我们一般都会让每个<code>case</code>之间的顺序是随机的，而不是按照特定的顺序，而<code>slice</code>本身有顺序的，所以不满足我们的条件，这时我们可以使用<code>map</code>, 同时还可以把<code>name</code>放到<code>map</code>的<code>key</code>中，简化我们的写法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:23: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.014s</span><br></pre></td></tr></table></figure></p><h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><p>看上去前面的测试更加完美了， <strong>但是……</strong><br>我们的测试<code>case</code>出现错误的时候，我们会调用:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br></pre></td></tr></table></figure></p><p>打印我们的错误信息，但是这个错误信息打印后整个测试过程就结束了，如果我们有很多个<code>case</code>需要测试，而前面的<code>case</code>失败后就无法进行后面的测试了，这时候我们如果针对这个出错的<code>case</code>修改后，我们会发现其他的<code>case</code>有报错了，我们反复的修改，但是我们并不知道自己到底有多少个<code>case</code>是有问题的，我们无法一次性把问题修复好，照成我们工作量变大，并且效率变低，那么我们该如何改进这个情况呢?<br>我们知道问题出在<code>t.Fatalf</code>，那么我们可不可以即打印出错误信息又不让程序中断呢？答案是: 可以！ 我们使用<code>f.Errorf</code>替换<code>f.Fatalf</code><br><strong>可是…..</strong><br>如果某个<code>case</code>出现了<code>panic</code>同样会导致整个程序中断，所以这种方式治标不治本。那么我们该如何改进呢? Go 1.7 开始支持了 <a href="https://golang.org/doc/go1.7#testing" target="_blank" rel="noopener">sub test</a>。 下面我们就按照<code>Sub Test</code>的写法进行修改:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        got := Split(tc.input, tc.sep)</span><br><span class="line">                        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>t.Run</code>的源码我们看到:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span> tRunner(t, f)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实会诊对每个<code>case</code>启动一个<code>goroutine</code>， 所以其中一个出现了<code>panic</code>不会影响其他的<code>case</code>执行。</p><p>上面这种形态就是目前我们进行单元测试的<strong>最佳实践</strong>了。</p><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><h4 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h4><p>外部依赖是指我们的函数需要调用其他的函数，外部依赖有可能涉及到一些数据依赖，网络依赖等。关于单元测试中如何解决外部依赖的问题, 常用的方法是: <strong>Test Double(测试替身)</strong>, 而它也分很多种:</p><ul><li><strong>Dummy</strong> objects are passed around but never actually used. Usually they are just used to fill parameter lists.</li><li><strong>Fake</strong> objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).</li><li><strong>Stubs</strong> provide canned answers to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test.</li><li><strong>Spies</strong> are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.</li><li><strong>Mocks</strong> are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.</li></ul><p>看上去有点儿头大，分这么多类型而且他们的接线感觉也比较模糊，为了便于理解我们不对这些概念做过多的解读，我们后面把所有我们的工作都看做是<code>Mock</code></p><h4 id="编写可测试代码"><a href="#编写可测试代码" class="headerlink" title="编写可测试代码"></a>编写可测试代码</h4><h5 id="函数要短小"><a href="#函数要短小" class="headerlink" title="函数要短小"></a>函数要短小</h5><p><em>函数的第一规则是要短小。第二条规则是还要短小</em> ———— 《代码整洁之道》<br>至于如何才算短小，一般建议是不超过100行，也就是显示器一屏所显示的行数。<br>函数越短小那么单元测试的编写就越简单。</p><h5 id="函数功能要单一"><a href="#函数功能要单一" class="headerlink" title="函数功能要单一"></a>函数功能要单一</h5><p><em>函数应该做一件事。做好这件事。只做一件事。</em> ————–《代码整洁之道》<br>一个函数做的事情越少其逻辑越简单，难么对应的单元测试也就越简单。</p><h5 id="减少外部依赖"><a href="#减少外部依赖" class="headerlink" title="减少外部依赖"></a>减少外部依赖</h5><p>这里要明确的是我们要测试的是自己的函数而不是调用的函数，所以我们应该把中重点放到自己的函数上，至于外部依赖的函数越少越好，因为每个外部依赖都增加了我们单元测试的不确定性。</p><h5 id="依赖模块要方便-Mock"><a href="#依赖模块要方便-Mock" class="headerlink" title="依赖模块要方便 Mock"></a>依赖模块要方便 Mock</h5><p>为了专注我们自己模块的测试，对于外部的模块我们一般都会使用<code>Mock</code>的方法, 所以依赖模块如果好<code>Mock</code>的话测试起来就会方便很多，反之会很麻烦。</p><h5 id="方便依赖注入"><a href="#方便依赖注入" class="headerlink" title="方便依赖注入"></a>方便依赖注入</h5><p>一般我们<code>Mock</code>是通过依赖注入的方式，这种方式可以方便的更改依赖的对象的实现，而依赖注入的方式有好几种:</p><ul><li>通过变量赋值</li><li>通过参数传递</li><li>通过Set/Get方法</li></ul><h3 id="一个外部依赖的例子"><a href="#一个外部依赖的例子" class="headerlink" title="一个外部依赖的例子"></a>一个外部依赖的例子</h3><p>一个<code>User</code>包, 有一个通过<code>uid</code>获取分数<code>score</code>的方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">                Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">                Password: <span class="string">""</span>,</span><br><span class="line">                DB:       <span class="number">0</span>,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        _, err := client.Ping().Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">        <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个<code>Class</code>包，通过调用<code>user.Score</code>方法获取分数，根据分数给这个用户一个等级:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们要给<code>UserLevel</code>写单元测试，该怎么写呢？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">5</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestUserLevel (0.02s)</span><br><span class="line">    --- FAIL: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">        class_test.go:24: expected: N, got E</span><br><span class="line">    --- FAIL: TestUserLevel/C_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: C, got E</span><br><span class="line">    --- FAIL: TestUserLevel/B_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: B, got E</span><br><span class="line">    --- FAIL: TestUserLevel/A_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: A, got E</span><br><span class="line">    --- FAIL: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">        class_test.go:24: expected: W, got E</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    class   0.023s</span><br></pre></td></tr></table></figure></p><p>可以看到除了<code>Got Error</code>运行成功，其他的都失败了，因为我们本地并没有开启<code>redis</code>服务，所以是连不上的。如果我们要让这个测试用例通过，显然我们不能真的开启一个<code>redis</code>的服务，我们需要对<code>user.Score</code>进行<code>Mock</code></p><h4 id="Mock框架"><a href="#Mock框架" class="headerlink" title="Mock框架"></a>Mock框架</h4><p>go中<code>mock</code>的支持也有很多种:</p><ul><li><a href="https://github.com/golang/mock" target="_blank" rel="noopener">github.com/golang/mock</a></li><li><a href="https://github.com/bouk/monkey" target="_blank" rel="noopener">github.com/bouk/monkey</a></li><li><a href="https://github.com/smartystreets/goconvey" target="_blank" rel="noopener">github.com/smartystreets/goconvey</a></li><li><a href="https://github.com/stretchr/testify" target="_blank" rel="noopener">github.com/stretchr/testify</a></li><li><a href="https://github.com/prashantv/gostub" target="_blank" rel="noopener">github.com/prashantv/gostub</a></li></ul><p>每个框架都有自己的用法， 这里我那<code>github.com/bouk/monkey</code>来举例子, 改造一下我们的单元测试:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"bou.ke/monkey"</span></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        monkey.Patch(user.Score, mockScore)</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mockScore</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.014s</span><br></pre></td></tr></table></figure></p><h4 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h4><p>前面通过<code>Mock</code>框架我们可以在测试的时候替换原来的实现，这样就可以很方便的进行单元测试了,但是这种代码的实现方式其实并不符合面相对象设计的原则, 下面提出两个问题:</p><ol><li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?</li><li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？</li></ol><p>可见上面的方式不太灵活，面对复杂多变的需求无法很好的满足。这时就要求我们改用面相接口编程, 下面是我们使用面相接口编程的方式改进了上面的实现:<br><code>user</code>包增加了一个<code>User</code>接口，这个接口有一个函数<code>Score</code>, 然后定义了一个<code>defaultUser</code>, 并且实现了<code>Score</code>函数，最后定一个<code>New</code>函数向外输出这个<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>class</code>包调用由原来的通过包直接调用改为了增加一个<code>u</code>变量, 然后调用<code>u.Score</code>来获取信息:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    score, err := u.Score(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>class_test</code>不再依赖<code>mock</code>框架，而是实现了自己的<code>User</code>接口<code>mockUser</code>，替换了<code>user</code>包的<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u = mockUser&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.005s</span><br></pre></td></tr></table></figure></p><p>下面再来看上面提出的两个问题:</p><ol><li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?<br>答: 根据上面的实现可以看到，我们没有借助任何框架同样完成了<code>Mock</code>的效果</li><li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？<br>答: 由于面相接口编程，我们可以在user中增加一个实例实现从<code>mysql</code>获取数据的方法，调用者可以根据需求选择不同的实例，而且如果调用者对这个数据来源有自己的需求，甚至可以自己实现这个接口。</li></ol><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>上面的实现我们可以看到每次调用<code>var u =  user.New()</code>都会新建一个<code>defaultUser</code>对象，对于有些需要共享<code>defaultUser</code>状态的情况下，例如<code>defaultUser</code>中有一个常驻内存共享的数据, 我们在多个包调用的时候其实那得是不同的对象，为了共享这个数据我们把<code>user.New</code>改成下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样每次返回的其实都是同一个<code>defaultUser</code>。</p><h4 id="更方便的调用"><a href="#更方便的调用" class="headerlink" title="更方便的调用"></a>更方便的调用</h4><p>上面我们看出，修改为面相接口编程后我们需要通过依赖注入传递对象，但是这样会对调用者照成麻烦，我们是否可以在优化一下呢?<br>我们在<code>user</code>中增加一个函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以通过<code>user.Score</code>调用<code>du.Score</code>函数了，所以<code>class.go</code>的实现可以改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看上去不错，但是我们如何进行依赖注入呢？不然单元测试使用的是默认实现，我们没办法做单元测试了。前面其实我们提过依赖注入的方式有一个<code>Get/Set</code>方式，我们可以再修改一下<code>user</code>包:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> definedUser != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> definedUser.Score(uid)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> definedUser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">    definedUser = u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>class</code>不用修改，<code>class_test</code>修改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">int</span></span><br><span class="line">        want  <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">        <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">        <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">        <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">        <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">        <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user.SetUser(mockUser&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := UserLevel(tc.input)</span><br><span class="line">        t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> uid &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通过<code>user.SetUser</code>方法用自己的实现替换了之前默认的实现，这样我们就可以方便的进行单元测试了。<br>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.011s</span><br></pre></td></tr></table></figure></p><p>在大多数情况下，我们都是使用的默认实现，只有在我们必须要修改依赖的实现，或者单元测试时才会使用其他的实现，所以为了大多数的场景下调用简单，我们应该尽量使用这种方式来实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要回顾了一下关于单元测试的一些理论知识: </p><ul><li>测试的粒度应该是测试包中的可导出函数</li><li>测试的原则告诉我们应该是变测试变开发, 相互交替进行</li><li>测试的目的应该是测试行为，而不是测试具体的实现</li></ul><p>关于Go的单元测试可以分为三个阶段:</p><ul><li>初级阶段: 主要是认识Go的单元测试基本写法，以及如何利用Go的工具链运行单元测试及查看单元测试覆盖率的情况</li><li>进阶阶段: 主要是举一个单元测试的例子，通过不断改进这个单元测试的写法来告诉我们如何写出更好的单元测试</li><li>高级阶段: 介绍了如何写出可测试的函数，面对复杂的调用和多变得需求如何利用面相接口编程和依赖注入改进我们的程序的写法</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf" target="_blank" rel="noopener">Test-Driven Development By Example</a><br><a href="https://github.com/gopherchina/conference/blob/master/2019/1.4%20Testing%3B%20how%2C%20what%2C%20why%20-%20Dave%20.pdf" target="_blank" rel="noopener">Testing; how, what, why - Dave</a><br><a href="https://www.youtube.com/watch?v=EZ05e7EMOLM" target="_blank" rel="noopener">TDD, Where Did It All Go Wrong - Lan Cooper</a><br><a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" target="_blank" rel="noopener">The Three Laws of TDD.</a><br><a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">深度解读 - TDD（测试驱动开发）</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">单元测试wiki</a><br><a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">How to Write Go Code - Testing</a><br><a href="https://teamgaslight.com/blog/testing-behavior-vs-testing-implementation" target="_blank" rel="noopener">Testing Behavior vs. Testing Implementation</a><br><a href="http://codebetter.com/iancooper/2011/10/06/avoid-testing-implementation-details-test-behaviours/" target="_blank" rel="noopener">Avoid Testing Implementation Details, Test Behaviours</a><br><a href="https://baike.baidu.com/item/%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">边界条件测试</a><br><a href="https://item.jd.com/10064006.html" target="_blank" rel="noopener">代码整洁之道</a><br><a href="https://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">Mocks Aren’t Stubs</a><br><a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">TestDouble</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Go单元测试&quot;&gt;&lt;a href=&quot;#Go单元测试&quot; class=&quot;headerlink&quot; title=&quot;Go单元测试&quot;&gt;&lt;/a&gt;Go单元测试&lt;/h1&gt;&lt;p&gt;在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dependency inversion principle in Go</title>
    <link href="http://oohcode.com/2019/06/06/Dependency-inversion-principle-in-Go/"/>
    <id>http://oohcode.com/2019/06/06/Dependency-inversion-principle-in-Go/</id>
    <published>2019-06-06T06:54:25.000Z</published>
    <updated>2019-06-10T02:10:50.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="依赖反转原则在Go中使用"><a href="#依赖反转原则在Go中使用" class="headerlink" title="依赖反转原则在Go中使用"></a>依赖反转原则在Go中使用</h1><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a>有五个，分别是:</p><table><thead><tr><th>首字母</th><th>指代</th><th>概念</th></tr></thead><tbody><tr><td>S</td><td>单一功能原则</td><td>认为对象应该仅具有一种单一功能的概念。</td></tr><tr><td>O</td><td>开闭原则</td><td>认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td></tr><tr><td>L</td><td>里氏替换原则</td><td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。  参考契约式设计。</td></tr><tr><td>I</td><td>接口隔离原则</td><td>认为“多个特定客户端接口要好于一个宽泛用途的接口” 的概念。</td></tr><tr><td>D</td><td>依赖反转原则</td><td>认为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。 依赖注入是该原则的一种实现方式。</td></tr></tbody></table><p>这五个原则简称: <code>SOLID</code>。<br>在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。<br>该原则规定：</p><ul><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ul><p>该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。</p><p>在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。这种对于低层次组件的依赖限制了高层次组件被重用的可行性。</p><p>依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和低层组件划分到不同的包/库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。众多的设计模式，比如插件，服务定位器或者依赖反转，则被用来在运行时把指定的低层组件实现提供给高层组件。</p><p>应用依赖反转原则同样被认为是应用了<a href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">适配器模式</a>，例如：高层的类定义了它自己的适配器接口（高层类所依赖的抽象接口）。被适配的对象同样依赖于适配器接口的抽象（这是当然的，因为它实现了这个接口），同时它的实现则可以使用它自身所在低层模块的代码。通过这种方式，高层组件则不依赖于低层组件，因为它（高层组件）仅间接的通过调用适配器接口多态方法使用了低层组件，而这些多态方法则是由被适配对象以及它的低层模块所实现的。</p><blockquote><p><strong>前面一大堆其实都是从wiki上copy过来的，自己的理解有以下几点:</strong></p><ul><li>上层指<strong>调用者</strong>, 下层指<strong>被调用者</strong></li><li>原来的编程方式是上层调用下层的时候依赖下层具体的实现方式</li><li>依赖反转（或叫:依赖倒置)是指下层的实现依赖上层调用的需求</li><li>最终的解决方式是: 把上层的需求抽象成接口，上层依赖接口的抽象进行调用，下层依赖接口的抽象进行实现(下面要介绍的<strong>面相接口编程</strong>)</li></ul></blockquote><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a>是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</p><blockquote><p><strong>上面这段也是wiki上的, 自己理解:</strong></p><ul><li>依赖注入就是: 把下层依赖注入(或叫传递)到上层调用</li><li>要把提供服务的一方(也就是前面说的: 下层)作为实例传递给客户端(即:上层)</li><li>不要客户端在内部自己实现服务端的实例化。</li><li>这种方式的好处是: 可以通过传递不同的实例化对象来实现多态。</li></ul></blockquote><h3 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a>是前面实现依赖反转原则的具体方式。<br>基于接口的编程将应用程序定义为组件的集合，其中组件间的应用程序接口（API）调用可能只通过抽象化接口完成，而没有具体的类。类的实例化一般通过使用如<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener">工厂模式</a>等技术的其他接口完成。</p><blockquote><p><strong>这里也说一点自己的理解:</strong><br>上面说到要通过依赖注入方式传递实例，这个实例如何生成呢？如果每次都生成一个，如果这个实例是有状态的，那么每个拿到的可能都是不一样的，这样就<strong>无法共享</strong>。所以一般都是通过工厂模式产生一个实例，其他调用方要共享的话都通过这个工厂拿到<strong>同一个实例</strong>。</p></blockquote><p>另一种定义描述: 在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类</p><h4 id="面向接口编程和面向对象编程是什么关系"><a href="#面向接口编程和面向对象编程是什么关系" class="headerlink" title="面向接口编程和面向对象编程是什么关系:"></a>面向接口编程和面向对象编程是什么关系:</h4><p>首先，面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。</p><h4 id="接口的本质"><a href="#接口的本质" class="headerlink" title="接口的本质"></a>接口的本质</h4><h5 id="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"><a href="#接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念" class="headerlink" title="接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念"></a>接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界“如果你是……则必须能……”的理念</h5><p>例如，在自然界中，人都能吃饭，即“如果你是人，则必须能吃饭”。那么模拟到计算机程序中，就应该有一个Person接口，并有一个方法叫Eat()，然后我们规定，每一个表示“人”的类，必须实现Person接口，这就模拟了自然界“如果你是人，则必须能吃饭”这条规则。</p><p>从这里，我想各位也能看到些许面向对象思想的东西。面向对象思想的核心之一，就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。</p><h5 id="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"><a href="#接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同" class="headerlink" title="接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同"></a>接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为“同类事物”这个概念是相对的，它因为粒度视图不同而不同</h5><p>例如，在我的眼里，我是一个人，和一头猪有本质区别，我可以接受我和我同学是同类这个说法，但绝不能接受我和一头猪是同类。但是，如果在一个动物学家眼里，我和猪应该是同类，因为我们都是动物，他可以认为“人”和“猪”都实现了Animal这个接口，而他在研究动物行为时，不会把我和猪分开对待，而会从“动物”这个较大的粒度上研究，但他会认为我和一棵树有本质区别。</p><h4 id="面相接口编程的优点"><a href="#面相接口编程的优点" class="headerlink" title="面相接口编程的优点"></a>面相接口编程的优点</h4><ul><li>首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉。</li><li>使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工。</li></ul><blockquote><p><strong>关于面相接口编程的归纳:</strong></p><ul><li>面相接口是面向对象编程的重要部分</li><li>接口本质上是一组规则的集合，是一定粒度上有相同特指的对象的的抽象</li><li>面相接口编程可以提高编程的灵活性, 可以并行开发。</li></ul></blockquote><h2 id="Go-中的应用"><a href="#Go-中的应用" class="headerlink" title="Go 中的应用"></a>Go 中的应用</h2><h3 id="Go-中的接口"><a href="#Go-中的接口" class="headerlink" title="Go 中的接口"></a>Go 中的接口</h3><p>Go语言中，接口(interface)有其特殊的地方, 其他的语言一般要实现一个接口都需要显示的说明<br>例如<code>PHP</code>(这里没有贬低PHP的意思，大多数语言也是这种实现方式例如<code>C++</code>, <code>Python</code>, <code>Rust</code>等):<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare the interface 'iTemplate'</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the interface</span></span><br><span class="line"><span class="comment">// This will work</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span> <span class="keyword">implements</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $vars = <span class="keyword">array</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vars[$name] = $var;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;vars <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">            $template = str_replace(<span class="string">'&#123;'</span> . $name . <span class="string">'&#125;'</span>, $value, $template);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> $template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用到关键字 <code>implements</code>。<br>todo: 对比优缺点</p><p>而<code>Go</code>语言中，<code>interface</code>是<code>duck typing</code>(鸭子类型: If it looks like a duck, and it quacks like a duck, then it is a duck), 也就是如果一个对象实现了某个接口的方法，那么这个对象就是这个接口类型了，不需要显示说明是否实现了某个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Speaker types can say things.</span></span><br><span class="line"><span class="keyword">type</span> Speaker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Say(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person is a strut with filed name</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Say funciton is defined by Speaker and implement by Person</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Say</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  log.Println(p.name+<span class="string">":"</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>Person</code>实现了函数<code>Say</code>, 所以<code>Person</code>就是<code>Speaker</code>类型了。</p><h3 id="Go-中面相接口编程"><a href="#Go-中面相接口编程" class="headerlink" title="Go 中面相接口编程"></a>Go 中面相接口编程</h3><p>这种编程方式不仅是在 Go 语言中是被推荐的，在几乎所有的编程语言中，我们都会推荐这种编程的方式，它为我们的程序提供了非常强的灵活性，想要构建一个稳定、健壮的 Go 语言项目，不使用接口是完全无法做到的。</p><p>如果一个略有规模的项目中没有出现任何 type … interface 的定义，那么作者可以推测出这在很大的概率上是一个工程质量堪忧并且没有多少单元测试覆盖的项目，我们确实需要认真考虑一下如何使用接口对项目进行重构。</p><p>事实上官方库也都是按照这个思想来实现的，比如<code>net/http</code>包(对这个包的分析参考 <a href="/2017/07/01/how-golang-webserver-work/">golang 的 webserver 是如何工作的</a>)。当我们要启动一个http server时一般代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p>这个函数的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个参数是<code>Handler</code>类型, 这个函数的类型定义如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义的正是一个接口。这个接口只有一个函数<code>ServeHTTP</code>， 而最终对请求处理调用的也正是这个函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于第二个函数我们一般都会传<code>nil</code>, 所以会执行上面的逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler = DefaultServeMux</span><br></pre></td></tr></table></figure><p>而<code>DefaultServeMux</code>就是官方的默认实现。而我们也可以通过传递这个参数来实现自己的处理, 很多Web框架就是怎么做的，比如<code>gin</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    c := engine.pool.Get().(*Context)</span><br><span class="line">    c.writermem.reset(w)</span><br><span class="line">    c.Request = req</span><br><span class="line">    c.reset()</span><br><span class="line"></span><br><span class="line">    engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">    engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gin</code>自己实现了连接的处理方式，并且把这个实现作为参数传给<code>net/http</code>, 具体代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Run</span><span class="params">(addr ...<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; debugPrintError(err) &#125;()</span><br><span class="line"></span><br><span class="line">    address := resolveAddress(addr)</span><br><span class="line">    debugPrint(<span class="string">"Listening and serving HTTP on %s\n"</span>, address)</span><br><span class="line">    err = http.ListenAndServe(address, engine)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现正是前面说讲的: <strong>依赖接口编程</strong>，然后通过<strong>依赖注入</strong>把实例传入</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们有一个<code>user</code>包，里面是处理用户相关的信息, 还有一个<code>bank</code>包，<code>bank</code>会调用<code>user</code>的方法来获取一些用户信息, 刚开始他们的代码实现分别如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">    rows, err := db.Query(sql, uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    name, err := user.UserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果我们要给<code>bank</code>的<code>UserInfo</code>添加单元测试应该怎么做呢? 这里有以下几点问题:</p><ul><li>我们要测试的是<code>bank</code>的<code>UserInfo</code>函数，而不是为了测试这个函数都调用的函数，所以我们其实不太关心<code>user.UserName</code>里面的逻辑</li><li>我们要测试<code>UserInfo</code>就必须要从<code>UserName</code>获取一些信息，但是<code>UserName</code>的信息需要调用<code>db</code>才能获取，这里涉及到一些网络访问，会给我们的测试带来很多麻烦</li><li>我们需要把<code>UserName</code>给Mock掉<br>关于如何把<code>UserName</code> Mock掉, 其实我们可以借助一些<code>mock</code>的框架(比如<code>bou.ke/monkey</code>)来进行处理， 但是这种方法回避了设计上的一些问题，过度依赖会导致我们的代码质量堪忧，还有一些场景要求我们必须替换这个方法的实现，比如我们不想使用<code>user.UserName</code>的查询方式了，我们换了一种实现，这样我们就无法复用原来的代码了。<br>下面我们介绍如何利用上面介绍的知识来解决这个问题:</li></ul><h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>我们看一下第二版的代码<br><code>user</code>包:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">        UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DefaultUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">        rows, err := db.Query(sql, uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">                <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>bank</code>代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    name, err := u.UserName(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面我们都做了那些修改呢?</p><ul><li>面向接口编程<br>我们定义了一个接口类型<code>User</code>:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">        UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后<code>user</code>包用<code>DefaultUser</code>来实现了这个方法，所以<code>DefaultUser</code>就是这个类型的包了<br><code>bank</code>中定义了一个变量<code>var u = user.New()</code>, 由于<code>user.New()</code>的类型也是<code>User</code>，所以<code>u</code>的类型就是<code>User</code>, 然后在<code>UserInfo</code>函数中调用<code>User</code>类型的<code>UserName</code>方法<br>也就是说<code>user</code>和<code>bank</code>都是面向<code>User</code>来进行编程的</p><ul><li>依赖注入<br>我们第一个版本是直接调用<code>user.UserName</code>函数, 但是我们无法自己去修改这个函数的实现，所以我们通过<code>var u = user.New()</code>来获取<code>user</code>给我传递的一个对象，这样我们就可以通过<code>u</code>来调用<code>UserName</code>函数了，这时<code>user.New</code>就实现了依赖注入，这样做我们就可以通过覆盖<code>u</code>这个实例，来完成自己的实现了，下面</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>面对版本二, 我们怎么实现<code>bank.UserInfo</code>的单元测试呢？<br><code>bank_test.go</code>来看一下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u mockUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> uid == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"John"</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserInfo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    u = mockUser&#123;&#125;</span><br><span class="line">    cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        uid  <span class="keyword">int</span></span><br><span class="line">        res  <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">"test1"</span>, <span class="number">1</span>, <span class="string">"something was wrong"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test2"</span>, <span class="number">2</span>, <span class="string">"not found this user"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test3"</span>, <span class="number">3</span>, <span class="string">"user name is John"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        t.Run(v.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            info := UserInfo(v.uid)</span><br><span class="line">            <span class="keyword">if</span> info != v.res &#123;</span><br><span class="line">                t.Errorf(<span class="string">"got %s; want %s"</span>, info, v.res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go test -v</span><br><span class="line">=== RUN   TestUserInfo</span><br><span class="line">=== RUN   TestUserInfo/test1</span><br><span class="line">=== RUN   TestUserInfo/test2</span><br><span class="line">=== RUN   TestUserInfo/test3</span><br><span class="line">--- PASS: TestUserInfo (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test1 (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test2 (0.00s)</span><br><span class="line">    --- PASS: TestUserInfo/test3 (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      bank    0.013s</span><br></pre></td></tr></table></figure><p>首先我们定义了一个<code>mockUser</code>, 然后实现了<code>UserName</code>函数，所以这时<code>mockUser</code>已经是<code>User</code>类型了，然后我们在测试函数里通过<code>u = mockUser</code>替换掉了运来的<code>var u = user.New()</code>, 这时候在执行<code>UserInfo</code>调用的其实就是<code>mockUser.UserName</code>函数了，完美的完成了我们的单元测试。</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>前面我们虽然用依赖注入的方式完成了调用，但是还有一个问题, 当我们依赖注入的时候用的是<code>var u = user.New()</code>的方式来获取的，但是在错综复杂的调用过程中，我们难免会多次调用<code>user.New()</code>函数，而且我们还要共享同一个<code>User</code>， 这时候就要求我们使用工厂模式保证不管多少次调用，返回的都是同一个<code>User</code>, 在上面的代码中其实很好改:<br>我们把<code>user</code>中的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改为下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultUser = DefaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们每次返回的都是<code>user</code>内部的<code>defaultUser</code>这个实例，而这个实例只初始化了一次, 所有通过这个方法获取的实例都是同一个实例</p><h4 id="简化调用"><a href="#简化调用" class="headerlink" title="简化调用"></a>简化调用</h4><p>有时候我们会觉得每次调用都通过依赖注入的传递一个对象，会使得调用变的复杂起来，比如本来我们调用的时候只需要<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.UserName()</span><br></pre></td></tr></table></figure></p><p>而现在可能我们的调用变成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var u = user.New()</span><br><span class="line">u.UserName()</span><br></pre></td></tr></table></figure></p><p>那么我们如何使用更符合<code>go</code>的方式，直接使用包调用而不是每次都传递一个对象呢？我们可以改为下面的方式:<br><code>user</code>的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    UserName(<span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultUser = DefaultUser&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> definedUser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultUser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">        definedUser = u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserName return the name of user with uid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DefaultUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        sql := <span class="string">"select name from user where uid = ?"</span></span><br><span class="line">        rows, err := db.Query(sql, uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">                <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> definedUser == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defaultUser.UserName(uid)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> definedUser.UserName(uid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们新增加了一个变量<code>definedUser</code>来表示用户自定义的实例，然后通过<code>SetUser</code>来对其进行复制，我们同时增加了一个包级别的<code>UserName</code>函数，里面的实现会判断如果有<code>definedUser</code>那么我们就是用这个自定义的实现，如果没有我们就调用默认的实现</p><p><code>bank</code>的实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo if uid exist return the name of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfo</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        name, err := user.UserName(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"something was wrong"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"not found this user"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user name is "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bank</code>的实现跟第一个版本一样，如果我们不需要修改默认实现，对于调用来说非常方便，我们不用关系其内部的具体实现。</p><p><code>bank_test</code>的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u mockUser)</span> <span class="title">UserName</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> uid == <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"John"</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"something was wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserInfo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        user.SetUser(mockUser&#123;&#125;)</span><br><span class="line">        cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">                name <span class="keyword">string</span></span><br><span class="line">                uid  <span class="keyword">int</span></span><br><span class="line">                res  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                &#123;<span class="string">"test1"</span>, <span class="number">1</span>, <span class="string">"something was wrong"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"test2"</span>, <span class="number">2</span>, <span class="string">"not found this user"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"test3"</span>, <span class="number">3</span>, <span class="string">"user name is John"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> cases &#123;</span><br><span class="line">                t.Run(v.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        info := UserInfo(v.uid)</span><br><span class="line">                        <span class="keyword">if</span> info != v.res &#123;</span><br><span class="line">                                t.Errorf(<span class="string">"got %s; want %s"</span>, info, v.res)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>bank_test</code>由于要对<code>UserName</code>进行Mock, 用自己的实现来替换原来的实现，我们只需要在测试的时候调用<code>SetUser</code>函数，就完成了替换。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">面向对象设计的设计原则</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面相接口编程</a><br><a href="https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html" target="_blank" rel="noopener">面向接口编程详解（一）——思想基础</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://gocn.vip/article/1764" target="_blank" rel="noopener">使用Golang的interface接口设计原则</a><br><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d" target="_blank" rel="noopener">Duck typing in Go</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;依赖反转原则在Go中使用&quot;&gt;&lt;a href=&quot;#依赖反转原则在Go中使用&quot; class=&quot;headerlink&quot; title=&quot;依赖反转原则在Go中使用&quot;&gt;&lt;/a&gt;依赖反转原则在Go中使用&lt;/h1&gt;&lt;h2 id=&quot;依赖反转原则&quot;&gt;&lt;a href=&quot;#依赖反转原则&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go 调度器抢占方式</title>
    <link href="http://oohcode.com/2019/05/28/go-scheduler-preemption/"/>
    <id>http://oohcode.com/2019/05/28/go-scheduler-preemption/</id>
    <published>2019-05-28T02:35:56.000Z</published>
    <updated>2019-05-29T02:56:21.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS-调度"><a href="#OS-调度" class="headerlink" title="OS 调度"></a>OS 调度</h2><h2 id="Go-调度"><a href="#Go-调度" class="headerlink" title="Go 调度"></a>Go 调度</h2><p>被抢占后把 g 状态从 <code>_Grunning</code> 改为 <code>_Grunnable</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">"bad g status"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">    dropg()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    globrunqput(gp)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Go-调度的问题"><a href="#Go-调度的问题" class="headerlink" title="Go 调度的问题"></a>Go 调度的问题</h2><h3 id="deadloop"><a href="#deadloop" class="headerlink" title="deadloop"></a>deadloop</h3><p>Go的抢占需要依赖函数的调用，只有在函数调用(准确的说是函数调用产生morestack调用的时候)的时候才会进行真正的强占，那么对于下面的这个方式:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个死循环，而且里面没有任何函数调用，也不会进行栈的扩张，所以这个goroutine永远不会被抢占。<br>参考<a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a> 这篇文档的说明，我们看一下具体的问题及解决方案。<br>// todo: 继续完善上篇文章中的例子</p><h3 id="deadloop-amp-GC"><a href="#deadloop-amp-GC" class="headerlink" title="deadloop &amp; GC"></a>deadloop &amp; GC</h3><p>还有这样一个<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">88</span> &#123;</span><br><span class="line">                runtime.GC()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// the wrong part</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">                sum += &lt;-ch</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个程序也会hang死。</p><p>下面这段代码在主goroutine中运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// the wrong part</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ch) == <span class="number">100</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        itemNum := <span class="built_in">len</span>(ch)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; itemNum; i++ &#123;</span><br><span class="line">            sum += &lt;-ch</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum == itemNum &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个程序由于没有函数的调用和<code>Goshced()</code>的主动调用所以会通过<code>阻塞监控</code>的方式被动弃权。</p><h4 id="runtime-GC"><a href="#runtime-GC" class="headerlink" title="runtime.GC"></a>runtime.GC</h4><p>当执行 <code>runtime.GC()</code>的时候都发生了什么？我们来看一下<br>通过<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">dlv</a>这个工具我们可以对这个程序进行断点调试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv debug go run gc.go</span><br></pre></td></tr></table></figure></p><p>函数会执行到 <code>stopTheWorldWithSema</code> 这个函数，这个函数主要作用是停止所有的P，然后进行垃圾回收，我们通过一步一步调试发现, 这个函数会下面这个循环中无法出来:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么会在这个地方无法出来？下面分析一下具体原因。</p><p>GC种一个步骤是要把所有的 p 都设置为<code>_Pgcstop</code> 状态后才能继续进行。 下面看看这个步骤是否能够完成。</p><p><code>stopTheWorldWithSema</code>函数更加详细的执行过程如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we hold a lock, then we won't be able to stop another M</span></span><br><span class="line">    <span class="comment">// that is blocked trying to acquire the lock.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"stopTheWorld: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.stopwait = gomaxprocs <span class="comment">// 设置stopwait的初始值为最大的 p 的个数</span></span><br><span class="line">    atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>) <span class="comment">// 设置 gcwaiting = 1, 表示正在进入GC状态</span></span><br><span class="line">    preemptall() <span class="comment">// 给所有的 p 发送抢占信号，如果成功，则对应的 p 进入 idle 状态</span></span><br><span class="line">    <span class="comment">// stop current P</span></span><br><span class="line">    _g_.m.p.ptr().status = _Pgcstop <span class="comment">// Pgcstop is only diagnostic.</span></span><br><span class="line">    sched.stopwait-- <span class="comment">// 给他当前的设置状态后，stopwait个数减一 </span></span><br><span class="line">    <span class="comment">// try to retake all P's in Psyscall status</span></span><br><span class="line">    <span class="comment">// 遍历所有的 p 如果满足条件(p的状态为 _Psyscall)则释放这个 p , 并且把 p 的状态都设置成 _Pgcstop ; 然后stopwait--</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        s := p.status</span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                traceGoSysBlock(p)</span><br><span class="line">                traceProcStop(p)</span><br><span class="line">            &#125;</span><br><span class="line">            p.syscalltick++</span><br><span class="line">            sched.stopwait--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stop idle P's</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := pidleget() <span class="comment">//获取idle 状态的 p, 从 _Pidle list 获取</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        p.status = _Pgcstop <span class="comment">// 把 p 状态设置为 _Pgcstop</span></span><br><span class="line">        sched.stopwait-- <span class="comment">// 计数 stopwait --</span></span><br><span class="line">    &#125;</span><br><span class="line">    wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line">    <span class="keyword">if</span> wait &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">            <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">                noteclear(&amp;sched.stopnote)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再次给所有的 p 发送 抢占信号</span></span><br><span class="line">            preemptall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面函数把所有非<code>_Prunning</code>状态的 p 都设置为了 <code>_Pgcstop</code> 状态，对于 <code>_Prunning</code> 状态的 p 如何设置其为 <code>_Pgcstop</code> 状态呢? 主要是通过 <code>preemptall()</code>函数给每个 p 发送抢占信号<br><code>preemptall()</code> 其实时调用了 <code>preemptone()</code> 前面我们已经讲了具体的原理。被抢占后 p 重新进入调度阶段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">        stoplockedm()</span><br><span class="line">        execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不应该调度一个正在执行 cgo 调用的 g</span></span><br><span class="line">    <span class="comment">// 因为 cgo 在使用当前 m 的 g0 栈</span></span><br><span class="line">    <span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line">    <span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">        throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果还在等待 gc，则</span></span><br><span class="line">        gcstopm()</span><br><span class="line">        <span class="keyword">goto</span> top <span class="comment">// 循环执行</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面说调度器会会把 <code>gcwaiting</code>设置为<code>1</code>, 所以这里会进入 <code>gcstopm()</code>, 直到所有的 m 都被<code>stop</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcstopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"gcstopm: not waiting for gc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// OK to just drop nmspinning here,</span></span><br><span class="line">        <span class="comment">// startTheWorld will unpark threads as necessary.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"gcstopm: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _p_ := releasep()</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    _p_.status = _Pgcstop <span class="comment">//设置 p 状态为 _Pgcstop</span></span><br><span class="line">    sched.stopwait--</span><br><span class="line">    <span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">        notewakeup(&amp;sched.stopnote)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    stopm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>gcstopm()</code> 会把 p 的状态置为 <code>_Pgcstop</code>。</p><p><strong>但是死循环的 g 不会被抢占，所以其 p 状态会一直是  Prunning 无法被设置为 Pgcstop</strong></p><p>再回到前面进入死循环的地方:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for remaining P's to stop voluntarily</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">        <span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">            noteclear(&amp;sched.stopnote)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        preemptall()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里进入死循环的原因是条件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) == <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>不满足<br><code>notetsleep</code>函数内部每隔一段时间就会返回:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> atomic.Load(key32(&amp;n.key)) != <span class="number">0</span> <span class="comment">// n.key 为参数 &amp;shced.stopnote.key的值</span></span><br></pre></td></tr></table></figure></p><p>这个函数意思是<code>&amp;sched.stopnote.key != 0</code><br>如果要想让返回值为 <code>true</code> 就需要满足上面的条件。 <code>stopnote.key</code>的值有两个函数可以控制:</p><ul><li><code>notewakeup</code> 把 <code>stopnote</code> 设置为 1</li><li><code>noteclear 把</code>stopnote<code>设置为 0所以我们需要调用</code>notewakeup<code>才行。而这个函数我们可以看到是在</code>gcstopm()`种有调用:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sched.stopwait--</span><br><span class="line"><span class="keyword">if</span> sched.stopwait == <span class="number">0</span> &#123;</span><br><span class="line">    notewakeup(&amp;sched.stopnote)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>由于存在 g 无法被抢占，所以其对应的 p 不会释放, <code>stopwait</code>也就不能为<code>0</code>, 所以也就无法执行<code>notewakeup</code>,最终导致上面的循环无法出来。</p><p>死锁状态的发生:</p><ul><li>GC: 要想进行<code>GC</code>就需要所有的P都转为空闲状态，而主<code>goroutine</code>无法被抢占，对应的<code>P</code>也无法进入空闲。所以<code>GC</code>会一直阻塞。</li><li>新启动的<code>goroutine</code>: 由于新启动的<code>goroutine</code>也进入了空闲状态</li><li>主<code>goroutine</code>: 由于新启动的<code>goroutine</code>进入了空闲状态,无法再给<code>chan</code>发信号，所以主<code>goroutine</code>也无法退出。<br>由于上面三个都进入了阻塞状态，导致了整个程序进入了死锁状态。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html" target="_blank" rel="noopener">scheduling-in-go-part1</a><br><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html" target="_blank" rel="noopener">scheduling-in-go-part2</a><br><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html" target="_blank" rel="noopener">scheduling-in-go-part3</a><br><a href="https://github.com/two/go-under-the-hood/blob/master/book/part2runtime/ch06sched/preemptive.md" target="_blank" rel="noopener">go-under-the-hood</a><br><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">non-cooperative-preemption</a><br><a href="https://gocn.vip/article/441" target="_blank" rel="noopener">如何定位 golang 进程 hang 死的 bug</a><br><a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=the-simple-analysis-of-goroutine-schedule-examples" target="_blank" rel="noopener">Goroutine调度实例简要分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OS-调度&quot;&gt;&lt;a href=&quot;#OS-调度&quot; class=&quot;headerlink&quot; title=&quot;OS 调度&quot;&gt;&lt;/a&gt;OS 调度&lt;/h2&gt;&lt;h2 id=&quot;Go-调度&quot;&gt;&lt;a href=&quot;#Go-调度&quot; class=&quot;headerlink&quot; title=&quot;Go 
      
    
    </summary>
    
    
      <category term="Go" scheme="http://oohcode.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>【译】 Go 语言机制之栈和指针 (1)</title>
    <link href="http://oohcode.com/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/"/>
    <id>http://oohcode.com/2019/03/04/Language-Mechanics-On-Stacks-And-Pointers/</id>
    <published>2019-03-04T05:29:19.000Z</published>
    <updated>2019-03-12T12:11:15.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列的文章主要是帮助你理解指针，栈，堆，逃逸分析和值/指针语义的设计和机制。本系列一共有四篇，这是第一篇。本篇主要是介绍栈和指针。</p><p>本系列文章索引:<br>1) Go 语言机制之栈和指针<br>2) Go 语言机制之逃逸分析<br>3) Go 语言机制之内存性能分析<br>4) Go 语言机制之数据和语义的使用原则</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我并不打算美化指针，因为指针真的很难理解。如果我们使用不当，指针能够产生很难理解的 bug 甚至影响性能。 在写并发程序或者多线程程序时这种问题更为明显。这也难怪很多语言试图对开发者隐藏指针的使用。尽管如此，如果你是用 Go 来开发程序，你是没有办法避免使用指针的。相对于深入的理解指针，你更应该关注如何写出干净，简单并且有效的代码。</p><a id="more"></a><h1 id="帧边界"><a href="#帧边界" class="headerlink" title="帧边界"></a>帧边界</h1><p>帧边界为每个函数提供了独立的内存空间的，这些函数都运行在自己的内存空间中。每个帧都允许他自己的函数操作他的上下文并且能够提供流程控制。一个函数可以通过帧指针直接访问它所在帧的内存，但如果要访问帧外的内存就需要间接访问。为了能够让函数访问所在帧外的内存, 这个内存需要在函数之间共享。帧边界之间的这种限制和原则是需要首先明白的。<br>当一个函数被调用时在两个帧之间就会出现上下文切换。代码会从调用的函数所在的帧切换到被调用函数所在的帧。如果函数调用需要传递数据，这个数据必须要从一个帧传输到另一个帧。两个帧之间的数据传递在 Go 中是通过”值传递”来完成的。<br>通过”值传递”来传输数据的优点是可读性好。你说看到的值就是函数调用被复制和接收到的值。这就是我为什么说”值传递”是 WYSIWYG(what you see is what you get)，所见即所得。所有这些都使你在编写两个函数 调用时不会隐藏上下文切换的成本。”值传递”会帮助你很好的理解当函数调用时所产生的影响。</p><p>下面这段代码就是函数通过”值传递”来传输整形数据的例子:</p><p>list 1:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Declare variable of type int with a value of 10.</span></span><br><span class="line">   count := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Display the "value of" and "address of" count.</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"count:\tValue Of["</span>, count, <span class="string">"]\tAddr Of["</span>, &amp;count, <span class="string">"]"</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pass the "value of" the count.</span></span><br><span class="line">   increment(count)</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"count:\tValue Of["</span>, count, <span class="string">"]\tAddr Of["</span>, &amp;count, <span class="string">"]"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(inc <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Increment the "value of" inc.</span></span><br><span class="line">   inc++</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"inc:\tValue Of["</span>, inc, <span class="string">"]\tAddr Of["</span>, &amp;inc, <span class="string">"]"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你的程序启动的时候, runtime 就会创建 main goroutine 开始初始化main 函数中的代码。一个 goroutine 就是存在于操作系统线程（ 最终会运行在一些核上）的一个执行路径。Go 1.8版本以后每个 goroutine 回初始化2048字节(byte)的栈空间。这个初始化栈空间在过去几年发生过几次变化了， 未来也可能会再次修改。<br>栈非常重要，因为它为每个独立的函数提供了祯边界之间的物理内存空间。当 list 1 的 main 函数执行的时候，goroutine 的栈空间如下图所示:</p><p>Figure 1:<br><img src="/assets/img/golang/80_figure1.png" alt></p><p>在 Figure 1 中你可以看到，<code>main</code>函数对应的栈已经被创建出来了。 这块儿空间被成为『栈帧』, 这个框表示的是<code>main</code>函数的堆边界。当函数被调用的时候，这个帧是正在执行的代码的一部分。可以看到变量<code>count</code>被放到了<code>main</code>函数的帧中地址为<code>0x10429fa4</code> 的地方。</p><p>Figure 1 同样也表明了一个非常有趣的点。 当前活动的帧下面所有堆内存都是不可用的，但是从这个帧开始上面的地址是可用的。我需要清晰的知道堆中可用和不可用的部分的边界。</p><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>变量的目的是为了给一个特定的内存地址进行命名，以便于提高程序的可读性，并且能够帮助你了解自己正在使用的数据。如果你有一个变量的话你就必须在内存中有一个变量值，如果你有一个变量值你就必须有一个内存地址。在<code>line 9</code>, <code>main</code>函数调用一个内置的函数<code>println</code>来输出变量<code>count</code>的值和地址<br>Listing 2</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"count:\tValue Of["</span>, count, <span class="string">"]\tAddr Of["</span>, &amp;count, <span class="string">"]"</span>)</span><br></pre></td></tr></table></figure><p>使用符号<code>&amp;</code>来获取变量的地址已经不陌生了，很多语言也是这样使用的。如果你在32bit的机器上运行这段代码的话，第<code>9</code>行代码的输出与下面的形式很相似：<br>listing 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]</span><br></pre></td></tr></table></figure></p><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>在<code>12</code>行代码, <code>main</code>函数调用了<code>increment</code>函数:<br>Listing 4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increment(count)</span><br></pre></td></tr></table></figure></p><p>函数调用意味着<code>goroutine</code>需要在内存栈中申请一段新的内存。然而，事情比较复杂。为了能够成功的调用这个函数，数据需要突破帧边界放到新的帧中。举个例子就是整型数据需要被复制并且在调用的过程中被传递。可以根据<code>increment</code>函数18行的函数定义看到。<br>Listing 5<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(inc <span class="keyword">int</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure></p><p>如果再回来看<code>12</code>行代码<code>increment</code>函数的调用，可以看到代码传递的是变量<code>count</code>的值。这个值会被复制，然后放到<code>increment</code>函数所在的新帧中。需要记住一点，<code>increment</code>函数只能够直接读写他自己帧中的内存地址，所以它需要变量<code>inc</code>能接收，存储并且访问传递过来的<code>count</code>的副本。<br>在<code>increment</code>函数开始执行之前，<code>goroutine</code>栈的结构如下:<br><img src="/assets/img/golang/80_figure2.png" alt><br>现在可以看到栈中有两个帧,一个是<code>main</code>函数的，在它下面是<code>increment</code>函数的。在<code>increment</code>函数的帧中，可以看到变量<code>inc</code>的值是<code>10</code>，这个值是在函数调用的时候复制并传递过来的。变量<code>inc</code>的地址是<code>0x10429f98</code>, 这个地址在内存中比较低，是因为栈是向增长的, 这是内部实现的一个细节，这里不需要关注。重要的是<code>toroutine</code>把<code>main</code>函数中的变量<code>count</code>的值得副本传递到了函数<code>increment</code>中的变量<code>inc</code>。<br>函数<code>increment</code>剩下的代码就是打印出变量<code>inc</code>的值和地址。<br>Listing 6<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inc++</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"inc:\tValue Of["</span>, inc, <span class="string">"]\tAddr Of["</span>, &amp;inc, <span class="string">"]"</span>)</span><br></pre></td></tr></table></figure></p><p>第<code>12</code>行代码的输出与下面的形式很相似:<br>Listing 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc:    Value Of[ 11 ]  Addr Of[ 0x10429f98 ]</span><br></pre></td></tr></table></figure></p><p>执行完函数调用后，内存中栈的结构如下:<br>Figure 3<br><img src="/assets/img/golang/80_figure3.png" alt><br><code>21</code>行和<code>22</code>行代码执行完后函数<code>increment</code>就把控制权交回给了<code>main</code>函数。然后<code>main</code>函数在<code>14</code>行打印出了变量<code>count</code>的值和地址。<br>Listing 8<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"count:\tValue Of["</span>,count, <span class="string">"]\tAddr Of["</span>, &amp;count, <span class="string">"]"</span>)</span><br></pre></td></tr></table></figure></p><p>这个函数完整的输出入下:<br>Listing 9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]</span><br><span class="line">inc:    Value Of[ 11 ]  Addr Of[ 0x10429f98 ]</span><br><span class="line">count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]</span><br></pre></td></tr></table></figure></p><p>在函数<code>increment</code>函数调用前和调用后，变量<code>count</code>的值在<code>main</code>函数所在的帧中值是一样的。</p><p>函数返回值<br>在内存栈中当被调用的函数把控制权返还给调用函数的时候到底发生了什么？一句话来回答就是:什么也没发生。下面就是当<code>increment</code>函数返回后栈的结构:<br>Figure 4<br><img src="/assets/img/golang/80_figure4.png" alt><br>这个栈结构和<code>Figure 3</code>的结构一模一样，唯一的区别就是函数<code>increment</code>所在的帧现在是无法访问的内存了。因为现在<code>main</code>函数是工作的帧, 为函数<code>increment</code>创建的帧是无法访问的。<br>为被调用的函数返回后帧所占用的内存进行清除是一个比较费时间的，因为你不知道这些内存是否会被再次用到。所以当函数调用时这些帧需要被再次用到时帧所占用的内存才会被清除，否则就会放在那不管。<br>通常在每次函数调用中，栈都会进行清除，一般都是在帧中进行变量初始化的时候完成的，因为每个变量都会被初始化，即使是使用默认值, 初始化的时候就需要占用内存。</p><h1 id="共享值"><a href="#共享值" class="headerlink" title="共享值"></a>共享值</h1><p>如果我们想让函数<code>increment</code>直接操作<code>main</code>函数中的变量<code>count</code>该怎么做呢？这时候就需要指针了。指针存在的目的就是为了让函数共享一个值以便能够读写变量的值, 及时这个值不在它自己的帧中。<br>如果你不需要共享，那就不需要用到指针。学习指针的时候重要的是清晰的词汇而不是语法或者操作符。所以记住指针是为了共享，读代码的时候不要用操作符<code>&amp;</code>来代替共享的意思。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个系列的文章主要是帮助你理解指针，栈，堆，逃逸分析和值/指针语义的设计和机制。本系列一共有四篇，这是第一篇。本篇主要是介绍栈和指针。&lt;/p&gt;
&lt;p&gt;本系列文章索引:&lt;br&gt;1) Go 语言机制之栈和指针&lt;br&gt;2) Go 语言机制之逃逸分析&lt;br&gt;3) Go 语言机制之内存性能分析&lt;br&gt;4) Go 语言机制之数据和语义的使用原则&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;我并不打算美化指针，因为指针真的很难理解。如果我们使用不当，指针能够产生很难理解的 bug 甚至影响性能。 在写并发程序或者多线程程序时这种问题更为明显。这也难怪很多语言试图对开发者隐藏指针的使用。尽管如此，如果你是用 Go 来开发程序，你是没有办法避免使用指针的。相对于深入的理解指针，你更应该关注如何写出干净，简单并且有效的代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://oohcode.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>golang http client 连接池</title>
    <link href="http://oohcode.com/2018/06/01/golang-http-client-connection-pool/"/>
    <id>http://oohcode.com/2018/06/01/golang-http-client-connection-pool/</id>
    <published>2018-06-01T02:44:03.000Z</published>
    <updated>2019-03-04T04:37:02.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>golang标准库<code>net/http</code>做为<code>client</code>时有哪些细节需要注意呢，这里做一个详细的分析。</p></blockquote><h2 id="net-http-client工作流程"><a href="#net-http-client工作流程" class="headerlink" title="net/http client工作流程"></a>net/http client工作流程</h2><p>首先分析一下<code>client</code>的工作流程。 下面是一般我们进行一个请求时的代码事例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoRequest</span><span class="params">(req *http.Request)</span> <span class="params">(MyResponse, error)</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response := MyResponse&#123;&#125;</span><br><span class="line">    response.Header = resp.Header</span><br><span class="line">    ...</span><br><span class="line">    response.Body = body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中我们首先创建一个<code>http.Client</code>, 所有的值都是默认值，然后调用<code>client.Do</code>发请求，<code>req</code>是我们请求的结构体。这里我们也可以用<code>client.Get</code>, <code>client.Post</code>等函数来调用，从他们的源码来看都是调用的<code>client.Do</code>。<br><code>client.Do</code>的实现在<code>net/http</code>包的<code>go/src/net/http/client.go</code>源文件中。可以看到函数内部主要是实现了一些参数检查，默认值设置，以及对于多跳请求的处理，最为核心的就是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// c.send() always closes req.Body</span></span><br><span class="line">            reqBodyClosed = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">                err = &amp;httpError&#123;</span><br><span class="line">                    err:     err.Error() + <span class="string">" (Client.Timeout exceeded while awaiting headers)"</span>,</span><br><span class="line">                    timeout: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shouldRedirect <span class="keyword">bool</span></span><br><span class="line">redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !shouldRedirect &#123;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这里真正发请求的函数就是<code>c.send</code>, 这个函数的实现也比较简单, 主要是调用了<code>send</code>函数，这个函数的实现主要如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// didTimeout is non-nil only if err != nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send issues an HTTP request.</span></span><br><span class="line"><span class="comment">// Caller should close resp.Body when done reading from it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line">    ...</span><br><span class="line">        resp, err = rt.RoundTrip(req)</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里真正进行网络交互的定位到的函数是<code>rt.RoundTrip</code>,这个函数的定义是一个<code>interface</code>，从其注释也可以看出他的主要作用是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// RoundTrip executes a single HTTP transaction, returning</span><br><span class="line">// a Response for the provided Request.`</span><br></pre></td></tr></table></figure></p><p>由于这个函数是一个<code>interface</code>我们需要知道是谁实现了这个函数，看一下<code>send</code>的参数就可以找到，实现这个函数的是<code>c.transport()</code>的返回值，这个函数的实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Transport</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到，返回的对象是<code>c.Transport</code>或者<code>DefaultTransport</code>, 由于我们创建<code>client</code>的时候没有设置<code>c.Transport</code>参数，所以这里返回的应该是<code>DefaultTransport</code>对象, 这个对象对<code>RoundTripper</code>函数的实现大概如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip implements the RoundTripper interface.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For higher-level HTTP client support (such as handling of cookies</span></span><br><span class="line"><span class="comment">// and redirects), see Get, Post, and the Client type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">                pconn, err := t.getConn(treq, cm)</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="comment">// HTTP/2 path.</span></span><br><span class="line">                    t.setReqCanceler(req, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">                        resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp, err = pconn.roundTrip(treq)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里面具体的细节我们先不关系，对于<code>HTTP/2</code>的处理我们也先不关心。这里需要重点关注的是<code>t.getConn</code>这个函数。<code>t.getConn</code>的作用是获取一个链接，这个链接该怎么获取，是一个值得深究的问题。下面看一下这个函数的关键实现细节:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getConn dials and creates a new persistConn to the target as</span></span><br><span class="line"><span class="comment">// specified in the connectMethod. This includes doing a proxy CONNECT</span></span><br><span class="line"><span class="comment">// and/or setting up TLS.  If this doesn't return an error, the persistConn</span></span><br><span class="line"><span class="comment">// is ready to write requests to.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">req := treq.Request</span><br><span class="line">         trace := treq.trace</span><br><span class="line">         ctx := req.Context()</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GetConn(cm.addr())</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">if</span> pc, idleSince := t.getIdleConn(cm); pc != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">             trace.GotConn(pc.gotIdleConnTrace(idleSince))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// set request canceler to some non-nil function so we</span></span><br><span class="line">         <span class="comment">// can detect whether it was cleared between now and when</span></span><br><span class="line">         <span class="comment">// we enter roundTrip</span></span><br><span class="line">         t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;&#125;)</span><br><span class="line">             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">         handlePendingDial := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             testHookPrePendingDial()</span><br><span class="line">                 <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> v := &lt;-dialc; v.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                         t.putOrCloseIdleConn(v.pc)</span><br><span class="line">                     &#125;</span><br><span class="line">                     testHookPostPendingDial()</span><br><span class="line">                 &#125;()</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">cancelc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">             t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123; cancelc &lt;- err &#125;)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                 pc, err := t.dialConn(ctx, cm)</span><br><span class="line">                     dialc &lt;- dialRes&#123;pc, err&#125;</span><br><span class="line">             &#125;()</span><br><span class="line">idleConnCh := t.getIdleConnCh(cm)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> v := &lt;-dialc:</span><br><span class="line">                            <span class="comment">// Our dial finished.</span></span><br><span class="line">                            <span class="keyword">if</span> v.pc != <span class="literal">nil</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &amp;&amp; v.pc.alt == <span class="literal">nil</span> &#123;</span><br><span class="line">                                    trace.GotConn(httptrace.GotConnInfo&#123;Conn: v.pc.conn&#125;)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> v.pc, <span class="literal">nil</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Our dial failed. See why to return a nicer error</span></span><br><span class="line">                            <span class="comment">// value.</span></span><br><span class="line">                            <span class="keyword">select</span> &#123;</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                    <span class="comment">// It was an error due to cancelation, so prioritize that</span></span><br><span class="line">                                    <span class="comment">// error value. (Issue 16049)</span></span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                                <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                                <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                                          <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                              err = errRequestCanceledConn</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                                <span class="keyword">default</span>:</span><br><span class="line">                                              <span class="comment">// It wasn't an error due to cancelation, so</span></span><br><span class="line">                                              <span class="comment">// return the original error message:</span></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">nil</span>, v.err</span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="keyword">case</span> pc := &lt;-idleConnCh:</span><br><span class="line">                             <span class="comment">// Another request finished first and its net.Conn</span></span><br><span class="line">                             <span class="comment">// became available before our dial. Or somebody</span></span><br><span class="line">                             <span class="comment">// else's dial that they didn't use.</span></span><br><span class="line">                             <span class="comment">// But our dial is still going, so give it away</span></span><br><span class="line">                             <span class="comment">// when it finishes:</span></span><br><span class="line">                             handlePendingDial()</span><br><span class="line">                                 <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">                                     trace.GotConn(httptrace.GotConnInfo&#123;Conn: pc.conn, Reused: pc.isReused()&#125;)</span><br><span class="line">                                 &#125;</span><br><span class="line">                             <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                                 handlePendingDial()</span><br><span class="line">                                     <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">                    <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                                     handlePendingDial()</span><br><span class="line">                                         <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">                    <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                              handlePendingDial()</span><br><span class="line">                                  <span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">                                      err = errRequestCanceledConn</span><br><span class="line">                                  &#125;</span><br><span class="line">                              <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是这个过程的流程图:<br><img src="http://www.plantuml.com/plantuml/svg/NP3DYi8m58NNvYcohA-WIv-as5I39HbCD-vcm9_IHHsm54P1Pa2NC-fcb2deopHf-XRUDjQ1XcnoxpddVhd2jyS-eYwsiZJIjwsAzkhqgQEpN2R5wWhFDlQ7X65hGaGROJWTVOlbPckwNKGyGR35UDbq-NY4MXqPR6JwfvAZ2UmQcmf3ur7nLGR7_EUhU5ivrFRwsUNxeG68kc8O_XFAR6mFRCfW0kYCdpeUwN76UiE6HGPhkCKYX6dvUbhJrYG0PoYXz_XsHVLSWGeI_JhhUroGnlGgGiv-ipGfuWzzECZTD7-Vboh27BC3KE36cfX3NIHy_d87"><br>从上面可以看到，获取链接会优先从连接池中获取，如果连接池中没有可用的连接，则会创建一个连接或者从刚刚释放的连接中获取一个，这两个过程时同时进行的，谁先获取到连接就用谁的。<br>当新创建一个连接, 创建连接的函数定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error)</span><br></pre></td></tr></table></figure></p><p>最后这个函数会通过goroutine调用两个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go pconn.readLoop()</span><br><span class="line">go pconn.writeLoop()</span><br></pre></td></tr></table></figure></p><p>其中<code>readLoop</code>主要是读取从server返回的数据,<code>writeLoop</code>主要发送请求到server,在<code>readLoop</code>函数中有这么一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Put the idle conn back into the pool before we send the response</span><br><span class="line">// so if they process it quickly and make another request, they&apos;ll</span><br><span class="line">// get this same conn. But we use the unbuffered channel &apos;rc&apos;</span><br><span class="line">// to guarantee that persistConn.roundTrip got out of its select</span><br><span class="line">// potentially waiting for this persistConn to close.</span><br><span class="line">// but after</span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">    pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br></pre></td></tr></table></figure></p><p>这里可以看出，在处理完请求后，会立即把当前连接放到连接池中。</p><p>上面说到连接池，每个<code>client</code>的连接池结构是这样的:<code>idleConn   map[connectMethodKey][]*persistConn</code>。其中<code>connectMethodKey</code>的值就是<code>client</code>连接的server的<code>host</code>值, map的值是一个<code>*persistConn</code>类型的<code>slice</code>结构，这里就是存放连接的地方，<code>slice</code>的长度由<code>MaxIdleConnsPerHost</code>这个值指定的，当我们不设置这个值的时候就取默认的设置:<code>const DefaultMaxIdleConnsPerHost = 2</code>。</p><p>另外这里我们插一个知识点，对于HTTP协议，有一个header值”Connections”, 这个值的作用就是<code>client</code>向<code>server</code>端发请求的时候，告诉<code>server</code>是否要保持连接。具体的可以参考<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank" rel="noopener">rfc2616</a>。 这个协议头的值有两种可能(参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">MDN文档</a>):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p><p>当值为<code>keep-alive</code>时，<code>server</code>端会保持连接，一直到连接超时。当值为<code>close</code>时,<code>server</code>端会在传输完<code>response</code>后主动断掉<code>TCP</code>连接。在<code>HTTP/1.1</code>之前，这个值默认是<code>close</code>, 之后是默认<code>keep-alive</code>, 而<code>net/http</code>默认的协议是<code>HTTP/1.1</code>也就是默认<code>keep-alive</code>, 这个值可以通过<code>DisableKeepAlives</code>来设置。</p><p>从上面的介绍我们可以看出，<code>net/http</code>默认是连接复用的，对于每个server会默认的连接池大小是2。<br>接下来我们看一下连接是如何放进连接池的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">putOrCloseIdleConn</span><span class="params">(pconn *persistConn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pconn.<span class="built_in">close</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span></span><br><span class="line"><span class="comment">// a new request.</span></span><br><span class="line"><span class="comment">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span></span><br><span class="line"><span class="comment">// an error explaining why it wasn't registered.</span></span><br><span class="line"><span class="comment">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errKeepAlivesDisabled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.isBroken() &#123;</span><br><span class="line">        <span class="keyword">return</span> errConnBroken</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errNotCachingH2Conn</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.markReused()</span><br><span class="line">    key := pconn.cacheKey</span><br><span class="line"></span><br><span class="line">    t.idleMu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> t.idleMu.Unlock()</span><br><span class="line">    waitingDialer := t.idleConnCh[key]</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> waitingDialer &lt;- pconn:</span><br><span class="line">        <span class="comment">// We're done with this pconn and somebody else is</span></span><br><span class="line">        <span class="comment">// currently waiting for a conn of this type (they're</span></span><br><span class="line">        <span class="comment">// actively dialing, but this conn is ready</span></span><br><span class="line">        <span class="comment">// first). Chrome calls this socket late binding. See</span></span><br><span class="line">        <span class="comment">// https://insouciant.org/tech/connection-management-in-chromium/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> waitingDialer != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// They had populated this, but their dial won</span></span><br><span class="line">            <span class="comment">// first, so we can clean up this map entry.</span></span><br><span class="line">            <span class="built_in">delete</span>(t.idleConnCh, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.wantIdle &#123;</span><br><span class="line">        <span class="keyword">return</span> errWantIdle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.idleConn == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.idleConn = <span class="built_in">make</span>(<span class="keyword">map</span>[connectMethodKey][]*persistConn)</span><br><span class="line">    &#125;</span><br><span class="line">    idles := t.idleConn[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(idles) &gt;= t.maxIdleConnsPerHost() &#123;</span><br><span class="line">        <span class="keyword">return</span> errTooManyIdleHost</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, exist := <span class="keyword">range</span> idles &#123;</span><br><span class="line">        <span class="keyword">if</span> exist == pconn &#123;</span><br><span class="line">            log.Fatalf(<span class="string">"dup idle pconn %p in freelist"</span>, pconn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">    t.idleLRU.add(pconn)</span><br><span class="line">    <span class="keyword">if</span> t.MaxIdleConns != <span class="number">0</span> &amp;&amp; t.idleLRU.<span class="built_in">len</span>() &gt; t.MaxIdleConns &#123;</span><br><span class="line">        oldest := t.idleLRU.removeOldest()</span><br><span class="line">        oldest.<span class="built_in">close</span>(errTooManyIdle)</span><br><span class="line">        t.removeIdleConnLocked(oldest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.IdleConnTimeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pconn.idleTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">            pconn.idleTimer.Reset(t.IdleConnTimeout)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pconn.idleAt = time.Now()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先会尝试把连接放入到连接池中，如果不成功则<code>关闭连接</code>,大致流程如下:<br><img src="http://www.plantuml.com/plantuml/svg/XP5FJy8m6CRl-nGzmispauEHWyQO-1LgU8UDIsVMuf-4WqOM5rHYuX914m864gC1528I8F9brcux-HMS82Cxg3sqJVi-lxvF7yQnoHMYeKIQCBoZmoR0_gfE3e2XL0fnCmSedqTR-6WZeyEQGIdR1dFTO1ojeAKauhj0KU8OM591uLWMLY-uRVcJgYmrLGLq1YX1ZVcbVIz6GtTmuWwUl7OzEBqvn8GJcaqJh8FfEO_ki1GAfTFtdY_4LIyuBqhdmxih-6y5ERnMqPIZ6URUT3E5kkEoi6nPBCuU3Uk5rHJsImpj3bhgGX9lSduCD1FX4SvYGXUA36WuftDXru9A8qRs9vN8pUVuCYXtPUiXA8z4lQh-YXDMNxJF0gVYTpgXwEz-mZLo_1tKZy_NcdZlob7zlmnYg7WUix-AU54jqPHe_W80"><br>如果<code>DisableKeepAlives</code>为<code>true</code>表示不使用连接复用，所以请求完后会把连接关掉，但是这里需要注意的是，同时发请求的时候我们会设置<code>Connections: close</code>, 所以<code>server</code>端发送完数据后就会自动断开，所以这种情况的连接其实是<code>server</code>端发起的。</p><h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>前面我们已经讲过<code>net/http</code>默认使用<code>HTTP/1.1</code>协议，也就是默认发送<code>Connections: keep-alive</code>的头，让服务端保持连接，就是所谓的长连接。<br>再看<code>DefaultTransport</code>的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// DefaultTransport is the default implementation of Transport and is</span><br><span class="line">// used by DefaultClient. It establishes network connections as needed</span><br><span class="line">// and caches them for reuse by subsequent calls. It uses HTTP proxies</span><br><span class="line">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and</span><br><span class="line">// $no_proxy) environment variables.</span><br><span class="line">var DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment, //代理使用</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   30 * time.Second, //连接超时时间</span><br><span class="line">        KeepAlive: 30 * time.Second, //连接保持超时时间</span><br><span class="line">        DualStack: true, //</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    MaxIdleConns:          100, //client对与所有host最大空闲连接数总和</span><br><span class="line">    IdleConnTimeout:       90 * time.Second, //空闲连接在连接池中的超时时间</span><br><span class="line">    TLSHandshakeTimeout:   10 * time.Second, //TLS安全连接握手超时时间</span><br><span class="line">    ExpectContinueTimeout: 1 * time.Second, //发送完请求到接收到响应头的超时时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们使用<code>DefaultTransport</code>时，就是默认使用的长连接。但是默认的连接池<code>MaxIdleConns</code>为100， <code>MaxIdleConnsPerHost</code>为2，当超出这个范围时，客户端会主动关闭到连接。<br>如果我们想设置为短连接，有几种方法:</p><ol><li>设置<code>DisableKeepAlives = true</code>: 这时就会发送<code>Connections:close</code>给server端，在server端响应后就会主动关闭连接。</li><li>设置<code>MaxIdleConnsPerHost &lt; 0</code>: 当<code>MaxIdleConnsPerHost &lt; 0</code>时，连接池是无法放置空闲连接的，所以无法复用,连接直接会在<code>client</code>端被关闭。</li></ol><h2 id="Server端出现大量的TIME-WAIT"><a href="#Server端出现大量的TIME-WAIT" class="headerlink" title="Server端出现大量的TIME_WAIT"></a>Server端出现大量的<code>TIME_WAIT</code></h2><p>当我们在实际使用时，会发现<code>Server</code>端出现了大量的<code>TIME_WAIT</code>,要想深入了解其原因，我们首先先回顾一下<code>TCP</code>三次握手和四次分手的过程:<br><img src="/assets/img/golang/tcp_3_handshake.png" alt><br><img src="/assets/img/golang/tcp_4_handshake.png" alt><br>图中可以看出，<code>TIME_WAIT</code>只会出现在主动关闭连接的一方,也就是<code>server</code>端出现了大量的主动关闭行为。<br>默认我们是使用长连接的，只有在超时的情况下<code>server</code>端才会主动关闭连接。前面也讲到，如果超出连接池的部分就会在<code>client</code>端主动关闭连接，连接池的连接会复用，看着似乎没有什么问题。问题出在我们每次请求都会<code>new</code>一个新的<code>client</code>,这样每个<code>client</code>的连接池里的连接并没有得到复用，而且这时<code>client</code>也不会主动关闭这个连接，所以<code>server</code>端出现了大量的<code>keep-alive</code>但是没有请求的连接，就会主动发起关闭。</p><p>todo:补充tcpdump的分析结果</p><p>要解决这个问题以下几个方案:</p><ol><li><code>client</code>复用，也就是我们尽量复用<code>client</code>，来保证<code>client</code>连接池里面的连接得到复用，而减少出现超时关闭的情况。</li><li>设置<code>MaxIdleConnsPerHost &lt; 0</code>：这样每次请求后都会由<code>client</code>发起主动关闭连接的请求，<code>server</code>端就不会出现大量的<code>TIME_WAIT</code></li><li><p>修改<code>server</code>内核参数: 当出现大量的<code>TIME_WAIT</code>时危害就是导致<code>fd</code>不够用,无法处理新的请求。我们可以通过设置<code>/etc/sysctl.conf</code>文件中的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure><p> 达到快速回收和重用的效果，不影响其对新连接的处理。</p></li></ol><p>另外需要注意的是，虽然<code>DisableKeepAlives = true</code>也能满足连接池中不放空闲连接，但是这时候会发送<code>Connections: close</code>，这时<code>server</code>端还是会主动关闭连接，导致大量的<code>TIME_WAIT</code>出现，所以这种方法行不通。</p><p>以上就是我总结的关于<code>net/http</code>中连接池相关的知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;golang标准库&lt;code&gt;net/http&lt;/code&gt;做为&lt;code&gt;client&lt;/code&gt;时有哪些细节需要注意呢，这里做一个详细的分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;net-http-client工作流程&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="golang" scheme="http://oohcode.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>亿级流量网站架构核心技术总结</title>
    <link href="http://oohcode.com/2017/08/03/the-core-technology-of-high-traffic-website/"/>
    <id>http://oohcode.com/2017/08/03/the-core-technology-of-high-traffic-website/</id>
    <published>2017-08-03T05:27:30.000Z</published>
    <updated>2019-03-04T04:37:02.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近读了《亿级流量网站架构核心技术——跟开涛学搭建高可用高并发系统》这本书，总体感觉这本书很实用，作者根据自己负责的项目经历以及业务的发展过程和业界的理论基础相结合讲解了如何搭建一个具有高并发和高可用特征的电商网站。作者是京东的架构师，进来随着京东业务的不断发展，6.18和双十一活动规模的不断扩大，作者都亲身经历了整个电商网站的发展过程，相对于单纯的理论，这本书更多的是能够在业务中快速应用的经验总结。下面就这两方面我把作者的思维导图搬过来，不断提醒自己要注意的整体思想，并能够深入浅出，根据思维导图的每一项都有一个自己更发散更深入的认识。</p></blockquote><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><img src="/assets/img/cthtw/High-availability.png" alt="高可用"></p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="/assets/img/cthtw/High-concurrency.png" alt="高并发"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近读了《亿级流量网站架构核心技术——跟开涛学搭建高可用高并发系统》这本书，总体感觉这本书很实用，作者根据自己负责的项目经历以及业务的发展过程和业界的理论基础相结合讲解了如何搭建一个具有高并发和高可用特征的电商网站。作者是京东的架构师，进来随着京东
      
    
    </summary>
    
    
      <category term="java" scheme="http://oohcode.com/tags/java/"/>
    
      <category term="架构" scheme="http://oohcode.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="高并发" scheme="http://oohcode.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高可用" scheme="http://oohcode.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>golang channels 的串联,扇入扇出及控制</title>
    <link href="http://oohcode.com/2017/07/12/golang-goroutines-1/"/>
    <id>http://oohcode.com/2017/07/12/golang-goroutines-1/</id>
    <published>2017-07-12T02:06:03.000Z</published>
    <updated>2019-03-04T04:37:02.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。 一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。 channel之间可以进行串联，并联等组合，组成我们想要的运行方式。 不同goroutine之间需要同步，也需要控制，具体该如何处理这些情况，下面分别进行介绍。</p></blockquote><h2 id="channel基础"><a href="#channel基础" class="headerlink" title="channel基础"></a>channel基础</h2><p>使用内置的make函数，我们可以创建一个channel:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type 'chan int'</span></span><br></pre></td></tr></table></figure></p><p>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。<br>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。<br>一个channel有发送和接受两个主要操作，都是通信行为。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch     <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure></p><p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></table></figure></p><p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></p><h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的Channels</h3><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。<br>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。</p><p>对于不带缓存的Channels，我们使用的是有必须放到goroutine,因为如果直接调用<code>chanx &lt;- 1</code>时，会报错<code>fatal error: all goroutines are asleep - deadlock!</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chanx &lt;- <span class="number">1</span> <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p><p>由于主goroutine调用了 <code>chanx &lt;-1</code>, 但是由于是顺序往下执行，执行时还不存在监听<code>chanx</code>的方法存在，所以数据放入<code>chanx</code>后无法唤醒接收的方法，只能等待下去，所以就产生了deadlock。<br>可以修改为下面的形式，把<code>chanx &lt;- 1</code>放入到一个goroutine里，然后主goroutine监听了这个<code>chanx</code>，当往<code>chanx</code>放数据的时候就会有接收的方法被调用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;chanx &lt;- <span class="number">1</span>&#125;() <span class="comment">//right</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p><p><strong>当使用<code>range</code>遍历<code>chan</code>时别忘了close</strong>, 下面当没有使用close时:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>output:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive]:</span><br></pre></td></tr></table></figure></p><p><code>range</code>会从<code>channel</code>中接收数据直到<code>channel</code>被<code>close</code>为止，正常情况下<code>close</code>并不是必须的，只有在接收者需要知道没有更多的数据进入的时候才需要，而<code>range</code>正是需要知道这个信息的。所以代码改成下面这样就没问题了:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(chanx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="带缓存的Channels"><a href="#带缓存的Channels" class="headerlink" title="带缓存的Channels"></a>带缓存的Channels</h3><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p><p><strong>队列元素为1的带缓存Channels与不带缓存的Channels是不同的</strong>，下面的例子可以看出:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan_nobuffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan_nobuffer &lt;- <span class="number">1</span> <span class="comment">//error 必须放到goroutine中</span></span><br><span class="line">    &lt;-chan_nobuffer</span><br><span class="line"></span><br><span class="line">    chan_buffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    chan_buffer &lt;- <span class="number">1</span> <span class="comment">//right</span></span><br><span class="line">    &lt;-chan_buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><p>channel还有两种语法:<code>&lt;-chan int</code>和<code>chan&lt;- int</code>，其意思是单方向的channel, 当定义为<code>out chan&lt;- int</code>表示<code>out</code>只能被往里面放数据，不允许从out拿数据,否则程序会报错<code>receive from send-only type chan&lt;- int</code>,如果定义为<code>in &lt;-chan int</code>则<code>in</code>只能往外输出数据，不允许往<code>in</code>里面放数据，否则报错<code>send to receive-only type &lt;-chan int</code></p><h2 id="channel串联"><a href="#channel串联" class="headerlink" title="channel串联"></a>channel串联</h2><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。 这种串联的Channels就是所谓的管道（pipeline）。下图就是一个串联的channel示意:<br><img src="/assets/img/golang/goroutines_0712_1.png" alt="串联channel"><br>第一个goroutine Counter负责生成一个0,1,2,3,…形式的整数序列,然后把整数序列输入到一个channel中，通过这个channel传递个下一个goroutine Squarer, 负责将从channel接收到的数求平方，然后再把得出的结果通过channel传递给goroutine Printer, Printer负责将从channel接收的数据打印出来。<br>其程序实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> Counter(chan1)</span><br><span class="line">    <span class="keyword">go</span> Squarer(chan2, chan1)</span><br><span class="line">    Printer(chan2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中我们创建了两个chan, 然后调用了<code>Counter</code>和<code>Squarer</code>, 由于上面说:<strong>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。</strong>所以我们对chan1和chan2的修改都是全局的。<br><code>Counter</code>往chan1中陆续放入了<code>0,1,2,3,...</code>等数列，然后同步的<code>Squarer</code>接收到数据对其平方并放入<code>chan2</code>,最后<code>Printer</code>从<code>chan2</code>中输出这些数据。<br>对于串联的Channel还有另外一种实现方法:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    out := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            out &lt;- n*n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的<code>gen</code>函数用到了golang的<strong>可变参数</strong>这个特性，跟上面的<code>Counter</code>不一样的是，这个<code>gen</code>会把<code>chan</code>当做返回值返回，而不是作为参数传入。<code>sq</code>函数也跟<code>Squarer</code>函数不一样了:把上一个函数的chan最为参数，下一个输出的chan作为返回值。</p><h2 id="channel扇入扇出"><a href="#channel扇入扇出" class="headerlink" title="channel扇入扇出"></a>channel扇入扇出</h2><p><strong>扇出</strong>：同一个 channel 可以被多个函数读取数据，直到channel关闭。 这种机制允许将工作负载分发到一组worker，以便更好地并行使用 CPU 和 I/O。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    c1 := sq(c)</span><br><span class="line">    c2 := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c1 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"-------------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c2 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是几种输出样式，可以知道当调用两次<code>sq</code>时，其实是对chan的扇出操作，既一个channel被多个函数读取了。每次读取的顺序和个数都不能保证。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span> </span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">9</span></span><br><span class="line">#<span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">------------------</span><br><span class="line">#<span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><strong>扇入</strong>：多个 channel 的数据可以被同一个函数读取和处理，然后合并到一个 channel，直到所有 channel都关闭。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed, then calls wg.Done.</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            out &lt;- n <span class="comment">//对于每个chan其中的元素都放到out中 </span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done() <span class="comment">//减少一个goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs)) <span class="comment">//要执行的goroutine个数</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        <span class="keyword">go</span> output(c) <span class="comment">//对传入的多个channel执行output</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a goroutine to close out once all the output goroutines are</span></span><br><span class="line">    <span class="comment">// done.  This must start after the wg.Add call.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait() <span class="comment">//等待，直到所有goroutine都完成后</span></span><br><span class="line">        <span class="built_in">close</span>(out) <span class="comment">//所有的都放到out后关闭</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>merge</code>函数的参数也是变长的，类型是<code>chan</code>, 这个函数还用到了<code>sync</code>这个包，这里主要的作用就是对一组goroutines进行同步。首先把传入的cs都通过<code>output</code>调用放入<code>out</code>中，每处理完一个<code>c</code>就调用<code>wg.Done()</code>更新剩余的次数, <code>wg.Wait()</code>等到所有的channels把数据放到<code>out</code>中，然后关闭<code>out</code>。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    out2 := sq(c)</span><br><span class="line">    out1 := sq(c)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> merge(out1, out2) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下图就展示了扇入扇出的过程:<br><img src="/assets/img/golang/goroutines_0712_2.png" alt="串联channel"></p><h2 id="goroutines控制"><a href="#goroutines控制" class="headerlink" title="goroutines控制"></a>goroutines控制</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">The Go Blog - pipelines</a></li><li><a href="https://segmentfault.com/a/1190000006261218" target="_blank" rel="noopener">Go语言并发模型：像Unix Pipe那样使用channel</a></li><li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-04.html" target="_blank" rel="noopener">Go语言圣经-channels</a></li><li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-05.html" target="_blank" rel="noopener">Go语言圣经-并发的循环</a></li><li><a href="https://docs.hacknode.org/gopl-zh/ch5/ch5-07.html" target="_blank" rel="noopener">Go语言圣经-可变参数</a></li><li><a href="https://deepzz.com/post/golang-context-package-notes.html" target="_blank" rel="noopener">快速掌握 Golang context 包</a></li><li><a href="https://tour.golang.org/concurrency/4" target="_blank" rel="noopener">A Tour of Go - Range and Close</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。 一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。 channel之间可以进行串联，并联等组
      
    
    </summary>
    
    
      <category term="golang" scheme="http://oohcode.com/tags/golang/"/>
    
      <category term="goroutines" scheme="http://oohcode.com/tags/goroutines/"/>
    
  </entry>
  
  <entry>
    <title>golang的webserver是如何工作的</title>
    <link href="http://oohcode.com/2017/07/01/how-golang-webserver-work/"/>
    <id>http://oohcode.com/2017/07/01/how-golang-webserver-work/</id>
    <published>2017-07-01T01:29:38.000Z</published>
    <updated>2019-03-04T04:37:02.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们知道golang实现一个webserver非常简单，但是其内部是如何工作的呢，我们深入探究一下其原理。</p></blockquote><h2 id="实现一个webserver服务"><a href="#实现一个webserver服务" class="headerlink" title="实现一个webserver服务"></a>实现一个webserver服务</h2><p>下面我们就用golang内置的服务实现一个简单的webserver:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        r.ParseForm()       <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">        fmt.Println(r.Form) <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">        fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">        fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">        fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">                fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">                fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        http.HandleFunc(<span class="string">"/hello"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以通过<code>go run main.go</code>来开启Server服务, 当我们访问<code>http://localhost:8090/</code>或<code>http://localhost:8090/hello</code>都会得到<code>Hello astaxie!</code>, 也就是都执行了<code>sayhelloName</code>函数。<br>下面让我们来分析一下服务的代码:<br>首先我们从<code>main</code>函数入口进入程序执行，首先执行了<code>http.HandleFunc(&quot;/&quot;, sayhelloName)</code>和<code>http.HandleFunc(&quot;/hello&quot;, sayhelloName)</code>两个方法，这两个方法其实就是设置路由及其对应的处理函数。<br>然后执行<code>http.ListenAndServe(&quot;:8090&quot;, nil)</code>这个函数开始监听8090端口并把用户的请求根据之前设置的路由规则交给特定的函数进行处理。<br>下面我将针对这两个函数进行深入的分析。</p><h2 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a>http.HandleFunc</h2><p>这个函数是<code>net/http</code>包中定义的, 第一个参数<code>pattern</code>是<code>string</code>类型，表示匹配的URL, 第二个参数<code>handler</code>这是个函数类型，表示一个处理函数。其定义在<code>net/http/server.go</code>中，第一如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数调用了下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HandelrFunc</code>定义如下, 声明为一个函数类型, <code>HandlerFunc(handler)</code>就是把<code>handler</code>强制类型转化为<code>HandlerFunc</code>类型<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure></p><p><code>mux.Handle</code>的定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helpful behavior:</span></span><br><span class="line">    <span class="comment">// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span></span><br><span class="line">    <span class="comment">// It can be overridden by an explicit registration.</span></span><br><span class="line">    n := <span class="built_in">len</span>(pattern)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line">        <span class="comment">// If pattern contains a host name, strip it and use remaining</span></span><br><span class="line">        <span class="comment">// path for redirect.</span></span><br><span class="line">        path := pattern</span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line">            <span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">            path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">        &#125;</span><br><span class="line">        url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">        mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出这个函数会把<code>pattern</code>和<code>handler</code>的对应关系读存储到<code>mux.m</code>这个map里了，<code>mux</code>类型是<code>ServeMux</code>,其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">    hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过上面的处理后通过<code>http.HandleFunc</code>设置的<code>pattern</code>与<code>handler</code>的对应关系都被存储到了<code>DefaultServeMux</code>这个对象的<code>m</code>中。</p><h2 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a>http.ListenAndServe</h2><p>这个函数也是在<code>net/http/server.go</code>中定义的，其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面函数最终对调用到下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn(srv, l)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srv.trackListener(l, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">defer</span> srv.trackListener(l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里通过一个for循环不停的接收请求<code>l.Accept()</code>来得到接收的请求，然后再通过<code>go c.serve(ctx)</code>进行请求的处理。这里用到了协程，也就是每个请求其实是由单独的协程进行处理的，这也是golang作为webserver高效的原因所在。<code>c.serve</code>函数中有一个<code>for</code>循环，会不断读取同一个请求的数据，直到出现问题或者正确读取完毕。读取完请求后会调用<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>这个函数来处理请求。这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="当-handler-为-nil"><a href="#当-handler-为-nil" class="headerlink" title="当 handler 为 nil:"></a>当 handler 为 nil:</h3><p>可以看到当我们不在<code>ListenAndServe</code>中传递<code>handler</code>时，也就是<code>sh.srv.Handler = nil</code>时<code>hanlder=DefaultServeMux</code>，这个 <code>DefaultServeMux</code>正式我们前面通过<code>http.HandleFunc</code>来设置的。 下面调用了<code>hanlder.ServeHTTP</code>，这里也就是调用了<code>DefaultServeMux.ServeHTTP</code>, 这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数中的<code>mux.Handler</code>从请求<code>r</code>中找到请求的URL然后在去<code>mux.m</code>的map结构中找到对应的映射关系从而得出<code>h</code>这个处理函数名。<br>由于上面说过<code>h</code>是转换为类型<code>HandlerFunc</code>, 这个类型定义的<code>ServeHTTP</code>函数如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以调用<code>h.ServeHTTP(w,r)</code>就等于调用<code>h(w,r)</code>，也就是我们调用我们自己的写的处理函数。<br>这些都完成后会执行收尾工作，并把得到的结构返回给请求用户。</p><h3 id="当-handler-不为-nil"><a href="#当-handler-不为-nil" class="headerlink" title="当 handler 不为 nil:"></a>当 handler 不为 nil:</h3><p>这时调用<code>h.ServerHTTP(w,r)</code>其实就是调用自己传入的<code>handler</code>的<code>ServerHTTP</code>函数，例如web框架<code>revel</code>的源码<code>github.com/revel/cmd/harness/harness.go</code>中执行<code>revel run app</code>是就会执行下面的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the harness, which listens for requests and proxies them to the app</span></span><br><span class="line"><span class="comment">// server, which it runs and rebuilds as necessary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> paths []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> revel.Config.BoolDefault(<span class="string">"watch.gopath"</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">        gopaths := filepath.SplitList(build.Default.GOPATH)</span><br><span class="line">        paths = <span class="built_in">append</span>(paths, gopaths...)</span><br><span class="line">    &#125;</span><br><span class="line">    paths = <span class="built_in">append</span>(paths, revel.CodePaths...)</span><br><span class="line">    watcher = revel.NewWatcher()</span><br><span class="line">    watcher.Listen(h, paths...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        addr := fmt.Sprintf(<span class="string">"%s:%d"</span>, revel.HTTPAddr, revel.HTTPPort)</span><br><span class="line">        revel.INFO.Printf(<span class="string">"Listening on %s"</span>, addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        <span class="keyword">if</span> revel.HTTPSsl &#123;</span><br><span class="line">            err = http.ListenAndServeTLS(</span><br><span class="line">                addr,</span><br><span class="line">                revel.HTTPSslCert,</span><br><span class="line">                revel.HTTPSslKey,</span><br><span class="line">                h)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = http.ListenAndServe(addr, h)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            revel.ERROR.Fatalln(<span class="string">"Failed to start reverse proxy:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kill the app on signal.</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(ch, os.Interrupt, os.Kill)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    <span class="keyword">if</span> h.app != <span class="literal">nil</span> &#123;</span><br><span class="line">        h.app.Kill()</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这里也调用了`</span>http.ListenAndServe<span class="string">`但是第二个参数`</span>hanlder<span class="string">`传入了`</span>h<span class="string">`，所以最终会调用`</span>h.ServerHTTP<span class="string">`函数, 这个函数`</span>revel<span class="string">`中是这么实现的:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="comment">// ServeHTTP handles all requests.</span></span><br><span class="line"><span class="comment">// It checks for changes to app, rebuilds if necessary, and forwards the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Reverse proxy the request.</span></span><br><span class="line">    <span class="comment">// (Need special code for websockets, courtesy of bradfitz)</span></span><br><span class="line">    <span class="keyword">if</span> strings.EqualFold(r.Header.Get(<span class="string">"Upgrade"</span>), <span class="string">"websocket"</span>) &#123;</span><br><span class="line">        proxyWebsocket(w, r, h.serverHost)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h.proxy.ServeHTTP(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们知道golang实现一个webserver非常简单，但是其内部是如何工作的呢，我们深入探究一下其原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实现一个webserver服务&quot;&gt;&lt;a href=&quot;#实现一个webserver服务&quot; 
      
    
    </summary>
    
    
      <category term="golang" scheme="http://oohcode.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现总结——独立功能的实现</title>
    <link href="http://oohcode.com/2017/03/11/The-Design-and-Implementation-of-Redis-4/"/>
    <id>http://oohcode.com/2017/03/11/The-Design-and-Implementation-of-Redis-4/</id>
    <published>2017-03-11T02:16:04.000Z</published>
    <updated>2019-03-04T04:37:02.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>通过执行<code>SUBSCRIBE</code>命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者(subscriber):每当其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息。<br>除了订阅频道之外，客户端还可以通过执行<code>PSUBSCRIBE</code>命令订阅一个或多个模式，从而成为这些模式的订阅者:每当有其他客户端祥某个频道发送消息时，消息不仅会被发送给这个频道所有订阅者，它还会被发送给所有与这个频道匹配的模式的订阅者。<br>Redis将所有频道的订阅管系都保存在服务器状态的<code>pubsub_channels</code>字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。每当执行订阅命令时服务器都会将客户端与被订阅的频道着<code>pubsub_channels</code>字典中进行关联。如果执行退订命令，那么就会从<code>pubsub_channels</code>中删除这个客户端。<br>模式的订阅则是保存在服务器<code>pubsub_patterns</code>这个属性中，其操作过程与上面相同。<br>发送消息是就会遍历频道的<code>pubsub_channels</code>和<code>pubsub_patterns</code>的客户端，将消息发送给订阅了这些频道和模式的客户端。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过<code>MULTI</code>,<code>EXEC</code>,<code>WATCH</code>等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性，按顺序地执行多个命令的机制，并且在事务执行期间(<strong>当接收到EXEC命令后才开始真正执行, 之前只是命令输入</strong>)，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。<br><code>MULTI</code>命令标识事务的开始，除了<code>EXEC</code>,<code>DISCARD</code>,<code>WATCH</code>,<code>MULTI</code>四个命令外的其他命令都会进入事务的队列中，当接收到<code>EXEC</code>命令时开始执行事务队列中的命令。<br><code>WATCH</code>命令是一个乐观锁(optimistic locking), 它可以在<code>EXEC</code>命令执行之前，监视任意数量的数据库键,并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的回复。 (注意<code>WATCH</code>命令执行的顺序是在<code>MULTI</code>之前)。<br><code>WATCH</code>命令执行的过程是:</p><ol><li>将监控的键保存到<code>watched_keys</code>字典中，字典的值是所有监视相应数据库键的客户端。</li><li>所有对数据库进行修改的命令都会对<code>watched_keys</code>进行检查，如果键被修改了，就会把客户端的<code>REDIS_DIRTY_CAS</code>标识打开。</li><li>当接收到<code>EXEC</code>执行命令时，如果判断客户端的<code>REDIS_DIRTY_CAS</code>被打开了，标识客户端提交的事务已经不再安全，服务器拒绝客户端提交的事务。 </li></ol><p>事务的ACID性质: Redis中，事务总是具有原子性(Atomicity), 一致性(Consistency)和隔离性(Isolation)，并且当Redis运行在某种特定持久化模式下时，事务也具有耐久性(Durability)</p><ul><li>事务的原子性指的是，数据库将事务中的多个操作当做一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。但是Redis的事务和传统的关系型数据库事务的最大区别在于,<strong>Redis不支持事务回滚机制(rollback)</strong>,即事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，知道将事务队列中的所有命令都执行完毕为止。</li><li>事务具有一致性指的是，如果数据库在执行事务之前一致的，那么事务在执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。<strong>一致</strong>指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。</li><li>事务的隔离性指的是，即时数据库中有多个事务并发地执行，各个事务之间也不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。因为Redis是使用单线程的方式执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此,Redis中的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</li><li>事务的耐久性指的是,当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质里面了，即使服务器在事务执行完毕后停机，，执行事务所得的结果也不会丢失。Redis有<code>RDB</code>和<code>AOF</code>两种持久化方案，但是要持久化方案要和性能进行兼顾。</li></ul><h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本,直接在服务器端原子地执行多个Redis命令。使用<code>EVAL</code>命令可以直接对输入的脚本进行求值，而<code>EVALSHA</code>命令则可以根据脚本的SHA1校验和来对脚本进行求值。<br>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境，并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成:</p><ol><li>创建一个基础的 Lua环境(通过调用<code>lua_open</code>函数)</li><li>载入函数库(基础库,表格库,字符串库等), 让Lua脚本可以使用这些函数库来进行数据操作。</li><li>创建全局表格Redis,这个表格包含了对Redis进行操作的函数，比如用于在 Lua脚本中执行Redis命令的redis.call函数</li><li>使用Redis自制的随机函数来替换Lua原有的代有副作用的随机函数,从而避免在脚本中引入副作用。(关于副作用，纯函数的概念参考:<a href="https://zh.wikipedia.org/zh-hk/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">wiki</a></li><li>创建排序辅助函数，Lua环境使用这个辅助函数来对一部分Redis命令的结果(比如集合)进行排序,从而消除这些命令的不确定性。</li><li>创建<code>redis.pcall</code>函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</li><li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本过程中，将额外的全局变量添加到Lua环境中。</li><li>将完成修改的Lua环境保存到服务器状态的Lua属性中，等待执行服务器传来的Lua脚本。</li></ol><p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与 Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的<code>lua_scripts</code>字典。</p><ul><li>伪客户端: 执行Redis命令必须有响应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。下图是Lua脚本执行Redis命令时的通信步骤:<br><img src="/assets/img/redis/redis_lua.png" alt="redis_lua命令执行步骤"></li><li><code>lua_scirpts</code>字典: 这个字典的键为某个Lua脚本的SHA1校验和，而字典的值则是SHA1校验和对应的Lua脚本。<br><code>EVAL</code>命令的执行过程可以分为以下三个步骤:</li></ul><ol><li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。</li><li>将客户端给定的脚本保存到<code>lua_scripts</code>字典中,等待将来进一步使用。</li><li>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</li></ol><p>Redis还有四个有关Lua脚本的命令:<code>SCRIPT FLUSH</code>, <code>SCRIPT EXISTS</code>, <code>SCRIPT LOAD</code>和<code>SCRIPT KILL</code>命令。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Redis的<code>SORT</code>命令可以对列表建，集合键或者有序集合键的值进行排序。<br>SORT命令的实现原理是(以<code>SORT numbers</code>为例):</p><ol><li>创建一个和要排序的对象numbers长度相同的数组，该数组的每个项都是一个<code>redis.h/redisSortObject</code>结构。</li><li>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间一对一关系</li><li>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面</li><li>根据数组项u.score属性的值，对数组进行数字值排序(快速排序算法)，排序后的数组项按u.score属性的值从小到大排列</li><li>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端。</li></ol><p>其他的排序方式，比如按照字母顺序排列，降序排列，通过外部键进行排序等原理都差不多，变化的是排列的顺序，排列的依据<code>u.score</code>不一样。<br>更多<code>SORT</code>命令的具体使用和参数可以参考文档:<a href="http://redisdoc.com/key/sort.html" target="_blank" rel="noopener">Redis SORT命令</a></p><h2 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h2><p>Redis提供了<code>SETBIT</code>,<code>GETBIT</code>, <code>BITCOUNT</code>, <code>BITOP</code>四个命令用于处理二进制位数组(bit array, 又称为”位数组”)<br>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。<br>具体使用方法参考官方文档。</p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。<br>服务器有两个和慢查询有关的选项:</p><ul><li><code>slowlog-log-slower-than</code>选项执行执行时间超过多少微秒的命令请求会被记录到日志上。(可以通过<code>CONFIG SET slowlog-log-slower-than N</code>设置)</li><li><code>slowlog-max-len</code>选项执行服务器最多保存多少条慢查询日志。(可以通过<code>CONFIG SET slowlog-max-len N</code>设置)</li></ul><p>使用<code>SLOWLOG GET</code>命令可以查看服务器所保存的慢查询日志, 使用<code>SLOWLOG LEN</code>可以查看当前日志的数量。</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>通过执行<code>MONITOR</code>命令，客户端可以将自己变为一个监视器，实时地接收并打印服务器当前处理的命令请求的相关信息。当一个客户端使用<code>MONITOR</code>向服务器发送命令时，这个客户端的<code>REDIS_MONITOR</code>标识会被打开，并且客户端本身会被服务器添加到<code>monitors</code>链表的表尾。当服务器每次接收到请求时(处理命令之前), 都会调用<code>replicationFeedMonitors</code>函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;发布与订阅&quot;&gt;&lt;a href=&quot;#发布与订阅&quot; class=&quot;headerlink&quot; title=&quot;发布与订阅&quot;&gt;&lt;/a&gt;发布与订阅&lt;/h2&gt;&lt;p&gt;通过执行&lt;code&gt;SUBSCRIBE&lt;/code&gt;命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者(s
      
    
    </summary>
    
    
      <category term="redis" scheme="http://oohcode.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现总结——多机数据库的实现</title>
    <link href="http://oohcode.com/2017/03/06/The-Design-and-Implementation-of-Redis-3/"/>
    <id>http://oohcode.com/2017/03/06/The-Design-and-Implementation-of-Redis-3/</id>
    <published>2017-03-06T11:19:41.000Z</published>
    <updated>2019-03-04T04:37:02.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在Redis中用户可以通过执行<code>SLAVEOF</code>命令或者设置<code>slaveof</code>选项，让一个服务器去复制(repliacte)另一个服务器，被复制的服务器称为主服务器(master),而对服务器进行复制的服务器被称为从服务器(salve)。<br>复制功能分为同步(sync)和命令传播(command propagate)两个操作:</p><ul><li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。(从服务器主动向主服务器请求数据)</li><li>命令传播操作用于在主服务器的数据库状态被修改，导致主从服务器数据库状态出现不一致时，让主服务器的数据库重新回到一致状态。</li></ul><p><img src="/assets/img/redis/redis_sync.png" alt="redis旧版复制"></p><ul><li>同步过程:<ul><li>主服务器接收到从服务器发来的SYNC命令,执行BGSAVE命令,创建RDB文件,并使用缓冲区记录接下来执行的所有写命令。</li><li>从服务器接收并载入主服务器发来的RDB文件。</li><li>主服务器接着发送缓冲区的写命令到从服务器。</li><li>从服务器接收命令。</li></ul></li><li>命令传播:<br>  每当主服务器执行写命令时，主服务器的数据库状态就可能被修改，并导致主从服务器不一致。为了再次回到一致状态，主服务器需要对从服务器执行命令传播操作: 主服务器会将自己执行的写命令发送给从服务器执行，当从服务器执行了相同的写命令后，主从服务器再次回到一致状态。</li></ul><p>从服务器初次复制主服务器或者从服务器当前要复制的主服务器和上一次不一样时，RDB文件会完整的传输。在处于命令传播阶段的主从服务器因为网络原因而中断了复制，再次连接上时会重头开始复制。但是第二种情况的效率非常低，很多已经复制过的数据需要再次进行复制。这就是旧版复制功能的缺陷。<br>新版复制功能为了解决重复复制的问题，提出了一个<code>PSYNC</code>命令代替之前的<code>SYNC</code>命令。完整的复制与上面的第一种情况初次复制是一样的，部分重同步则用于处理断线后的情况: 断线再连接后，主服务器只发送断线期间的写命令到从服务器。<br>部分重同步的实现是通过<code>复制偏移量</code>:</p><ul><li>主服务器每次向从服务器转播N个字节的数据时，就将自己的复制偏移量的值+N</li><li>从服务器每次收到主服务器传播来的N个字节数据时，就将自己的复制偏移量的值+N</li></ul><p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态:</p><ul><li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li><li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li></ul><p>复制积压缓冲区是一个由主服务器维护的固定长度，先进先出队列，默认大小为1MB。当主从断开连接，再次连接时,从服务器会通过<code>PSYNC</code>将自己的复制偏移量<code>offset</code>发送给主服务器:</p><ul><li>如果<code>offset</code>偏移量之后的数据存在于复制积压缓冲区，那么主服务器将对从服务器执行部分重同步操作。</li><li>如果<code>offset</code>偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器会对从服务器执行完整重同步操作。</li></ul><p>在命令传播阶段，从服务器默认会以每秒一次的频率，祥主服务器发送命令<code>REPLICONF ACK &lt;replication_offset&gt;</code>, 其中<code>replication_offset</code>是当前从服务器的复制偏移量, 这个<code>心跳检测</code>的作用如下:</p><ul><li><strong>检测主从服务器的网络状态</strong>:如果主服务器超过一秒钟没收到从服务器发送的<code>REPLICONF ACK</code>命令，那么主服务器就知道主从服务器之间的连接出现问题了。</li><li><strong>辅助实现min-slaves选项</strong>:Redis的<code>min-slaves-to-write</code>和<code>min-slaves-max-log</code>两个选项可以防止主服务器在不安全的情况下执行写命令。</li><li><strong>检测命令丢失</strong>:如果因为网络故障，主服务器传播给从服务器的写命令半路丢失，那么从服务器发送的偏移量就会小于主服务器的偏移量，这时候主服务器会从复制积压缓冲区中重新把命令发送给从服务器。(2.8版本之前没有这个功能，所以会出现丢失的情况)</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel(哨岗，哨兵)是Redsi的高可用性(high availability)解决方案:由一个或多个Sentinel实例(instance)组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。另外Sentinel还会继续监视已下线的服务器，并在它重新上时，将它设置为新的主服务器的从服务器(降级)。<br>启动Sentinel可以使用命令: <code>redis-sentinel /path/to/your/sentinel.conf</code> 或 <code>redis-server /path/to/your/sentinel.conf --sentinel</code>, 启动时需要执行一下步骤:</p><ul><li>初始化服务器: Sentinel本质上是一个运行在特殊模式下的Redis服务器，启动初始换与原来有所不同。</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码:初始换Sentinel可以执行的命令，替换之前的默认命令。</li><li>初始化Sentinel状态:初始化<code>sentinel.c/sentinelState</code>结构，这个结构保存了服务器中所有Sentinel相关的状态。</li><li>根据跟定的配置文件，初始化Sentinel的监视主服务器列表:Sentinel状态中的<code>masters</code>字典记录了所有被Sentinel监视的主服务器的相关信息，其中字典的键是被监视主服务器的名字；而字典的值则是被监视主服务器对应的<code>sentinel.c/sentinelRedisInstance</code>结构。</li><li>创建连向主服务器的网络连接: 最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息。对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接:<ul><li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li><li>另一个是订阅连接，这个链接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。</li></ul></li></ul><blockquote><p>为什么有两个连接?<br>在Redis目前的发布与订阅功能中，被发送的信息不回保存在Redis服务器里，如果发送信息时，接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。<strong>为了不丢失任何信息，必须专门用一个订阅连接来接收该频道的信息</strong>(原理?)。另外除了订阅频道，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接。</p></blockquote><h3 id="Sentinel网络拓扑"><a href="#Sentinel网络拓扑" class="headerlink" title="Sentinel网络拓扑"></a>Sentinel网络拓扑</h3><p>Sentinel与主服务器，从服务器及其他Sentinel之间都是彼此连接的:</p><ul><li>首先Sentinel默认<code>每10秒一次</code>向主服务器发送INFO命令，Sentinel可以得到主服务器信息以及主服务器的从服务器信息;</li><li>Sentinel会更新自己的主服务器和从服务器信息，还会创建连接到从服务器的命令连接和订阅连接。</li><li>Sentinel还会默认<code>每2秒一次</code>通过命令连接向所有被监视的主服务器和从服务器发送命令，这条命令会向服务器的<code>__sentinel__:hello</code>频道发送一条信息</li><li>由于Sentinel订阅了主服务器和从服务器的消息，所以所有订阅的Sentinel都会收到上面的信息，接收消息的Sentinel就会感知到发消息的Sentinel存在，并记录到<code>sentinels</code>属性中(可以实现自动发现功能)</li></ul><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><h4 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h4><p>默认情况下Sentinel会以<code>每秒一次</code>的频率向所有与它创建了命令连接的实例(包括主服务器，从服务器，其他Sentinel等)发送PING命令, 并通过实例返回的PING命令回复判断是否在线。由于每个Sentinel设置的下线时间标准可能不一样，所以会出现不同的Sentinel认为服务器的状态不一致，所以这种情况称为主观下线状态。</p><h4 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h4><p>当Sentinel从其他Sentinel那里接收的足够数量的已下线判断之后，Sentinel就会认为将主服务器判定为客观下线状态，并对主服务器执行故障转移操作。</p><h4 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h4><p>当主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头的Sentinel，并由领头Sentinel对下线服务器执行故障转移。<br>选举策略是每个检测到主服务器下线的Sentinel都向其他Sentinel发送想要成为领头的命令，收到命令的Sentinel会将发送命令的Sentinel设置为局部领头，如果一个Sentinel被半数以上的Sentinel设置为局部领头，它就胜出，否则会进行再次选举。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>选举出领头Sentinel后，领头Sentinel将对已下线的主服务器执行故障转移操作:</p><ul><li>在已下线服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器: 选择优先级高，复制偏移量大的从服务器，使用命令<code>SLAVE of one</code>使其变为主服务器。</li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器: 领头Sentinel向其他从服务器发送<code>SLAVEOF</code>命令。</li><li>将已下线的主服务器设置为心的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p><h3 id="节点与槽"><a href="#节点与槽" class="headerlink" title="节点与槽"></a>节点与槽</h3><p>Redis集群通常由多个节点(node)组成，开始每个节点都是图例的，它们都处于一个只包含自己的集群中，当要组建一个真正可工作的集群，我们必须将节点连接起来，构成一个包含多个节点的集群。使用<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>命令来完成。另外Redis服务器启动时也可以根据<code>cluster-enabled</code>配置选项来判断是否开启集群模式。节点信息保存在<code>cluster.h/clusterNode</code>结构中，<code>clusterNode</code>结构保存了一个节点的当前状态，比如节点的创建时间，节点的名等;<code>clusterNode</code>的<code>link</code>属性是一个<code>clusterLink</code>结构，该结构保存了连接节点所需的有关信息,比如套接字描述符，输入缓冲区和输出缓冲区; 每个节点都保存着一个<code>clusterState</code>结构，这个结构记录了当前节点的视角下，集群目前所处的状态，例如机器是在线还是下线，集群包含多少节点等。<br>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为<code>16384</code>(=2048*8)个槽(slot),数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。当数据库中的16384个槽有节点在处理时，集群处于一个上线状态(ok);相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态(fail)。<br>槽指派信息记录在<code>clusterNode.slots[16384/8]</code>属性中, <code>numslots</code>记录了节点负责处理的槽的数量。Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位来判断节点是否负责处理槽i:</p><ul><li>如果slots数组在索引i上的二进制位值为1，那么表示节点负责处理槽i。</li><li>如果slots数组在索引i上的二进制位值为0, 那么表示节点不负责处理槽i。</li></ul><p>节点会把自己处理的槽信息发送给其他集群中的其他节点，因此集群中的每个节点都会知道数据库中16384个槽分别被指派给了集群中哪些节点。<br><code>clusterState</code>结构中的<code>slots[16384]</code>数组则更上面的正好反过来，它记录了每个槽是由哪个节点在管理的。之所以会有这两种结构是为了在查找节点管理了哪些槽和槽由哪个节点管理的复杂度都降低了。</p><h3 id="集群中的执行命令"><a href="#集群中的执行命令" class="headerlink" title="集群中的执行命令"></a>集群中的执行命令</h3><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽(使用crc16(key)&amp;16383算法得出槽位置)，并检查这个槽是否指派给了自己(clusterState.slots[i]是否为自己):</p><ul><li>如果键所在的槽正好指派给了当前节点，那么节点直接执行这个命令。</li><li>如果键所在的槽没有指派给了当前节点，那么节点回向客户端返回一个MOVED错误，指引客户端转向(redirect)至正确的节点，并再次发送之前想要执行的命令。</li></ul><p>节点与单机服务器在数据库方面的区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制。<br>节点还会使用<code>clusterState</code>结构中的<code>slots_to_keys</code>跳跃表来保存槽和键之间的关系，主要目的是方便节点对属于某个或某些槽的所有数据库键进行批量操作。</p><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目的节点)，并且相关槽所属的键值对也会从源节点移动到目的节点。这个过程可以在线进行，在重新分片过程中，集群不需要下线，并且源节点和目的节点都可以继续处理命令请求。<br>Redis的重新分片操作是由Redis的集群管理软件<code>redis-trib</code>负责执行的。迁移过程如下:<br><img src="/assets/img/redis/redis_trib.png" alt="redis-trib"><br>在执行第四步迁移的过程中，如果客户端向源节点发送一个与数据库键有关的命令，那么:</p><ul><li>源节点先在自己数据库里查找指定的键，如果找到就直接执行客户端发送的命令.</li><li>如果没找到，那么这个键可能已经被迁移到了目标节点，源节点向客户端返回一个ASK错误，指引客户端转向正在导入槽的目的节点，并再次发送之前想要执行的命令。<br>当客户端接收到ASK错误并转向正在执行导入槽节点时，客户端会先向节点发送一个<code>ASKING</code>命令，然后才重新发送想要执行的命令。ASKING命令会打开发送客户端的<code>REDIS_ASKING</code>标识。<br>一般情况下如果客户端向节点发送一个关于槽i的命令，如果节点没有这个槽，那么就会返回<code>MOVED</code>，但是如果节点的<code>clusterState.importing_slots_from[i]</code>显示节点正在导入槽i,并且发送命令的客户端带有<code>REDIS_ASKING</code>（通过<code>ASKING</code>命令打开)标识，那么节点将执行这个关于槽i的命令一次</li></ul><p>关于ASK错误与MOVED错误的区别:</p><ul><li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点，客户端收到关于槽i的MOVED错误后，每次遇到槽i请求是，都可以直接将命令发送至MOVED错误所指向的节点。</li><li>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施, 不会影响后面命令的发送。</li></ul><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分为主节点(master)和从节点(slave),其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。设置从节点的命令:<code>CLUSTER REPLICATE &lt;node_id&gt;</code><br>集群中的每个节点都会定期地祥集群中其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记位疑似下线(probable fail, PFAIL)。如果一个集群里，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线(FAIL), 将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点X标记为下线。<br>当一个从节点发现自己正在复制的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，下面是故障转移执行的步骤:</p><ol><li>复制下线主节点的所有从节点里面，会有一个从节点被选中:选举过程和Sentinel差不多。</li><li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li><li>新的主节点向集群广播一条PONG消息，可以让集群中其他节点立即知道这个节点从从节点变为了主节点，并且这个主节点已经接管了原本由已下线主节点负责处理的槽。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面主要讲了Redis在多机数据库下的功能特性，其中复制是实现数据备份，数据可靠性的保证。Sentinel实现高可用性的保证。在3.0版本之前的分布式方案都是自己实现的，然后利用Sentinel进行监控。后来Redis自己实现了集群方案，可以用其默认的集群方案来代替之前的自己实现方案。他们之间是相辅相成的，根据自己的需要进行选择。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.zhihu.com/question/21419897" target="_blank" rel="noopener">Redis集群方案应该怎么做?</a></li><li><a href="http://rdc.hundsun.com/portal/article/669.html" target="_blank" rel="noopener">如何部署高可用的Redis集群架构</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复制&quot;&gt;&lt;a href=&quot;#复制&quot; class=&quot;headerlink&quot; title=&quot;复制&quot;&gt;&lt;/a&gt;复制&lt;/h2&gt;&lt;p&gt;在Redis中用户可以通过执行&lt;code&gt;SLAVEOF&lt;/code&gt;命令或者设置&lt;code&gt;slaveof&lt;/code&gt;选项，让一个服务器
      
    
    </summary>
    
    
      <category term="redis" scheme="http://oohcode.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现总结——单机数据库的实现</title>
    <link href="http://oohcode.com/2017/03/05/The-Design-and-Implementation-of-Redis-2/"/>
    <id>http://oohcode.com/2017/03/05/The-Design-and-Implementation-of-Redis-2/</id>
    <published>2017-03-05T11:02:37.000Z</published>
    <updated>2019-03-04T04:37:02.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>一个Redis Server可以有多个Redis数据库，这点类似于MySQL, 从Redis Server的源代码中可以看到,<code>redisDb</code>是Server数据库的指针，指向一个数据库组成的数组，而数据库的数量则由<code>dbnum</code>属性来表示。客户端可以通过<code>SELECT</code>命令选择当前要操作的数据库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库数组指针</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;                      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数据库的定义在<code>redis.h/redisDb</code>中，定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以解除阻塞的键</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库号码</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></p><ul><li><code>dict</code>: 是一个字典，保存了数据库中的所有键值对，我们将这个字典称为键空间(key space)。</li><li><code>expires</code>: 也是一个字典，保存的是键值与这个键值过期时间的键值对。</li></ul><p>一个简化的结构图如下:<br><img src="/assets/img/redis/redis_db.png" alt="db结构"><br>设置生存时间和过期时间时，最终都是计算出最后生存时间，然后把这个值存入<code>expires</code>字典中。过期字典中找不到证明没有设置过期时间。过期删除策略Redis主要是使用惰性删除策略与定期删除两种策略。所谓惰性删除策略就是当用户获取键时，先判断其是否过期，如果过期则删除键，返回失败，如果没过期则正常返回。定期删除策略是Redis会周期行的从过期字典中随机出一部分键值，如果过期则删除键，否则保留。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB(redis database)持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中(RDB文件默认的文件名为<code>dump.rdb</code>)。RDB持久化功能锁生成的RDB文件是一个经过压缩的二进制文件，通过该文件还可以还原生成RDB文件时的数据库状态。<br>有两个Redis命令可以用于生成RDB文件，一个是<code>SAVE</code>, 另一个是<code>BGSAVE</code>。<code>SAVE</code>会阻塞Redis服务进程，知道RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何请求。<code>BGSAVE</code>命令会派生出一个子进程,然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求。<br>RDB文件是在服务器启动时自动执行的，只要Redis服务器启动时检测到RDB文件存在，它就会自动载入RDB文件。但是如果服务器开启了AOF持久化功能，就会优先使用AOF文件。因为AOF文件的更新频率通常比RDB文件高，所以数据是最新的可能性高。<br>用户可以通过save选项设置多个保存条件，但只要其中任意一条被满足，服务器就会执行<code>BGSAVE</code>命令。例如配置为下面三个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p><p>只要满足900s内至少一次修改，或300s内至少10次修改，或60s内10000次修改就会自动执行<code>BGSAVE</code>命令。<br>服务器维护一个<code>dirty</code>计数器，用于记录距离上次成功执行<code>SAVE</code>或<code>BGSAVE</code>命令之后，服务器对数据库状态进行了多少次修改(包括写入，删除，更新等操作)。<br>服务器还维护一个<code>lastsave</code>属性，记录服务器上一次成功执行<code>SAVE</code>或<code>BGSAVE</code>命令的时间。<br>RDB文件结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----+----------+---------+---+---------+</span><br><span class="line">|     |          |         |   |         |</span><br><span class="line">|REDIS|db_version|databases|EOF|check_sum|</span><br><span class="line">|     |          |         |   |         |</span><br><span class="line">+-----+----------+---------+---+---------+</span><br></pre></td></tr></table></figure></p><ul><li><code>REDIS</code>: RDB文件开头是REDIS部分，这个部分长度为5字节,保存着”REDIS”五个字符。通过五个字符，快速检测是否为RDB文件。</li><li><code>db_version</code>: 长度为4字节，它的值是一个字符串表示的整数，记录了RDB文件的版本号。</li><li><code>databases</code>: 包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li><li><code>EOF</code>: 长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕。</li><li><code>check_sum</code>: 8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对前面四部分的内容计算得出的。服务器载入RDB文件时，会将载入数据所计算出的校验和与<code>check_sum</code>所记录的检验和进行对比，以此来检查RDB文件是否出错或者有损坏的情况。<br>可以使用<code>od -c dump.rdb</code>或<code>od -cx dump.rdb</code>命令来对RDB文件内容进行分析。</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF(Append Only File)持久化功能是通过保存Redis服务器所执行的写命令来记录数据库状态的。AOF持久化功能的实现可以分为命令追加(append), 文件写入，文件同步(sync)三个步骤:</p><ul><li>命令追加: 服务器执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</li><li>AOF文件的写入与同步: 服务器的每次时间循环结束之前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里。<br><code>flushAppendOnlyFile</code>函数的行为由服务器配置的<code>appendfsync</code>选项的值来决定:</li></ul><table><thead><tr><th>appendfsync选项的值</th><th>flushAppendOnlyFile函数的行为</th><th>影响</th></tr></thead><tbody><tr><td>always</td><td>将aof_buf缓冲区中的所有内容写入并同步到AOF文件</td><td>性能最低，但是安全性最高，发生故障停机最多丢失一个循环事件所产生的在缓冲区中的命令</td></tr><tr><td>everysec(默认值)</td><td>将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1s,那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的</td><td>性能足够快，并且出现故障停机，最多丢失一秒钟的命令数据</td></tr><tr><td>no</td><td>将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统决定</td><td>性能最好，写入AOF速度最快，但是单次同步时间最长，出现故障丢失的命令最多</td></tr></tbody></table><p>由于AOF文件记录了重建数据库所需的所有写命令，所以服务器只要读入并执行一遍AOF文件里么保持的写命令，就可以还原服务器关闭之前的状态。<br>由于AOF持久化是通过保存被执行的写命令来记录数据库状态的，随着时间的推移，写命令越来越多，这时候就需要<code>AOF重写</code>来减轻文件体积的膨胀。<br><code>AOF重写</code>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录的这个键值对的多条命令。但是在重写列表，哈希表，集合，有序集合等多个元素的键时，如果元素的数量超过了<code>redis/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>常量的值，会通过多条命令来记录键的值。<br>一个问题是在AOF重写期间，服务器还需要处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。为了解决这个问题，Redis服务器设置了一个<code>AOF重写缓冲区</code>，这个缓冲区在服务器创建子进程进行重写是开始使用,当Redis服务器执行完一个写命令后，它会同事将这个命令发送给AOF缓冲区和<code>AOF重写缓冲区</code>。当AOF重写工作完成后，向父进程发送信号，父进程就会将<code>AOF重写缓冲区</code>中的所有内容写到新的AOF文件中，对新的AOF文件进行改名，原子地 （atomic)覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>文件事件(file event): Redis服务器通过套接字与客户端(或其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。<br>下图是Redis自己实现的文件事件处理器的四个组成部分:<br><img src="/assets/img/redis/redis_fileevent.png" alt="db结构"></p><ul><li>文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答(accept),读取(read),写入(write)，关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，着保持了Redis内部单线程设计的简单性。<br>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总会将所有产生事件的套接字都放在一个队列里，然后通过这个队列，以有序(sequentially),同步(synchronously)，每次一个套接字的方式向文件事件分派器传送套接字。<br>Redis的I/O多路复用程序的所有功能都是通过包装常见的<code>select</code>,<code>epoll</code>,<code>evport</code>和<code>kqueue</code>这些I/O多路复用函数库来实现的，编译时会自动选择性能高最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现。</p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件(time event): Redis服务器中的一些操作(如<code>serverCron</code>函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。<br>Redis的时间事件分为两类:</p><ul><li>定时事件: 让程序在指定的时间之后执行一次。</li><li>周期性事件: 让一端程序每隔指定的时间就执行一次。</li></ul><p>一个时间事件主要由以下三个属性:</p><ul><li>id: 服务器为时间事件创建的全局唯一ID(标识号)。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>when: 毫秒精度的UNIX时间戳，记录了时间事件的到达(arrive)时间。</li><li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用响应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>如果事件处理器返回<code>ae.h/AE_NOMORE</code>，那么这个事件为定时事件:该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非<code>AE_NOMORE</code>的整数值，那么这个事件为周期性时间:当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间后再次到达，并以这种方式一直更新运行下去。</li></ul><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责,下面是这个函数的伪代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    // 获取到达时间离当前最接近的时间事件</span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    </span><br><span class="line">    // 计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    </span><br><span class="line">    // 如果事件已到达，那么remaind_ms的值就可能为负数，将它设定为<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    // 根据remaind_ms的值，创建timeval结构</span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    </span><br><span class="line">    // 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class="line">    // 如果remaind_ms的值为<span class="number">0</span>，那么aeApiPoll调用之后马上返回，不阻塞</span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">   </span><br><span class="line">    // 处理所有已产生的文件事件 </span><br><span class="line">    processFileEvents()</span><br><span class="line">    </span><br><span class="line">    // 处理所有已到达的时间事件</span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure></p><p>事件的调度和执行规则:</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最接近的当前时间的时间事件决定，这个方法既可以避免服务器对时间事件并行频繁的轮询，可以确保aeApiPoll函数不会阻塞时间过长。</li><li>因为文件事件是随机出现的，如果处理完文件事件后时间事件仍未到达，继续等待并处理下一个文件事件。</li><li>对文件事件和时间事件的处理都是同步，有序，原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占。因此耗时的事件会影响整个服务的性能。</li><li>因为时间事件是在文件事件之后执行，并且事件之间不会抢占，所以时间事件的实际处理时间通常回避时间事件设定的到达时间稍微晚一些。</li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>通过使用I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。<br>关于<code>redisClient</code>的定义可以从<code>redis.h</code>中看到，客户端有很多属性。这些属性可以分为两类:</p><ul><li>比较通用的属性，这些属性很少特定功能相关，无论客户端执行的是什么工作，它都需要这些属性。</li><li>和特定功能相关的属性。下重点介绍这些。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>fd(fake client)</code>: 伪客户端的fd属性的值为<code>-1</code>,伪客户端处理的命令请求来自于AOF文件或者lua脚本; 普通客户端fd属性值是大于-1的整数，使用套接字与服务器通信，所以fd用来记录客户端套接字的描述符。</li><li><code>name</code>: 默认情况下一个连接到服务器的客户端是没有名字的，但是可以使用<code>CLIENT setnaem</code>命令设置一个名字，可以通过<code>CLIENT list</code>查看。</li><li><code>flags</code>: 一部分标志记录了客户端的角色(如REDIS_MASTER代表主服务器, REDIS_SLAVE代表从服务器), 另一部分标志记录了客户端目前所处的状态(REDIS_MONITOR正在执行monitor, REDIS_MULTI标志客户端正在执行事务)。</li><li><code>querybuf</code>: 用于保存客户端发送的命令请求。输入缓冲区的大小会根据输入内容动态调整，但是最大不能超过1GB,否则服务器将关闭这个客户端。</li><li><code>argv</code>和<code>argc</code>: 服务器将客户端发送的名保存到<code>querybuf</code>后，对命令内容进行分析，得出命令参数及命令的参数个数分别保存到<code>argv</code>和<code>argc</code>中。</li><li><code>authenticated</code>: 记录客户端是否通过了身份验证，未通过用0表示，通过用1表示。</li><li><code>ctime</code>: 记录创建客户端的时间。</li><li><code>lastinteraction</code>: 记录客户端与服务器最后一次进行互动的时间。</li><li><code>obuf_soft_limit_reached_time</code>: 记录输出缓冲区第一次到达软性显示的时间。</li></ul><p>执行命令所得的命令回复会被保存到客户端状态的输出缓冲区里，每个客户端都有两个输出缓冲区可用</p><ul><li><code>buf</code>和<code>bufpos</code>: 固定的换缓冲区，用于保存那些长度比较小的回复，如:OK, 简短的字符串值，整数值或错误回复等。<code>buf</code>是缓冲区，<code>bufpos</code>记录<code>buf</code>数组目前已经使用的字节数量。</li><li><code>reply</code>: 可变大小的缓冲区是一个链表,用于保存比较大的回复，比如一个非常长的字符串值，列表等。</li></ul><h3 id="创建与关闭"><a href="#创建与关闭" class="headerlink" title="创建与关闭"></a>创建与关闭</h3><ul><li><strong>创建不同客户端</strong>: 如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端connect函数连接到服务器时，服务器就会调用连接事件处理器为客户端创建响应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</li><li><strong>关闭客户端</strong>: 一个普通客户端被关闭的原因有很多:<ul><li>客户端进程退出或被杀死</li><li>客户端向服务器发送了带有不符合协议格式的命令请求</li><li>客户端成了CLIENT KILL命令的目标</li><li>用户为服务器设置了timeout配置选项，客户端空转时间超过timeout选项设置的值</li><li>客户端发送的命令请求大小超过了输入缓冲区的限制大小(1GB)</li><li>发送给客户端的命令回复超过输出缓冲区的限制大小。按理说输出缓冲区是没有大小限制的，但是为了防止过多占用服务器资源，采用硬性限制和软性限制两种方案限制大小。</li></ul></li><li><strong>Lua脚本的伪客户端</strong>: 服务器在初始化时负责创建Lua脚本中包含的Redis命令的伪客户端，在服务器运行的整个周期中都会存在。</li><li><strong>AOF文件的伪客户端</strong>: 服务器载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成后关闭。</li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>前面讲了，客户端发送的请求会被放到输入缓冲区，然后服务器对命令进行解析，转换成协议格式，服务器将通过调用命令执行器来完成余下的步骤:</p><ul><li><strong>查找命令</strong><br>根据上面说的<code>argv[0]</code>参数中对应的命令在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的<code>cmd</code>属性里。<br>命令表是一个字典，字典的键是一个个命令名字，比如”set”,”get”,”del”等;而字典的值则是一个个<code>redisCommand</code>结构，每个<code>redisCommand</code>结构记录了一个Redis命令的实现信息。</li></ul><p><code>redisCommand</code>结构的主要属性:</p><table><thead><tr><th>属性名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>char *</td><td>命令的名字，比如”set”</td></tr><tr><td>proc</td><td>redisCommandProc *</td><td>函数指针，指向命令的实现函数</td></tr><tr><td>arity</td><td>int</td><td>命令参数的个数，用于检查命令请求的格式是否正确</td></tr><tr><td>sflags</td><td>char *</td><td>字符串形式的标识值，这个值记录了命令的属性<br>例如:<br>w:表示写入命令<br>r:只读命令<br>m:可能会占用大量内存的命令<br>a:这是一个管理命令</td></tr><tr><td>flags</td><td>int</td><td>对sflags标识进行分析得出的二进制标识，由程序自动生成</td></tr><tr><td>calls</td><td>long long</td><td>服务器总共执行了多少次这个命令</td></tr><tr><td>milliseconds</td><td>long long</td><td>服务器执行这个民两个所耗费的总时长</td></tr></tbody></table><ul><li><p><strong>执行预备操作</strong><br>到目前为止，服务器已经将执行命令所需的命令实现函数,参数等都收集齐了，真正执行命令之前还需要一些预备操作：</p><ul><li>检查客户端状态的cmd指针是否执行NULL</li><li>检查命令请求所给定的参数个数是否正确</li><li>检查客户端是否已经通过了身份验证</li><li>如果服务器打开了<code>maxmemory</code>功能，需要检查服务器的内存占用情况，在有需要的时候进行内存回收</li><li>其他检查和限制执行的操作等</li></ul></li><li><p><strong>调用命令的实现函数</strong><br>当服务器决定要执行命令是<code>client-&gt;cmd-&gt;proc(client);</code>, 执行函数后会把回复保存到客户端的输出缓冲区，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将回复返回给客户端。</p></li><li><strong>执行后续工作</strong><br>在执行完实现函数后，服务器还需要执行一些后续工作:<ul><li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会坚持是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li><li>根据刚刚执行命令所耗费的时长，更被执行命令redisCommand结构的milliseconds属性，并将calls计数器加一</li><li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里。</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器</li><li>根据刚刚执行命令所耗费的时长，更被执行命令redisCommand结构的milliseconds属性，并将calls计数器加一</li><li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里。</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li></ul></li></ul><p>回复发送完毕后，回复处理器会清空客户端状态的输出缓冲区，未处理下一个命令请求做好准备。当客户端接收到协议格式的命令回复后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的<code>serverCron</code>函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。<code>serverCron</code>的函数主要功能如下面所列:</p><ul><li><strong>更新服务器时间缓存</strong>: 为了减少获取服务器时间而进行系统调用的次数，服务器状态中的<code>unixtime</code>和<code>mstime</code>属性被用作当前时间的缓存，serverCron函数默认每100ms的频率更新这两个字段。对于设置键值过期时间，慢查询日志这种需要高精度时间的功能来说，服务器还是会再次执行系统调用。</li><li><strong>更新LRU时钟</strong>: 服务器状态中的lruclock属性保存了服务器的LRU时钟;每个Redis对象都会有一个lru属性，保存了对象最后一次被访问的时间。这个值也是用serverCron来更新。</li><li><strong>更新服务器每秒执行命令次数</strong>: <code>serverCron</code>函数中的<code>trackOperationsPerSecond</code>函数会以每100ms一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。可以通过<code>INFO stats</code>查看。</li><li><strong>更新服务器内存峰值记录</strong>:<code>serverCron</code>每次都会查看服务器当前使用的内存数量，并与<code>stat_peak_memory</code>保持的值进行比较，如果当前的数据比较大就更新这个值。<code>INFO memory</code>命令可以查看具体的数据。</li><li><strong>处理SIGTERM信号</strong>:服务器启动时，Redis会为服务器进程的<code>SIGTERM</code>信号关联处理器<code>sigtermHandler</code>函数，这个信号处理器负责在服务器接到<code>SIGTERM</code>信号时，打开服务器状态的<code>shutdown_asap</code>标识。如果不拦截这个信号，可能会造成比如RDB持久化操作时关闭服务器。</li><li><strong>管理客户端资源</strong>:<code>serverCron</code>函数每次执行都会调用<code>clientsCron</code>函数，<code>clientsCron</code>函数会对一定数量的客户端进行以下两个检查:<ul><li>如果客户端与服务器之间的连接已经超时,那么程序释放这个客户端。</li><li>如果客户端在上一次执行命令请求后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</li></ul></li><li><strong>管理数据库资源</strong>: 每次调用<code>databasesCron</code>函数，对服务器中一部分数据库进行检查，删除其中的过期键，并在需要时，对字典进行收缩操作。</li><li><strong>执行被延迟的BGREWRITEAOF</strong></li><li><strong>检查持久化操作的运行状态</strong></li><li><strong>将AOF缓冲区的内容写入到AOF文件</strong></li><li><strong>关闭异步客户端</strong></li><li><strong>增加cronloops计数器的值</strong>:<code>cronloops</code>记录了<code>serverCron</code>函数执行的次数。</li></ul><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程。过程如下:</p><ul><li><strong>初始化服务器状态结构</strong>:包括设置服务器的运行ID,设置服务器的默认运行频率，设置服务器的默认配置文件路径，设置服务器默认端口号，设置服务器默认持久化条件等。</li><li><strong>载入配置选项</strong>: 可以通过给定配置函数或指定配置文件来修改服务器的默认配置。</li><li><strong>初始化服务器数据结构</strong>:包括初始化<code>server.clients</code>链表，初始化执Lua脚本的执行环境<code>server.lua</code>等;还进行了创建共享对象，打开服务器的监听端口等操作。</li><li><strong>还原数据库状态</strong>: 完成初始化后，服务器需要载入<code>RDB</code>文件或者<code>AOF</code>文件，并根据文件记录的内容来还原服务器的数据库状态。</li><li><strong>执行事件循环</strong>: 初始完成后，开始执行服务器的事件循环(loop)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;p&gt;一个Redis Server可以有多个Redis数据库，这点类似于MySQL, 从Redis Server的源代码中可以看到,&lt;co
      
    
    </summary>
    
    
      <category term="redis" scheme="http://oohcode.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现总结——数据结构与对象</title>
    <link href="http://oohcode.com/2017/03/04/The-Design-and-Implementation-of-Redis-1/"/>
    <id>http://oohcode.com/2017/03/04/The-Design-and-Implementation-of-Redis-1/</id>
    <published>2017-03-04T03:44:38.000Z</published>
    <updated>2019-03-04T04:37:02.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="简单的动态字符串"><a href="#简单的动态字符串" class="headerlink" title="简单的动态字符串"></a>简单的动态字符串</h3><p>Redis自己构建的一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将SDS用做Redis的默认字符串表示。<br>SDS的定义在<code>sds.h/sdshdr</code>结构中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录buf数组中已使用的字节的数量</span></span><br><span class="line"><span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/redis/redis_sds.png" alt="SDS结构"><br>C字符串和SDS之间的区别:</p><table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次必然需要执行N次内存重分配</td><td>修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td>只能保持文本数据</td><td>可以保持文本或者二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在redis链表键，发布与订阅，慢查询，监视器等功能都用到了。<br>链表结构分为链表和链表节点，每个链表由多个链表的节点组合而成。每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是一个双端链表。表头节点和表尾节点都指向NULL, 是一个无环链表。保存链表值的类型是void, 可以保持不同类型的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表定义adlist/list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表所浩瀚的节点数量 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点定义adlist.h/listNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/redis/redis_list.png" alt="list结构"></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典又称为符号表(symbol table), 关联数组(associative array)或映射(map),是一种用于保存键值对(key-value pair)的抽象数据结构。字典中的每一个键都是独一无二的。字典在Redis中应用相当广泛，比如Redis的数据库就是使用字典作为底层实现的，对数据库的CRUD也是建立在字典的操作上。字典还是哈希键的底层实现之一。<br><img src="/assets/img/redis/redis_dict.png" alt="dict结构"><br>字典的结构如上图所示，字典是由多个结构连接而成，首先是字典结构<code>dict.h/dict</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型特定函数, 保存了一簇用于操作特定类型键值对的函数,</span></span><br><span class="line">    <span class="comment">// Redis会为用途不同的字典设置不同的类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据, 保存了需要传给那些类型特定的函数的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表, 注意这里hash表定义两个，其中一个是实际中使用的，</span></span><br><span class="line">    <span class="comment">// 另一个是在扩展或收缩的时候使用的，类似于GC复制算法的原理</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引, 记录rehash目前的进度</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p>字典所使用的哈希表<code>dict.h/dictht</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemark;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p><p>哈希表节点:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值 </span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向下个哈希表节点,形成链表</span></span><br><span class="line">    <span class="comment">// 使用next指针解决哈希冲突的问题</span></span><br><span class="line">    <span class="comment">// 哈希算法为MurmurHash2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p><p>随着操作的不断执行，哈希表保存的键值对会逐渐的增多或减少，为了让哈希负载因子(load factor)维持在一个合理的范围之内，当哈希表保持的键值对对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或收缩。<br>为了避免rehash对服务器性能造成影响，服务器不是一次性将<code>ht[0]</code>里面的所有键值对全部<code>rehash</code>到<code>ht[1]</code>，而是分多次，渐进式地将<code>ht[0]</code>里面的键值对慢慢地<code>rehash</code>到<code>ht[1]</code>。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构, 它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(longN)，最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。更多介绍参考<a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">wiki</a>。<br>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。跳跃表的另一个应用就是作为集群节点中的内部数据结构。除了这两个地方，其它地方没有用到。<br>跳跃表有<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个结构定义，其中<code>zskiplistNode</code>结构用于表示跳跃表节点，而<code>zskiplist</code>结构则用于保存跳跃表节点信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/redis/redis_skiplist.png" alt="skiplist结构"></p><ul><li>层: 每个层带有两个属性，前进指针和跨度。前进指针用于访问表尾方向的其节点，而跨度则记录了前进指针所指向节点和当前节点的距离。上图中连线数字上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问就会沿着层的前进指针进行。每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law, 越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。</li><li>前进指针: 每个层都有一个指向表尾方向的前进指针(level[i].forward属性), 用于从表头向表尾方向的访问节点。</li><li>后退指针: 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值: 各个节点中的1.0，2.0和3.0是节点所保存的分值。在跳跃表中，节点各自所保存的分值从小到大排列。 跳跃表中的节点按照分值进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li><li>成员对象: 各个节点中的o1, o2和o3是节点所保存的成员对象。</li></ul><p>具体的操作过程参考<a href="http://blog.csdn.net/ict2014/article/details/17394259" target="_blank" rel="noopener">http://blog.csdn.net/ict2014/article/details/17394259</a></p><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合键的底层实现。<br>每个<code>intset.h/intset</code>结构表示一个整数集合:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tyepdef <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式, 决定contents的类型</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保持元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/redis/redis_intset.png" alt="intset结构"><br><code>contents</code>数组是整数集合的底层实现: 整数集合的每个元素都是<code>contents</code>数组的一个数组项(item), 各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。虽然<code>contetns</code>声明为<code>int8_t</code>类型的数组,但实际上<code>contents</code>并不保存任何<code>int8_t</code>类型的值，<code>contents</code>数组的真正类型取决于<code>encoding</code>属性的值。<br>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行<code>升级(upgrade)</code>, 然后才能将新元素添加到整数集合里面。整数集合不支持<code>降级操作</code>, 一旦对数组进行了升级，编码就会一致保持升级后的状态。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表(ziplist)是列表建和哈希键的底层实现之一。当一个列表建只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表建的底层实现。<br>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。一个压缩列表可以包含任意多个节点(entry),每个节点可以保持一个字节数组或一个整数值。<br><img src="/assets/img/redis/redis_ziplist.png" alt="ziplist结构"><br>压缩列表各个组成部分的详细说明:</p><table><thead><tr><th>属性</th><th>类型</th><th>长度</th><th>用途</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4字节</td><td>记录整个压缩列表占用的内存字节数:在对压缩列表进行内存重分配,或者计算zlend的位置时使用</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节:通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2字节</td><td>记录了压缩列表包含的节点数量，当节点数小于UINT16_MAX时取这个值，大于时需要遍历列表才能得出</td></tr><tr><td>entryX</td><td>列表节点</td><td>不定</td><td>压缩列表包含的节点，节点的长度由节点保存的内容决定</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1字节</td><td>特殊值<code>0xFF(十进制255)</code>，用于标记压缩列表的末端</td></tr></tbody></table><p>压缩列表的节点构成:</p><ul><li><code>previous_entry_length</code>: 以字节为单位，记录了压缩列表中前一个节点的长度。只要我们拥有了一个指向某个节点的起始地址的指针，那么通过这个指针及这个节点的<code>previous_entry_length</code>属性，程序就可以一直向前一个节点回溯，最终达到压缩列表的表头节点。</li><li><code>encoding</code>: 记录了节点的<code>content</code>属性所保存数据的类型及长度。</li><li><code>content</code>: 负责保存节点的值，节点值可以使一个字节数组或整数，值的类型和长度由节点的<code>encoding</code>属性决定。</li></ul><p><code>连锁更新</code>问题是指当插入新节点或删除节点后，<code>previous_entry_length</code>属性所记录的长度不能够满足改变后的节点的记录，需要扩容以便记录，最差的情况是后面的每个节点都会改变位置。最差的复杂度为O(N^2)。但是这种情况很少见，一般复杂度为O(N)。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>前面介绍了Redis的主要数据结构，但是Redis并没有直接使用这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个<code>对象系统</code>, 这个系统包含字符串对象，列表对象，哈希对象，集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们面前所介绍的数据结构。我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率，而这些对用户是透明的。<br>Redis的对象系统还实现了基于引用计数技术的内存回收机制(GC), 当程序不再是由某个对象的时候，这个对象所占用的内存就会被自动释放；另外Redis还通过引用计数法实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。<br>每当我们在Redis数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键(键对象),另一个对象用作键值对的值(值对象)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>使用<code>TYPE</code>命令可以看到对象的类型，对象的类型及type属性的值对应关系如下表:</p><table><thead><tr><th>type类型常量</th><th>对象的名称</th><th>TYPE命令的输出</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>字符串对象</td><td>“string”</td></tr><tr><td>REDIS_LIST</td><td>列表对象</td><td>“list”</td></tr><tr><td>REDIS_HASH</td><td>哈希对象</td><td>“hash”</td></tr><tr><td>REDIS_SET</td><td>集合对象</td><td>“set”</td></tr><tr><td>REDIS_ZSET</td><td>有序集合对象</td><td>“zset”</td></tr></tbody></table><p>每种TYPE对象的底层编码都是由上面说的数据结构组成的，使用<code>OBJECT ENCODING</code>命令可以查看一个数据库键的值对象的编码，具体的对应关系如下表:</p><table><thead><tr><th>对象所使用的底层数据结构</th><th>编码常量</th><th>OBJECT ENCODING命令输出</th></tr></thead><tbody><tr><td>整数</td><td>REDIS_ENCODING_INT</td><td>“int”</td></tr><tr><td>embstr编码的简单动态字符串(SDS)</td><td>REDIS_ENCODING_EMBSTR</td><td>“embstr”</td></tr><tr><td>简单动态字符串</td><td>REDIS_ENCODING_RAW</td><td>“raw”</td></tr><tr><td>字典</td><td>REDIS_ENCODING_HT</td><td>“hashtable”</td></tr><tr><td>双端链表</td><td>REDIS_ENCODING_LINKEDLIST</td><td>“linkedlist”</td></tr><tr><td>压缩列表</td><td>REDIS_ENCODING_ZIPLIST</td><td>“ziplist”</td></tr><tr><td>整数集合</td><td>REDIS_ENCODING_INTSET</td><td>“intset”</td></tr><tr><td>跳跃表和字典</td><td>REDIS_ENCODING_SKIPLIST</td><td>“skiplist”</td></tr></tbody></table><p>每种类型对象可以使用哪些数据结构，下面做了一个总结:</p><table><thead><tr><th>对象类型</th><th>“int”</th><th>“embstr”</th><th>“raw”</th></tr></thead><tbody><tr><td>“string”</td><td>如果字符串对象保存的是整数值，并且其可以用long类型来表示</td><td>如果字符串对象保持的是一个字符串值，并且其长度小于39字节</td><td>如果字符串对象保持的是一个字符串值，并且其长度大于39字节</td></tr></tbody></table><table><thead><tr><th>对象类型</th><th>“linkedlist”</th><th>“ziplist”</th></tr></thead><tbody><tr><td>“list”</td><td>不满足ziplist的条件的情况</td><td>同时满足:<br>1. 所有字符串元素的长度都小于64字节;<br>2. 元素数量小于512个</td></tr></tbody></table><table><thead><tr><th>对象类型</th><th>“hashtable”</th><th>“ziplist”</th></tr></thead><tbody><tr><td>“hash”</td><td>不满足ziplist的条件的情况</td><td>同时满足:<br>1. 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节;<br>2. 哈希对象保存的键值对数量小于512个</td></tr></tbody></table><table><thead><tr><th>对象类型</th><th>“intset”</th><th>“hashtable”</th></tr></thead><tbody><tr><td>“set”</td><td>同时满足:<br>1. 集合对象保存的所有元素都是整数值；<br>2. 集合对象保存的元素数量不超过512个</td><td>不满足”intset”的条件的情况</td></tr></tbody></table><table><thead><tr><th>对象类型</th><th>“ziplist”</th><th>“skiplist”</th></tr></thead><tbody><tr><td>“zset”</td><td>同时满足:<br>1. 有序集合保持的元素数量小于128个；<br>2. 有序集合保持的所有元素成员的长度都小于64字节</td><td>不满足”ziplist”的条件的情况</td></tr></tbody></table><p><code>redisObject</code>有一个<code>lru</code>属性,这个属性记录了对象最后一次被命令程序访问的时间,<code>OBJECT IDLETIME</code>命令可以打印出给定键的空转时长(当前时间-lru时间), 另外当开启<code>maxmemory</code>选项，并且服务器用于内存回收的算法为<code>volatile-lru</code>或者<code>allkeys-lru</code>，那么当服务器占用的内存数超过了<code>maxmemory</code>选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本数据结构&quot;&gt;&lt;a href=&quot;#基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;基本数据结构&quot;&gt;&lt;/a&gt;基本数据结构&lt;/h2&gt;&lt;h3 id=&quot;简单的动态字符串&quot;&gt;&lt;a href=&quot;#简单的动态字符串&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="redis" scheme="http://oohcode.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收进阶算法</title>
    <link href="http://oohcode.com/2017/02/03/gc-advanced/"/>
    <id>http://oohcode.com/2017/02/03/gc-advanced/</id>
    <published>2017-02-03T07:25:21.000Z</published>
    <updated>2019-03-04T04:37:02.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解GC的基本算法后，还需要了解各种改进的GC算法，这些算法是在之前的基础上进行扩展和组合的。主要包括<code>GC标记-压缩算法</code>, <code>保守式GC</code>, <code>分代垃圾回收</code>， <code>增量式垃圾回收</code>和<code>RC Immix算法</code>等。</p></blockquote><h2 id="GC标记-压缩算法"><a href="#GC标记-压缩算法" class="headerlink" title="GC标记-压缩算法"></a>GC标记-压缩算法</h2><p>GC标记-压缩算法(Mark Compact GC)是将GC标记-清除算法与GC复制算法相结合的产物。 GC标记-压缩算法由标记阶段和压缩阶段构成。标记阶段和GC标记-清除算法提到的标记阶段一样。接下来需要搜索数次的堆来进行压缩。压缩阶段通过数次搜索堆来重新装填活动对象。</p><h3 id="Lisp2算法"><a href="#Lisp2算法" class="headerlink" title="Lisp2算法"></a>Lisp2算法</h3><p>标记阶段的代码就不重复了，这里主要看压缩阶段的代码，下面可以看出压缩阶段主要分为三个步骤:</p><ol><li>第一步是<code>set_forwarding_ptr</code>, 主要是按顺序遍历堆内的活动对象，每个活动对象的<code>forwarding</code>指针指向的是以后这个活动对象需要移动到的位置。</li><li>第二步是<code>adjust_ptr</code>, 遍历整个活动对象，复制他们之间的引用关系, 这个步骤只更新指针。</li><li>第三步<code>move_obj</code>, 遍历整个堆，对活动对象进行移动。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">compaction_phase() &#123;</span><br><span class="line">    set_forwarding_ptr()</span><br><span class="line">    adjust_ptr()</span><br><span class="line">    move_obj()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_forwarding_ptr() &#123;</span><br><span class="line">    scan = new_address = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 对被标记的对象，forwarding指针指向应该移动到的位置</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            scan.forwarding = new_address</span><br><span class="line">            new_address += scan.size</span><br><span class="line">        <span class="comment"># 遍历整个堆</span></span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="comment"># 移动根指针</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = (*r).forwarding</span><br><span class="line">    </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 每个活动对象，原来指向子节点的指针改为指向直接点的forwarding指向的地址</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move_obj() &#123;</span><br><span class="line">    scan = $free = $head_start</span><br><span class="line">    <span class="comment"># 遍历堆</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end) </span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            new_address = scan.forwarding</span><br><span class="line">            <span class="comment"># 移动当前对象到对象forwarding指针指向的地址</span></span><br><span class="line">            copy_data(new_address, scan, scan.size)</span><br><span class="line">            <span class="comment"># 移动完活动对象后清空指针和标记，防止再次移动</span></span><br><span class="line">            new_address.forwarding = NULL</span><br><span class="line">            new_address.mark = FALSE</span><br><span class="line">            <span class="comment"># $free最终是压缩后可分配空间的开始</span></span><br><span class="line">            $free += new_address.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的步骤可以用下面的图形化的例子来描述:<br>首先假设原始状态如下:<br><img src="/assets/img/gc/gc_mc_list2_1.png" alt="原始状态"><br>先对其进行标记:<br><img src="/assets/img/gc/gc_mc_list2_2.png" alt="标记后"><br>设定forwarding指针:<br><img src="/assets/img/gc/gc_mc_list2_3.png" alt="设定forwarding指针"><br>更新指针:<br><img src="/assets/img/gc/gc_mc_list2_4.png" alt="更新指针"><br>移动对象:<br><img src="/assets/img/gc/gc_mc_list2_5.png" alt="移动对象"><br>上面可以看出，整个过程只是把活动对象往一边移动，活动对象之间的顺序不变。</p><ul><li>优点: 这个算法相对其他算法而言，堆利用率高，而且所有活动对象压缩到一端，不存在碎片化，能够充分的利用堆。</li><li>缺点: 整个压缩过程需要3遍对堆的搜索，也就是执行该算法所花费的时间与堆大小成正比，吞吐量要劣于其他算法。</li></ul><h3 id="Two-Finger算法"><a href="#Two-Finger算法" class="headerlink" title="Two-Finger算法"></a>Two-Finger算法</h3><p>Two-Finger算法由两个步骤构成:</p><ol><li>移动对象</li><li>更新指针</li></ol><p>我们知道Lisp2算法是把所有对象向右滑动，不改变活动对象的顺序，而Two-Finger算法则是真正的移动对象，把后面的活动对象移动到前面的空间。为了防止对象相互覆盖，必须要将<code>所有对象整理成大小一致</code>, 这个该算法的一个前提条件。另外Lisp2算法需要单独设置forwarding指针，但是Two-Finger算法可以利用对象的域来设定forwarding指针，不要单独占空间。<br>两个步骤对象的伪代码如下, 要说明的是<code>move_obj</code>函数有两个指针:$free, 从头往后找，找空闲的空间； live，从后往前找，找活动对象。这两个指针就是Two-Finger的名称由来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">move_obj() &#123;</span><br><span class="line">    <span class="comment">#从头开始找空闲空间</span></span><br><span class="line">    $free = $heap_start</span><br><span class="line">    <span class="comment">#从尾开始找活动对象</span></span><br><span class="line">    live = $heap_end - OBJ_SIZE</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">        <span class="comment">#free, 是活动对像就略过,继续往后找</span></span><br><span class="line">        <span class="keyword">while</span>($free.mark == TRUE)</span><br><span class="line">            $free += OBJ_SIZE</span><br><span class="line">        <span class="comment">#live, 是活动对象就略过，继续往前找</span></span><br><span class="line">        <span class="keyword">while</span>(live.mark == FALSE)</span><br><span class="line">            live -= OBJ_SIZE</span><br><span class="line">        <span class="comment"># free 指针 比 live小，证明还没有结束，否则证明查找结束了</span></span><br><span class="line">        <span class="keyword">if</span>($free &lt; live)</span><br><span class="line">            <span class="comment">#把live指向的对象复制到free地址</span></span><br><span class="line">            copy_data($free, live, OBJ_SIZE)</span><br><span class="line">            <span class="comment">#live指向的对象的forwarding指针指向新地址，为下一步更新指针做准备</span></span><br><span class="line">            live.forwarding = $free</span><br><span class="line">            <span class="comment">#移动过的对象标记位FALSE</span></span><br><span class="line">            live.mark = FALSE</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="comment">#*r&gt;=$free的条件是对于被移动过的对象执行指针更新，没有移动过的对象保持原样</span></span><br><span class="line">        <span class="keyword">if</span>(*r &gt;= $free)</span><br><span class="line">            *r = (*r).forwarding</span><br><span class="line">        </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="comment">#scan &lt; $free 是因为对于大于scan的节点已经失效，只对当前活动对象更新</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        <span class="comment">#更新过的标记一下</span></span><br><span class="line">        scan.mark = FLASE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            <span class="comment">#*child &gt;= $free 的条件是对于被移动过的对象执行指针更新，</span></span><br><span class="line">            <span class="comment"># 没有移动过的对象保持原样</span></span><br><span class="line">            <span class="keyword">if</span>(*child &gt;= $free)</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += OBJ_SIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点: 不需要额外的内存存储forwarding指针，内存使用效率比Lisp2高，只搜索两次堆，吞吐量也更好.</li><li>缺点: 压缩后对象的顺序发生了很大变化，不利于缓存的使用。而且每个对象大小必须一致，限制比较多。</li></ul><h3 id="表格算法"><a href="#表格算法" class="headerlink" title="表格算法"></a>表格算法</h3><p>表格算法是综合了Lisp2和Two-Finger两种算法优点的算法。其主要步骤也是有两部分:</p><ol><li>移动对象(群)以及构筑间隙表格(break table)</li><li>更新指针</li></ol><p>前面两个每次都是移动一个活动对象，而在表格算法种每次移动的是一个群连续的活动对象，更新指针所有的信息也不再是forwarding指针，而是是有个一个叫间隙表格的方法。间隙表是由两个值组成的，其中每个表格代表的是一个活动对象群的入口，左值代表活动对象群的首地址，右值代表活动对象群所相邻的前面的空间占分块的总大小。<br>第一步过程可以用伪代码来表示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">movie_obj()&#123;</span><br><span class="line">    <span class="comment">#从头开始遍历</span></span><br><span class="line">    scan = $free = $heap_start</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == FLASE)</span><br><span class="line">            <span class="comment"># size 记录相邻的非活动对象的大小</span></span><br><span class="line">            size += scan.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 记录活动对象的首地址</span></span><br><span class="line">        live = scan</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == TRUE)</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 上面两个while后，找到了第一个连续的非活动空间和第一个连续的活动空间</span></span><br><span class="line">        <span class="comment"># 移动活动对象群，并构筑间隙表格</span></span><br><span class="line">        slide_objs_and_make_bt(scan, $free, live, size)</span><br><span class="line">        <span class="comment"># 移动后记录下一个空闲空间地址</span></span><br><span class="line">        $free += (scan -live)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>slide_objs_and_make_bt</code>函数是一个比较复杂的过程，它主要由两部分组成:</p><ol><li>移动对象群</li><li>移动间隙表格</li></ol><p>可以用下面的图表示:<br>首先执行完上面代码到<code>slide_objs_and_make_bt</code>之前:<br><img src="/assets/img/gc/gc_mc_tb_1.png" alt="间隙表格"><br>执行<code>slide_objs_and_make_bt</code>后, 移动了对象群，并且在空出来的空间里记录了间隙表格, 左值100表示对象群首地址B的地址，右值100表示B之前的空白块长度为100<br><img src="/assets/img/gc/gc_mc_tb_2.png" alt="间隙表格"><br>再次执行<code>slide_objs_and_make_bt</code>后，F开头的对象群也进行了移动，并且把两个活动对象群对应的间隙表格都放到了空白块中，第二个间隙表格的550表示F的起始地址，右值300表示第一次执行<code>slide_objs_and_make_bt</code>后，第一个活动对象群的末尾到第二个活动对象群的开始，正好是6块，也就是上图<code>$free</code>到<code>live</code>的size大小是300。执行完最终结果如下:<br><img src="/assets/img/gc/gc_mc_tb_3.png" alt="间隙表格"></p><p>第二步更新指针的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = new_address(*r)</span><br><span class="line">    </span><br><span class="line">    scan = $heap_start</span><br><span class="line">    <span class="comment"># 对活动对象更新指针</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        scan.mark = FALSE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            *child = new_address(*child)</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到活动对象对应的应该跟新到的指针地址</span></span><br><span class="line">new_address(obj) &#123;</span><br><span class="line">    best_entry = new_bt_entry(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(entry : break_table)</span><br><span class="line">        <span class="keyword">if</span>(entry.address &lt;= obj &amp;&amp; $best_entry.address &lt; entry.address)</span><br><span class="line">            best_entry = entry</span><br><span class="line">    <span class="keyword">return</span> obj - best_entry.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的<code>new_address</code>函数比较难理解，就是需要从多个间隙表格中找到活动对象群所对应的，然后利用obj-best_entry.size 就返回节点对应的新地址。</p><p>优点: 首先内存利用率和Two-Finger一样，但是由于是保持了原来的顺序，所以可以利用缓存。<br>缺点: 每次移动都要进行表格的移动和更新，代价比较高。</p><h3 id="ImmixGC-算法"><a href="#ImmixGC-算法" class="headerlink" title="ImmixGC 算法"></a>ImmixGC 算法</h3><p>暂略……</p><h2 id="保守式GC"><a href="#保守式GC" class="headerlink" title="保守式GC"></a>保守式GC</h2><p>前面提到过GC是根据对象的指针指向去搜寻其他对象的。另一方面，GC对非指针不进行任何操作。另外可以认为调用栈、寄存器以及全局变量空间都是根。对于上面存在一个问题就是: <strong>如何识别一个变量是否是指针?</strong> 这里所说的<strong>保守式GC</strong>就是指”不能识别指针和非指针的GC”, 而<strong>准确式GC</strong>指的就是能够正确识别指针和非指针的GC。</p><h3 id="保守式GC-1"><a href="#保守式GC-1" class="headerlink" title="保守式GC"></a>保守式GC</h3><p>之前说的下面这些空间都是根:</p><ul><li>寄存器</li><li>调用栈</li><li>全局变量空间</li></ul><p>但是事实上他们都是不明确的根(ambiguous roots)。<br>保守式GC对检查不明确的根时，所进行的基本项目是:</p><ul><li>是不是被正确对齐的值? (32位CPU，为4的倍数；64位CPU为8的倍数; 其他情况被视为非指针)</li><li>是不是指着堆内? (分配了GC专用堆，对象就会被分配到堆里，指向对象的指针按道理肯定指向堆内，否则就是非指针)</li><li>是不是指着对象的开头?(如果把对象固定大小对齐，例如”BiBOP”法，如果对象的值不是固定大小的倍数，就是非指针)</li></ul><p>当不明确的根运行GC时，偶尔会出现非指针和堆里的对象的地址一样的情况，这时就无法识别这个值是非指针，这就是<strong>“貌似指针的非指针”(false pointer)</strong>, 保守式GC这种把”貌似指针的非指针”看成”指向对象的指针”叫做”指针的错误识别”。在采用GC标记-清除算法，这种非指针会被错误的识别为活动对象，不会被回收。这样采取的是一种保守的态度，这样处理也不会出现问题。</p><ul><li>优点: 容易编写语言处理程序</li><li>缺点: 识别指针和非指针需要付出成本;错误识别指针会压迫堆, 会占用堆空间;能够使用的GC算法有限，不能使用移动对象的GC算法，否则就会重新非指针，照成意想不到的BUG</li></ul><h3 id="准确式GC"><a href="#准确式GC" class="headerlink" title="准确式GC"></a>准确式GC</h3><p>准确式GC是基于正确识别指针和非指针的<strong>“正确的根”(exact roots)</strong>来执行GC的。要想创建正确的根，就需要”语言处理程序的支援”, 依赖语言处理程序的实现。常见的方法这里介绍两种：</p><ul><li>打标签: 通过打标签的方法把不明确的根里的所有非指针和指针都区别开来。</li><li><p>不把寄存器和栈当做根: 创建一个正确的根来管理，这个正确的根在处理程序里只集合了mutator可能到达的指针，然后以它为基础执行GC。 参考Rubinius语言处理程序的实现。</p></li><li><p>优点: 相对于保守式GC，能够正确识别指针和非指针，适用的GC方法也更广泛。</p></li><li>缺点: 需要语言处理程序的支援，给实现者带来负担。</li></ul><h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><p>保守式GC有一个缺点就是”不能使用GC复制算法等移动对象的算法”, 因为如果是非指针的对象发生移动，其值就会发生变化，使用这个对象就会出现问题。解决这个问题的方法就是使用”间接引用”<br>结合下图来说明:<br>复制前可以看到根和对象之间有句柄。每个对象都有一个句柄，它们分别持有指向这些对象的指针。并且局部变量和全局变量这些不明确的根里没有指向对象的指针，只装着指向句柄的指针(如图中的1，2，3), 下图中的1，2表示指针，3表示非指针。<br><img src="/assets/img/gc/gc_handle_1.png" alt="间接引用1"><br>复制之后移动了引用目标的对象，只修改了1，2是指针的值，非指针3的值并没有发生改变。<br><img src="/assets/img/gc/gc_handle_2.png" alt="间接引用2"></p><ul><li>优点: 可以适用于更多的GC算法</li><li>缺点: 所有对象都要经由句柄间接引用，回拉低访问对象内数据的速度。</li></ul><h3 id="MostlyCopyingGC"><a href="#MostlyCopyingGC" class="headerlink" title="MostlyCopyingGC"></a>MostlyCopyingGC</h3><p>又是一个为了能够执行GC复制算法的保守式GC, 这个算法的核心思想就是抛开那些不能移动的对象，将其他”大部分”的对象都进行复制的GC算法，目的是为了保证不能移动的对象一定不会移动，可以移动的对象大部分都移动了，保证不出现BUG。<br>这个算法执行的前提条件:</p><ol><li>根是不明确的根</li><li>没有不明确的数据结构</li><li>对象大小随意</li></ol><p>执行这个算法的要点是把堆分配成一定大小的页(page)组成，执行分配的时候从正在使用的页里分配，如果空间不够则使用空页，如果一个页放不下，则会跨页存储。<br>执行GC时把所有根直接引用的页升级为To空间，然后再把To页对象的子对象复制到空页。这个过程会保留根直接引用的对象，所以不会复制非指针对象。同时升级的页中也包含了垃圾对象吗，无法清除。</p><h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><p>保守式GC指针的错误识别所带来害处和这个对象的大小及其子对象的数量有关系，如果一个对象很大，或者子对象很多，却被识别为”还活着”, 那就会在占用很多的堆空间。<br>这里的黑名单记录的是”不明确的根内的非指针，其指向的是有可能被分配对象的地址”， 这里说的”有可能被分配对象的地址”指的是”堆内未使用的对象的地址”。mutator无法引用至今未使用过的对象。也就是说，如果根里存在有这种地址的指针，那它肯定就是”非指针”，就会被记入黑名单中。在分配对象过程中，如果要分配的地址在黑名单中，这个对象有可能被非指针值所引用。也就是说，及时分配后对象成了垃圾，也很有可能被错误识别为”还活着”。为此，对象分配到这种地址是要满足:</p><ul><li>小对象</li><li>没有子对象的对象</li></ul><p>这样及时错误识别了，对整个堆的影响也不大，把对堆的压迫控制在最低限度。</p><h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p>分代垃圾回收(Generational GC)把对象按“年龄”进行分类，使用不同的GC算法, 提高垃圾回收的效率。<strong>年龄</strong>的概念就是指对象的生存时间，经历一次GC后活下来的对象年龄就是1，依次类推。 新生成的对象和年龄小于一定值得对象都称为<strong>新生代对象</strong>, 年龄大于一定值得对象则称为<strong>老年代对象</strong>, 这就是所谓的分代。新生代对象经历一定GC后会变成老年代对象，这个过程就叫<strong>晋升(promotion)</strong>。</p><h3 id="Ungar-的分代垃圾回收"><a href="#Ungar-的分代垃圾回收" class="headerlink" title="Ungar 的分代垃圾回收"></a>Ungar 的分代垃圾回收</h3><p>Ungar 的垃圾回收是针对新生代执行GC复制算法，针对老年代执行标记-清除算法。Ungar 将堆结构分为四个部分，分别是生成空间、2个大小相等的幸存空间以及老年代空间，并分别用<code>$new_start</code>、<code>$survivor1_start</code>、<code>$survivor2_start</code>、<code>$old_start</code>这4个变量引用它们的开头。将生成空间和幸存空间合称为新生代空间。<br>当生成空间满了的时候，新生代GC就会启动，将生成空间的所有活动对象复制，这根GC复制算法是一个道理。目标空间是幸存空间中空闲的一个。</p><pre>      记 录 集    +---+---+---+---+$rs |   |   |   |   |    +---------------+    +------------------------+ $new_start    |              +--------------+   $survivor1_start    |              |     +-------------+ $survivor2_start    |              |     |     +-----------+  $old_start    |              |     |     |                           堆    v--------------v-----v-----v-----------------------------+    |              |     |     |                             |    |              |     |     |                             |    |              |     |     |                             |    +--------------+-----+-----+-----------------------------+     生 成 空 间     幸 存 空 间            老 年 代 空 间           新 生 代 空 间</pre><p>分代垃圾回收的优点是只将垃圾回收的重点放在新生代对象上，以此来缩减GC所需的时间。但是老年代有可能引用了新生代对象，所以还需要遍历老年代对象，这样就大大削减了分代垃圾回收的优势，所以为了解决这个问题，又增加了一个<strong>记录集</strong>。记录集里记录的是对新生代有引用的老年代对象。这样在新生代GC时，只需要再对记录集进行遍历就行了。<br>为了将老年代对象记录到记录集里，我们利用写入屏障(write barrier)。在mutator更新对象间的指针操作中，写入屏障是不可或缺的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, new_obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj &gt;= $old_start <span class="comment">#发出引用的对象在老年代里</span></span><br><span class="line">        &amp;&amp; new_obj &lt; $old_start <span class="comment">#新生成的对象在新生代里</span></span><br><span class="line">        &amp;&amp; obj.remembered == FALSE) <span class="comment">#老年代对象没有被记录</span></span><br><span class="line">        $rs[$rs_index] = obj <span class="comment">#老年代对象加入记录集</span></span><br><span class="line">        $rs_index++ </span><br><span class="line">        obj.remembered = TRUE <span class="comment">#表示已经被记录过</span></span><br><span class="line">    *field = new_obj <span class="comment">#field是obj的指针，更新指针new_obj成为引用目标的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分配是在生成空间进行的，执行分配的<code>new_obj()</code>函数伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size) &#123;</span><br><span class="line">    <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line">        <span class="comment"># 生成空间不够用，执行新生代GC</span></span><br><span class="line">        minor_gc()</span><br><span class="line">        <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line">            <span class="comment"># 执行GC后仍然不够用，返回错误</span></span><br><span class="line">            allocation_fail()</span><br><span class="line">    </span><br><span class="line">    obj = $new_free <span class="comment">#$new_free 是指向生成空间的分块开头的指针</span></span><br><span class="line">    $new_free += size</span><br><span class="line">    obj.age = <span class="number">0</span> <span class="comment">#年龄默认值</span></span><br><span class="line">    obj.forwarded = FALSE <span class="comment">#防止重复复制相同对象的标志，跟GC复制算法和GC标记-压缩算法中的作用一样</span></span><br><span class="line">    obj.remembered = FALSE <span class="comment">#是否在记录集里，只用于老年代对象</span></span><br><span class="line">    obj.size = size</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新生代GC的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">minor_gc() &#123;</span><br><span class="line">    $to_survivor_free = $to_survivor_start</span><br><span class="line">    <span class="comment">#根在新生代的对象进行GC复制</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="keyword">if</span>(*r &lt; $old_start)</span><br><span class="line">            *r = copy(*r)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="comment">#对记录集里的对象的子节点进行GC复制</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; $rs_index)</span><br><span class="line">        has_new_obj = FALSE</span><br><span class="line">        <span class="keyword">for</span>(child : children($rs[i]))</span><br><span class="line">            <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">                *child = copy(*child)</span><br><span class="line">                <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">                    has_new_obj = TRUE</span><br><span class="line">        <span class="comment"># TRUE表示复制后的对象在新生代，FALSE表示复制后的对象在老年代</span></span><br><span class="line">        <span class="comment"># 复制后的对象在老年代，则需要把这个对象从记录集里去掉</span></span><br><span class="line">        <span class="keyword">if</span>(has_new_obj == FALSE)</span><br><span class="line">            $rs[i].remembered = FALSE</span><br><span class="line">            $rs_index--</span><br><span class="line">            <span class="comment">#最后一位与当前节点交换，交换后，最后一位无法在访问到，可以认为是从记录集里去掉了</span></span><br><span class="line">            swap($rs[i], $rs[$rs_index])</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++</span><br><span class="line">    <span class="comment">#交换From空间和To空间</span></span><br><span class="line">    swap($from_survivor_start, $to_survivor_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象的复制</span></span><br><span class="line">copy(obj) &#123;</span><br><span class="line">    <span class="comment">#没有被复制</span></span><br><span class="line">    <span class="keyword">if</span>(obj.forwarded == FALSE)</span><br><span class="line">        <span class="comment">#年龄没有达到</span></span><br><span class="line">        <span class="keyword">if</span>(obj.age &lt; AGE_MAX)</span><br><span class="line">            copy_data($to_survivor_free, obj, obj.size)</span><br><span class="line">            <span class="comment"># 标识已经被复制</span></span><br><span class="line">            obj.forwarded = TRUE</span><br><span class="line">            <span class="comment"># 被复制到的地址</span></span><br><span class="line">            obj.forwarding = $to_survivor_free</span><br><span class="line">            <span class="comment"># age++</span></span><br><span class="line">            $to_survivor_free.age++</span><br><span class="line">            $to_survivor_free += obj.size</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                *child = copy(*child)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># 年龄达到，晋升到老年代</span></span><br><span class="line">            promote(obj)</span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象从新生代晋升到老年代</span></span><br><span class="line">promote(obj) &#123;</span><br><span class="line">    <span class="comment">#从老年代找空间</span></span><br><span class="line">    new_obj = allocate_in_old(obj)</span><br><span class="line">    <span class="keyword">if</span>(new_obj == NULL)</span><br><span class="line">        <span class="comment">#空间不够执行老年代的GC，跟GC标记-清除法一样</span></span><br><span class="line">        major_gc()</span><br><span class="line">        new_obj = allocate_in_old(obj)</span><br><span class="line">        <span class="keyword">if</span>(new_obj == NULL)</span><br><span class="line">            allocation_fail()</span><br><span class="line">    obj.forwarding = new_obj</span><br><span class="line">    obj.forwarded = TRUE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(child : children(new_obj))</span><br><span class="line">        <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">            $rs[$rs_index] = new_obj</span><br><span class="line">            $rs_index++</span><br><span class="line">            new_obj.remembered = TRUE</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分代垃圾回收是建立在”很多对象年纪轻轻就会死”的基础上的，所以满足这种条件时，可以改善GC所花费的时间，提高吞吐量。是但是因为老年代GC很费时，所以没办法缩短mutator的最大暂停时间。并且如果不满足上面的条件时，就没办法利用到分代垃圾回收的优势。</p><h3 id="记录各代之间的引用的方法"><a href="#记录各代之间的引用的方法" class="headerlink" title="记录各代之间的引用的方法"></a>记录各代之间的引用的方法</h3><p>Ungar 分代垃圾回收的记录集是不可少的，但是这个记录集会浪费很多空间，为了提高内存利用率，可以通过下面两种方法：</p><ul><li>卡片标记: 把老年代空间等分成N个卡片，每份假设129字节(1024位)，可以用表格表格中位图的一位表示一个卡片，这样能够有效提高内存空间(只需老年代的1/1024)。当标记表格设置很多位时，可能就会在搜索卡片上花费大量时间。</li><li>页面标记: 利用OS的页面管理，如果在卡片标记中奖卡片和页面设置为同样大小，我们就能得到OS的帮助。一旦mutator对堆内的某一个页面进行写入操作，OS就会设置跟这个页面对应的位，我们把这个位叫做页面重写标志位(dirty bit)。卡片标记中是搜索标记表格，而页面标记则是搜索这个页面的重写标志位。</li></ul><h3 id="多代垃圾回收"><a href="#多代垃圾回收" class="headerlink" title="多代垃圾回收"></a>多代垃圾回收</h3><p>分代垃圾回收是把对象分为新生代和老年代两个，也可以分成3个及更多个, 分代越多，对象变成垃圾的机会也就越大，所以这个方法确实能够减少活到最老代的对象。但是每代的空间也就相应的变小了，这样一来各代之间的引用就变多了，各代中垃圾回收花费的时间也就越来越长了。综合来看，少设置一些分代能得到更优秀的吞吐量，据说分为2代或3代是最好的。</p><h3 id="列车垃圾回收"><a href="#列车垃圾回收" class="headerlink" title="列车垃圾回收"></a>列车垃圾回收</h3><p>Ungar 分代垃圾回收的一个问题是不能够减少最大暂停时间，而列车垃圾回收(Train GC)就是为了控制老年代GC中暂停时间的增长而设计的。列车垃圾回收中将老年代空间按照一定的大小划分，每个划分出来的空间称为车厢，多个车厢有组成列车，多个列车一起组成了老年代空间。1次老年代GC不再是对整个老年代空间进行，而是以1个车厢作为GC对象。<br>下面这幅图反应的是列车垃圾回收的堆结构:<br><img src="/assets/img/gc/train_gc_1.png" alt="列车垃圾回收堆结构"><br>具体过程省略……</p><ul><li>优点: 缩减了老年代GC照成的mutator的最大暂停时间。还能回收循环的大型垃圾。</li><li>缺点: 执行写入屏障的额外负担要比Ungar的分代垃圾回收中执行时所产生的更大，因此吞吐量上要弱一些。</li></ul><h2 id="增量式垃圾回收"><a href="#增量式垃圾回收" class="headerlink" title="增量式垃圾回收"></a>增量式垃圾回收</h2><p>增量式垃圾回收(Incremental GC)是一种通过逐渐推进垃圾回收来控制mutator最大暂停时间的方法。之前介绍的GC算法，一旦GC开始执行，mutator就没有办法执行了，像这样的GC叫做听执行GC。为了改变这种方式，想出了一种GC和mutator交替运行的方式，这就是增量垃圾回收。</p><h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h3><p>这个算法将GC中的对象按照各自情况分成三种:</p><ul><li>白色: 还未搜索过的对象</li><li>灰色: 正在搜索的对象</li><li>黑色: 搜索完成的对象</li></ul><p>以GC标记-清除算为例，应用到三色标记算法中。默认对象都是白色，GC一旦运行，所有从根能够到达的对象都会被标记，然后放到栈里。放到栈里的对象被标记成灰色，然后栈里的对象依次弹出，搜索其子对象，子对象也被标记成灰色。当其所有的子对象都被标记成灰色时，该对象就被标记成黑色。当GC结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾对象则为白色。<br>增量式的GC标记-清除算法可以分为以下三个阶段:</p><ul><li>根查找阶段</li><li>标记阶段</li><li>清除阶段</li></ul><p>下面是过程的伪代码，所谓标记为灰色并不是真正的标记为灰色，而是标记位TRUE,并放到栈中；置为黑色则只是标记为TRUE; 标记位白色的就是obj.mark=FALSE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">incremental_gc() &#123;</span><br><span class="line">    case $gc_phase</span><br><span class="line">    when GC_ROOT_SCAN</span><br><span class="line">        root_scan_phase() <span class="comment">#根查找阶段</span></span><br><span class="line">    when GC_MARK</span><br><span class="line">        incremental_mark_phase() <span class="comment">#增量标记阶段</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        incremental_sweep_phase() <span class="comment">#增量清除阶段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根查找函数</span></span><br><span class="line">root_scan_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        mark(*r)</span><br><span class="line">    $gc_phase = GC_MARK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        obj.mark = TRUE</span><br><span class="line">        push(obj, $mark_stack) <span class="comment">#灰色对象放到栈里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#增量标记</span></span><br><span class="line">incremental_mark_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX) <span class="comment"># MARK_MAX每次从栈中弹出对象的次数</span></span><br><span class="line">        <span class="keyword">if</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">            obj = pop($mark_stack) <span class="comment">#从栈中弹出灰色对象, 标记其子对象</span></span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                mark(*child)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#栈为空，重新从根开始查找</span></span><br><span class="line">            <span class="keyword">for</span>(r : $roots)</span><br><span class="line">                mark(*r)</span><br><span class="line">            <span class="comment">#从根查找完继续标记</span></span><br><span class="line">            <span class="keyword">while</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">                obj = pop($mark_stack)</span><br><span class="line">                <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                    mark(*child)</span><br><span class="line">        <span class="comment">#为清除阶段做准备</span></span><br><span class="line">        $gc_phase = GC_SWEEP</span><br><span class="line">        $sweeping = $heap_start</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入屏障，对于新节点，需要标记为灰色</span></span><br><span class="line"><span class="comment">#如果没有这一步，标记阶段进行到一半有可能不会对新的节点进行搜索</span></span><br><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newobj.mark == FALSE)</span><br><span class="line">        newobj.mark = TRUE</span><br><span class="line">        push(newobj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除阶段</span></span><br><span class="line">incremental_sweep_phase() &#123;</span><br><span class="line">    swept_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(swept_count &lt; SWEEP_MAX) <span class="comment">#每次清除SWEEP_MAX个对象</span></span><br><span class="line">        <span class="keyword">if</span>($sweeping &lt; $heap_end)</span><br><span class="line">            <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line">                $sweeping.mark = FALSE</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">#mark=false表示白色，放入到空闲链表中</span></span><br><span class="line">                $sweeping.next = $free_list</span><br><span class="line">                $free_list = $sweeping</span><br><span class="line">                $free_size += $sweeping.size</span><br><span class="line"></span><br><span class="line">            $sweeping += $sweeping.size</span><br><span class="line">            swept_count++</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $gc_phase = GC_ROOT_SCAN</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#分配</span></span><br><span class="line">newobj(size) &#123;</span><br><span class="line">    <span class="comment">#$free_siz 小于一定量时就执行GC， 而不是等到空间枯竭</span></span><br><span class="line">    <span class="keyword">if</span>($free_size &lt; HEAP_SIZE * GC_THRESHOLD)</span><br><span class="line">        incremental_gc()</span><br><span class="line">    </span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        chunk.size = size</span><br><span class="line">        $free_size -= size</span><br><span class="line">        <span class="comment">#chunk如果在清除阶段在要清除的空间，需要涂黑，表示不可回收</span></span><br><span class="line">        <span class="keyword">if</span>($gc_phrase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面整个过程，分配和GC是交替进行的，而且GC的三个阶段也是按顺序循环进行的，每次执行incremental_gc()都会进入下一个阶段。</p><ul><li>优点: 增量式垃圾回收不是一口气运行GC,而是和mutator交替运行的，因此不会长时间妨碍到mutator的运行。</li><li>缺点: 牺牲了吞吐量。吞吐量和最大暂停时间是互相权衡的，一方面做的好另一方面就会变差。</li></ul><h3 id="Steele的算法"><a href="#Steele的算法" class="headerlink" title="Steele的算法"></a>Steele的算法</h3><p>这个算法中使用的写入屏障要比上面(Dijkstra)的写入屏障条件更严格，它能减少GC中错误的标记的对象。<br>这个算法的标记函数如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出在放入栈时并没有标记<code>obj.mark=TRUE</code>, 也就是说这个算法的<strong>灰色对象</strong>是指”堆在标记栈里的没有设置标志位的对象”, 黑色对象是”设置了标志位的对象”。<br>写入屏障的伪代码也不一样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    <span class="keyword">if</span>($gc_phase == GC_MARK &amp;&amp;</span><br><span class="line">        obj.mark == TRUE &amp;&amp;</span><br><span class="line">        newobj.mark == FALSE)</span><br><span class="line">        obj.makr = FALSE</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码主要是判断如果在标记过程中发出引用的对象是黑色对象，且新的引用的目标对象为灰色或白色，那么我们就把发出引用的对象涂成灰色。Steele的写入屏障通过限制标记对象来减少被标记的对象，从而防止了因疏忽而造成垃圾残留的后果。 (详情参见P175)</p><h3 id="汤浅的算法"><a href="#汤浅的算法" class="headerlink" title="汤浅的算法"></a>汤浅的算法</h3><p>汤浅的算法中标记阶段并没有在搜索根，遵循了”以GC开始时对象间的引用关系为基础执行GC”这项原则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">incremental_mark_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX)</span><br><span class="line">        <span class="keyword">if</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">            obj = pop($mark_stack)</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                mark(*child)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        $gc_phrase = GC_SWEEP</span><br><span class="line">        $sweeping = $heap_start</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面通过写入屏障防止产生从黑色对象指向白色对象的指针，而汤浅的算法中却允许黑色对象指向白色对象的指针。汤浅算法是基于在GC开始时保留活动对象这项原则，就没有必要在生成新指针时标记引用对象的目标了。及时出现了从黑色对象指向白色对象的指针，只要保留了GC开始时的指针，作为引用目标的白色对象早晚会被标记。但是在删除指针时无法保留指针，因此写入屏障要进行一些特殊处理:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    oldobj = *field</span><br><span class="line">    <span class="comment">#在标记阶段中如果指针更新前引用的oldobj是白色对象，就将其涂成灰色</span></span><br><span class="line">    <span class="keyword">if</span>(gc_phase == GC_MARK &amp;&amp; oldobj.mark == FALSE)</span><br><span class="line">        oldobj.mark = TRUE</span><br><span class="line">        push(oldobj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分配</span></span><br><span class="line">newobj(size) &#123;</span><br><span class="line">    <span class="keyword">if</span>($free_size &lt; HEAP_SIZE  * GC_THRESHOLD)</span><br><span class="line">        incremental_gc()</span><br><span class="line"></span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        chunk.size = size</span><br><span class="line">        $free_size -= size</span><br><span class="line">        <span class="comment">#这里跟之前不一样，分配后会设置obj为黑色</span></span><br><span class="line">        <span class="keyword">if</span>($gc_phase == GC_MARK)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RC-Immix算法"><a href="#RC-Immix算法" class="headerlink" title="RC Immix算法"></a>RC Immix算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;了解GC的基本算法后，还需要了解各种改进的GC算法，这些算法是在之前的基础上进行扩展和组合的。主要包括&lt;code&gt;GC标记-压缩算法&lt;/code&gt;, &lt;code&gt;保守式GC&lt;/code&gt;, &lt;code&gt;分代垃圾回收&lt;/code&gt;， &lt;code&gt;增量
      
    
    </summary>
    
    
      <category term="gc" scheme="http://oohcode.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收基本算法</title>
    <link href="http://oohcode.com/2017/01/23/gc-base/"/>
    <id>http://oohcode.com/2017/01/23/gc-base/</id>
    <published>2017-01-23T06:24:36.000Z</published>
    <updated>2019-03-04T04:37:02.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章介绍GC的基本算法:GC标记-清除法，引用计数法, GC复制算法。这三种我认为是GC的三个方向的基本思维。其他方法都是围绕这个些基本方法展开的。</p></blockquote><h2 id="GC标记-清除法"><a href="#GC标记-清除法" class="headerlink" title="GC标记-清除法"></a>GC标记-清除法</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>所谓的标记-清除法，依据其字面意思就是，先做标记，然后在清除。这个过程分为两个阶段，标记阶段就是把所有活动对象坐上标记，清除阶段就是把那些没有做标记的对象，也就是非活动对象回收的阶段。利用伪代码表示就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mark_sweep() &#123;</span><br><span class="line">    mark_phase()</span><br><span class="line">    sweep_phase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>标记阶段: 这个阶段从<code>根</code>出发，利用深度优先遍历(不用广度优先是因为深度优先搜索比广度优先搜索更能压低内存使用量。), 对每个能到达的活动对象都做上标记(用一个位来表示)。这个阶段所花费的时间与”活动对象的总数”成正比。标记阶段伪代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mark_phase() &#123;</span><br><span class="line">    <span class="comment">#遍历根节点, 进行标记</span></span><br><span class="line">    <span class="keyword">for</span>(r: $roots)</span><br><span class="line">        mark(*r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#标记函数</span></span><br><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        obj.mark = TRUE</span><br><span class="line">        <span class="comment">#深度优先遍历</span></span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            mark(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清除阶段: 清除阶段主要工作是通过遍历整个堆，把未被标记的对象(非活动对象)回收再利用。回收对象就是把对象作为分块，连接到被称为”空闲链表”的单向链表。之后进行分配时遍历空闲链表就可以找到分块了。两个相邻的分块如果地址是连续的，就会对其进行<strong>合并</strong>, 合并操作可以减少碎片的发生。清除阶段的伪代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase() &#123;</span><br><span class="line">    sweeping = $heap_start</span><br><span class="line">    <span class="comment">#遍历堆</span></span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">            sweeping.mark == FALSE</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#放入空闲链表</span></span><br><span class="line">            <span class="keyword">if</span>(sweeping.mark == $free_list + $free_list.size)</span><br><span class="line">                <span class="comment">#合并</span></span><br><span class="line">                $free_list.size += sweeping.size</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sweeping.next = $free_list</span><br><span class="line">                $free_list = sweeping</span><br><span class="line">            sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分配: 进行mutator申请分块时，搜索空闲链表并找到合适大小的分块，这个过程就叫做分配。找到合适的分块大小有三种策略:</p><ol><li>First-fit: 找到最初发现大于等于size的分块就立刻返回。考虑到分配所需的时间，标记清除法选择的就是这种方法。</li><li>Best-fit: 遍历空闲链表，找到大于等于size的最小分块返回。</li><li>Worst-fit: 找出最大的分块，把分块分割成size大小和剩余分块。<br>分配阶段的伪代码:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size) &#123;</span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="优点-缺点"><a href="#优点-缺点" class="headerlink" title="优点/缺点"></a>优点/缺点</h3><ul><li>优点:<ol><li>实现简单</li><li>与保守式GC算法兼容: 保守式算法就是不知道对象是否是指针，所以移动对象会造成错误(后面会讲到), 而标记清除算法是不会移动对象的，所以是兼容的。</li></ol></li><li>缺点:<ol><li>碎片化: 由于非活动对象分布不均匀，容易照成堆内的内存空间碎片化，不利于mutator的执行。</li><li>分配速度: 由于分配时需要遍历空闲链表，查找速度取决于要分配的块和空闲链表的分布。后面要讲到的复制算法和标记-压缩算法由于分块是连续内存分布的，所以速度要快。</li><li>与写时复制技术不兼容： 因为每次GC都要修改活动对象的标记位，导致写操作的发生，从而产生复制。</li></ol></li></ul><h3 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h3><p>为了提高<strong>分配速度</strong>，一个改进就是把分块按照大小分为多个空闲链表，这样在分配的时候就可以根据要分配的空间的大小去对应的空闲链表中寻找，大大减少了查找分块的时间。<br>下面是利用多个空闲链表的new_obj()函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#index 是一个要分配的字的大小</span></span><br><span class="line">    index = size / (WORD_LENGTH / BYTE_LENGTH)</span><br><span class="line">    <span class="comment">#空闲链表一共有101个，0-100都是按照字精确分配到对应的$free_list[index]中，</span></span><br><span class="line">    <span class="comment">#大于100的字都分配到$free_list[101]中</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span>($free_list[index] != NULL)</span><br><span class="line">            <span class="comment">#直接找到对应的空闲链表</span></span><br><span class="line">            chunk = $free_list[index]</span><br><span class="line">            $free_list[index] = $free_list[index].next</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">#大于100的需要遍历$free_list[101]找到合适大小的块</span></span><br><span class="line">        chunk = pickup_chunk(size, $free_list[<span class="number">101</span>])</span><br><span class="line">        <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line"></span><br><span class="line">    allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BiBOP法"><a href="#BiBOP法" class="headerlink" title="BiBOP法"></a>BiBOP法</h3><p>针对标记-清除算法的<strong>碎片化</strong>问题, 可以把堆先分割成大小固定的块，让每个块只能配置同样大小的对象，这就是BiBOP法。如果某个大小字的活动对象很少，其他的字活动对象很多的话，这种情况也不能提高堆的利用率，无法解决碎片化的问题。</p><h3 id="位图标记法"><a href="#位图标记法" class="headerlink" title="位图标记法"></a>位图标记法</h3><p>上面还说道标记-清除法不能够与写时复制技术兼容是因为修改标记位会引起复制发生，为了解决这个问题，位图标记法采用只收集各个对象的标志位并表格化，不跟对象一起管理。也就是把对象和标记位进行了分离。这样做有两个好处:</p><ol><li>与写时复制技术兼容: 因为GC的时候改变了标记位也不会引起对象的复制, 而位图表格非常小，所以即使被复制也不会有什么大的影响。</li><li>清除操作更高效: 在遍历堆的时候不需要取消标志位，可以最后在位图表格中设置。</li></ol><h3 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h3><p>延迟清除法(Lazy Sweep)是缩减因清除操作而导致的mutator最大暂停时间的方法。这个方法的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#用延迟清除法找到对应的块</span></span><br><span class="line">    chunk = lazy_sweep(size)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="comment">#没有找到合适的，进行一次标记操作</span></span><br><span class="line">    mark_phase()</span><br><span class="line">    <span class="comment">#再用延迟清除法找到对应的块 </span></span><br><span class="line">    chunk = lazy_sweep(size)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">     </span><br><span class="line">    allocation_fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_sweep(size)&#123;</span><br><span class="line">    <span class="keyword">while</span>($sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line">            $sweeping.mark == FALSE</span><br><span class="line">        <span class="comment">#找到和大小合适的块</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>($sweeping.size &gt; size)</span><br><span class="line">            chunk = $sweeping</span><br><span class="line">            $sweeping += $sweeping + $sweeping.size</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">        <span class="comment">#没找到继续往下找</span></span><br><span class="line">        $sweeping += $sweeping + $sweeping.size</span><br><span class="line">    <span class="comment">#遍历完了也没找到，$sweeping置为从头开始</span></span><br><span class="line">    $sweeping = $heap_start</span><br><span class="line">    <span class="keyword">return</span> NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里跟之前不同的是$sweeping是一个全局变量，每次执行lazy_sweep的时候都会从当前$sweeping的位置往后查找。如果第一次没有找到，第二次就会从头开始查找，如果第二次也没有查到，那就是没有可以分配的块了。一般情况下第一次查找范围变小了，mutator的执行时间就短了。但是有一个问题是就是当数据分配不均，比如说后面的都是活动对象，前面的都是空的，反而会增加mutator的时间。如何改善这个问题，后面会再说到。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>GC的目的是为了释放无法被引用的对象，自然就会想到让每个对象记录下自己被引用的个数，如果个数为0表示无法被引用，那就可以对其进行回收。这种思路就是引用计数法(Reference Counting)。</p><h3 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h3><p>引用计数法最重要的就是引入了一个计数器，用来记录被引用的个数。首先先看一下引用计数法的伪代码实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成新对象</span></span><br><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#从空闲链表中找到合适的块</span></span><br><span class="line">    obj = pickup_chunk(size, $free_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">        allocation_fail()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">#对象有一个计数器，成功生成后计数器值是1</span></span><br><span class="line">        obj.ref_cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新ptr指针，使其指向新对象obj</span></span><br><span class="line">update_ptr(ptr, obj)&#123;</span><br><span class="line">    <span class="comment">#被指向的对象计数器+1</span></span><br><span class="line">    inc_ref_cnt(obj)</span><br><span class="line">    <span class="comment">#原来指向的对象计数器-1</span></span><br><span class="line">    dec_ref_cnt(*ptr)</span><br><span class="line">    <span class="comment">#指向新对象</span></span><br><span class="line">    *ptr = obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数器+1</span></span><br><span class="line">inc_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数器-1</span></span><br><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    <span class="comment">#obj计数器-1</span></span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="comment">#obj计数器为0，说明对象变成了"垃圾", 需要对其子对象计数器都-1， 因为这个对象不存在了。</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            dec_ref_cnt(*child)</span><br><span class="line">        <span class="comment">#将obj连接到空闲链表中</span></span><br><span class="line">        reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面需要注意的一点是执行<code>update_ptr</code>的时候先执行了<code>inc_ref_cnt</code>后执行了<code>dec_ref_cnt</code>, 这是因为当<code>update_ptr</code>的前后两个对象是同一个时，如果先指向了<code>dec_ref_cnt</code>就会把这个对象删除，再执行<code>inc_ref_cnt</code>时就会出错，而顺序反过来就不会存在这个问题了。还有一点是引用计数法和标记清除法不一样的地方:引用计数法会在指针变动时发现是否是垃圾，从而立即回收，而标记清除法则即使发现了也不会立即回收，而是标记完后一起回收。</p><h3 id="优点-缺点-1"><a href="#优点-缺点-1" class="headerlink" title="优点/缺点"></a>优点/缺点</h3><ul><li><p>优点</p><ol><li>可以即刻进行垃圾回收</li><li>最大暂停时间短: 只在发生引用关系变化时立即回收。</li><li>没有必要沿指针查找: 根据每个变量的引用计数来回收，不需要进行遍历。</li></ol></li><li><p>缺点</p><ol><li>计数器值的增减处理繁重</li><li>计数器需要占用很多位: 计数器需要记录被引用的个数，这个记录位会占用不少的内存空间。</li><li>实现繁琐复杂</li><li>循环引用无法回收:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    string name</span><br><span class="line">    Person lover</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taro = <span class="keyword">new</span> Person(<span class="string">"太郎"</span>) <span class="comment">//执行后taro的引用计数为1</span></span><br><span class="line">hanako = <span class="keyword">new</span> Person(<span class="string">"花子"</span>) <span class="comment">//执行后hanako的引用计数为1</span></span><br><span class="line">taro.lover = hanako <span class="comment">//执行后hanako的引用计数为2</span></span><br><span class="line">hanako.lover = taro <span class="comment">//执行后taro的引用计数为2</span></span><br><span class="line">taro = <span class="keyword">null</span> <span class="comment">//taro指向null, hanako引用计数-1，变为1</span></span><br><span class="line">hanako = <span class="keyword">null</span> <span class="comment">//hanako指向null, taro引用计数-1， 变为1</span></span><br><span class="line"><span class="comment">//全部执行完后taro与hanako的引用计数都为1，不能被回收，但是又无法被引用, 照成了内存泄露的情况</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p>用图来说请其中的过程如下：<br><img src="/assets/img/gc/rc_cr.png" alt="循环引用图解"></p><h3 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h3><p>上面说到引用计数法的计数器值得<strong>增减处理很繁重</strong>，为了改善这个缺点，引入了延迟引用计数法(Deferred Reference Counting)。延迟引用计数法利用ZCT(Zero Count Table)来记录计时器值在dec_ref_cnt()作用下变为0的对象, zct表内的值是指向这些对象的指针。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#update_ptr($ptr, obj)调用不变，只是dec_ref_cnt不会递每次都递归处理子节点的引用计数</span></span><br><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">#$zct满了就执行一次扫描</span></span><br><span class="line">        <span class="keyword">if</span>(is_full($zct) == TRUE)</span><br><span class="line">            scan_zct()</span><br><span class="line">        push($zct, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_obj(size)&#123;</span><br><span class="line">    obj = pickup_chunk(size, $free_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">        <span class="comment">#空间不够执行一次扫描, 释放空间</span></span><br><span class="line">        scan_zct()</span><br><span class="line">        obj = pickup_chunk(size, $free_list)</span><br><span class="line">        <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">            allocation_fail()</span><br><span class="line"></span><br><span class="line">    obj.ref_cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#扫描zct</span></span><br><span class="line">scan_zct()&#123;</span><br><span class="line">    <span class="comment">#对根直接引用的对象都进行增量， 把根引用反映到计数器的值上</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        (*r).ref_cnt++</span><br><span class="line">    <span class="comment">#对子对象的计数器进行减量操作，回收 </span></span><br><span class="line">    <span class="keyword">for</span>(obj : $zct)</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">            remove($zct, obj)</span><br><span class="line">            delete(obj)</span><br><span class="line">    <span class="comment">#恢复根节点直接引用的对象计数器的值</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        (*r).ref_cnt--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#减量操作和回收</span></span><br><span class="line">delete(obj)&#123;</span><br><span class="line">    <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">        (*child).ref_cnt--</span><br><span class="line">        <span class="keyword">if</span>((*child).ref_cnt == <span class="number">0</span>)</span><br><span class="line">            delete(*child)</span><br><span class="line"></span><br><span class="line">    reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>书举例说<code>update_ptr($ptr, obj)</code>改写成<code>*$ptr = obj</code>, 我理解这只是举了一个例子说明不需要增减计数器。实际后面的代码中可以看出，还是使用的<code>update_ptr($ptr, obj)</code>,否则就没有对<code>dec_ref_cnt(obj)</code>的调用了。变化比较大的是<code>dec_ref_cnt(obj</code>函数，它不再递归调用子节点的计数器减量，而是直接把它放到zct结构中，在必要时调用scan_zct, 这就大大减少了计数器值得增减。</p><ul><li>优点: 延迟了根引用的技术，将垃圾一并回收，减轻了因根引用频发发生的变化导致计数器增减所带来的额外负担。</li><li>缺点: 失去了引用计数法的一大优点–可即可回收垃圾。另外scan_zct()导致最大暂停时间延长了。</li></ul><h3 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h3><p>引用计数法有一个问题就是计数器要设置多大的位宽。如果设置的小了，有可能会出现存不下而溢出的情况；如果设置的大了，又会占用过多的空间。Sticky的思想就是设置一个固定大小的位数，这个位数要比较小，对于溢出的情况下面两种处理方式:</p><ul><li>什么都不做<br>当计数器出现溢出时，不对其进行任何操作，其值就是能存储的最大值，一般情况下这个值很难达到，如果达到了这个值，证明其非常重要，其成为垃圾的可能性也非常小，对其计数不增也不减，不会存在什么大的问题。</li><li>使用GC标记-清除算法进行管理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mark_sweep_for_counter_overflow()&#123;</span><br><span class="line">    <span class="comment">#所有计数器清零</span></span><br><span class="line">    reset_all_ref_cnt()</span><br><span class="line">    mark_phase()</span><br><span class="line">    sweep_phase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#对所有可以达到的节点进行标记，每个节点及其子节点只会进栈一次，所以引用计数的值最多为2， 不会出现溢出的情况</span></span><br><span class="line">mark_phase()&#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="comment">#所有根节点放到标记栈中</span></span><br><span class="line">        push(*r, $mark_stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">        obj = pop($mark_stack)</span><br><span class="line">        <span class="comment">#弹出栈，引用计数+1</span></span><br><span class="line">        obj.ref_cnt++</span><br><span class="line">        <span class="comment">#只有引用计数为1才让其子节点进栈，已经进过的不会再进</span></span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                push(*child, $mark_stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除节点遍历堆，所有标记位为0的节点进行回收</span></span><br><span class="line">sweep_phase()&#123;</span><br><span class="line">    sweeping = $heap_top</span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>(sweeping.ref_cnt == <span class="number">0</span>)</span><br><span class="line">            reclaim(sweeping)</span><br><span class="line">        sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这么做可以在溢出后依然回收，而且没有对循环引用页适用，但是需要重置计数器。查找对象时没有设置标记位，而只是增量计数器，会出现多次查找活动对象的问题。比起一般的GC标记-清除算法需要更多的时间，吞吐量也会变小。</p><h3 id="1位引用计数法"><a href="#1位引用计数法" class="headerlink" title="1位引用计数法"></a>1位引用计数法</h3><p>1位引用计数法(1 bit Reference Counting)是Sticky引用计数法的极端例子，计数器只有1位大小。这里的计数器不在表示引用的个数，而是表示有一个引用还是多个引用。</p><ol><li>当计数器值为0，表示对象引用数为1，这种状态称为<strong>UNIQUE</strong></li><li>当计数器值为1， 表示引用数为复数, 这种状态称为<strong>MULTIPLE</strong></li></ol><p>相关伪代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指针复制 </span></span><br><span class="line"><span class="comment">#dest_ptr: 目的指针 </span></span><br><span class="line"><span class="comment">#src_ptr: 源指针 </span></span><br><span class="line">copy_ptr(dest_ptr, src_ptr)&#123;</span><br><span class="line">    <span class="comment">#由于目的指针原来指向的内容不再指向，需要对目的指针指向删除操作 </span></span><br><span class="line">    delete_ptr(dest_ptr)</span><br><span class="line">    <span class="comment">#执行复制 </span></span><br><span class="line">    *dest_ptr = *src_ptr</span><br><span class="line">    <span class="comment">#目的指针由于和源指针指向了同一个对象，目的指针需要设置为MULTIPLE </span></span><br><span class="line">    set_multiple_tag(dest_ptr)</span><br><span class="line">    <span class="comment">#源指针如果原来是UNIQUE, 现在多了一个目的指针，需要设置为MULTIPLE </span></span><br><span class="line">    <span class="keyword">if</span>(tag(src_ptr) == UNIQUE)</span><br><span class="line">        set_multiple_tag(src_ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除目的指针原来的指向对象 </span></span><br><span class="line">delete_ptr(ptr)&#123;</span><br><span class="line">    <span class="comment">#如果原来是UNIQUE，说明对象只有一个指针，删除后需要回收 </span></span><br><span class="line">    <span class="keyword">if</span>(tag(ptr) == UNIQUE)</span><br><span class="line">        <span class="comment">#回收 </span></span><br><span class="line">        reclaim(ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其过程可以参考下图:<br><img src="/assets/img/gc/1bit_rc.png" alt="1bit_rc"></p><ul><li>优点: <ol><li>不容易出现高速缓存缺失， 如上图所示，在更新计数器的时候不需要读取元素的值到内存中（C,D完全没有读), 只需要更新指针的计数器，所以不会出现内存中离得远找出缓存缺失。</li><li>计数器所占空间很小，节省内存。</li></ol></li><li>缺点: 1位引用计数器是在大量计数器都不足2的前提下来做的，当出现大量大于2的计数器时，1位引用计数器方法就无法回收这些对象，给堆带来巨大负担。</li></ul><h3 id="部分标记-清除算法"><a href="#部分标记-清除算法" class="headerlink" title="部分标记-清除算法"></a>部分标记-清除算法</h3><p>部分标记清除法主要是针对之前的无法回收循环引用的缺点而产生的。之前讲的<strong>延迟引用计数法</strong>可以处理循环引用的情况，但是效率太低。部分-标记清除算法只针对有可能是循环引用的对象上执行，在一般的对象上还是执行引用计数法。下面结合代码图图示说明一下部分标记-清除算法的过程。</p><p>部分标记-清除算法中，对象被涂成四种颜色来管理。每个颜色的含义如下：</p><ol><li>黑(BLACK): 绝对不是垃圾的对象(对象产生时的初始颜色)</li><li>白(WHITE): 绝对是垃圾的对象</li><li>灰(GRAY): 搜索完毕的对象</li><li>阴影(HATCH): 可能是循环垃圾的对象</li></ol><p>首先我们假设有一个循环引用对象群，<strong>初始状态</strong>如下：<br><img src="/assets/img/gc/pms_rc_1.png" alt="初始状态"><br>图中A和D是由根引用。所有对象在初始状态下都为黑色。<br>对应的初始代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    obj = pickup_chunk(size)</span><br><span class="line">    <span class="keyword">if</span>(obj != NULL)</span><br><span class="line">        <span class="comment">#初始颜色会BLACK</span></span><br><span class="line">        obj.color = BLACK</span><br><span class="line">        obj.ref_cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_empty($hatch_queue) == FALSE)</span><br><span class="line">        <span class="comment">#当空间不够用时扫描可能是循环引用的对象，然后释放出新的空间, 再次调用new_obj</span></span><br><span class="line">        scan_hatch_queue()</span><br><span class="line">        <span class="keyword">return</span> new_obj(size)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当执行<code>dec_ref_cnt()</code>时, 引用计数为0， 则回收。不为0时都认为是<strong>可能存在循环引用</strong>的对象, 都标记成HATCH, 并且把这个对象放到<code>$hatch_queue</code>当中。代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="comment">#ref_cnt == 0, 回收对象</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        delete(obj)</span><br><span class="line">    <span class="comment">#ref_cnt != 0 认为是可能存在循环引用的对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)</span><br><span class="line">        obj.color = HATCH</span><br><span class="line">    enqueue(obj, $hatch_queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对上面的图，如果A的引用被删除了，则执行<code>dec_ref_cnt()</code>之后的状态如下图:</p><p><img src="/assets/img/gc/pms_rc_2.png" alt="执行dec_ref_cnt"></p><p>这是对象群在调用<code>new_obj()</code>时已经没有心的内存空间可以使用，所以会触发<code>scan_hatch_queue()</code>函数的调用。对应代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scan_hatch_queue()&#123;</span><br><span class="line">    <span class="comment">#可能是循环引用的对象出队列</span></span><br><span class="line">    obj = dequeue($hatch_queue)</span><br><span class="line">    <span class="comment">#如果颜色为HATCH, 依次调用下面的函数</span></span><br><span class="line">    <span class="keyword">if</span>(obj.color == HATCH)</span><br><span class="line">        paint_gray(obj)</span><br><span class="line">        scan_gray(obj)</span><br><span class="line">        collect_white(obj)</span><br><span class="line">    <span class="comment">##如果颜色不为HATCH, 证明不是循环引用对象，继续下一个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_empty($hatch_queue) == FALSE)</span><br><span class="line">        scan_hatch_queue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面需要调用的<code>paint_gray(obj)</code>函数主要作用是深度遍历对象，搜索过的对象标记位GRAY:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">paint_gray()&#123;</span><br><span class="line">    <span class="comment">#对原来是BLACK或HATCH的对象标记为GRAY</span></span><br><span class="line">    <span class="keyword">if</span>(obj.color == (BLACK | HATCH))</span><br><span class="line">        obj.color = GRAY</span><br><span class="line">    <span class="comment">#深度遍历子节点，引用计数减量, 递归调用paint_gray记性标记</span></span><br><span class="line">    <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">        (*child).ref_cnt--</span><br><span class="line">        paint_gray(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完上面的函数后，对象的状态如下图:<br><img src="/assets/img/gc/pms_rc_3.png" alt="执行dec_ref_cnt"><br>下面<code>scan_gray(obj)</code>的目的是扫描刚才的GRAY节点，把其中的垃圾对象找出来，标记成WHITE:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scan_gray(obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == GRAY)</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">#ref_cnt&gt;0, 不是垃圾，需要标记成BLACK</span></span><br><span class="line">            paint_black(obj)</span><br><span class="line">            <span class="comment">#ref_cnt == 0, 是垃圾对象，标记成WHITE</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            obj.color = WHITE</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                scan_gray(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">paint_black(obj)&#123;</span><br><span class="line">    obj.color = BLACK</span><br><span class="line">    <span class="keyword">for</span>(child : chidren(obj))</span><br><span class="line">        <span class="comment">#由于执行paint_gray的时候ref_cnt--, 这里要恢复ref_cnt</span></span><br><span class="line">        (*child).ref_cnt++</span><br><span class="line">        <span class="keyword">if</span>((*child).color != BLACK)</span><br><span class="line">            paint_black(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记后的对象如下:<br><img src="/assets/img/gc/pms_rc_4.png" alt="执行dec_ref_cnt"><br>到上面的步骤后，可以看出已经知道那些颜色为WHITE的对象就是垃圾对象，这些对象需要回收，回收代码入下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">collect_white()&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == WHITE)</span><br><span class="line">        obj.color = BLACK</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            collect_white(*child)</span><br><span class="line">        reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回收后的图如下:<br><img src="/assets/img/gc/pms_rc_5.png" alt="执行dec_ref_cnt"><br>上面就是部分标记-清除算法的过程。这个算法的优点就是，只搜索可能是循环垃圾的对象群，就是阴影部分，如何确定这个范围呢？首先产生垃圾循环的条件有两个:</p><ol><li>产生循环引用。</li><li>删除从外部到循环引用的引用。</li></ol><p>部分标记-清除算法就利用<code>dec_ref_cnt()</code>函数来判断，如果引用计数减值后不为0， 那这个对象有可能就是循环对象的一份子。<br>这个算法的缺点就是需要三次查找对象，而每次查找的数量不少，所以付出的成本比较大。</p><h2 id="GC复制算法"><a href="#GC复制算法" class="headerlink" title="GC复制算法"></a>GC复制算法</h2><p>GC复制算法把原来的内存空间分为两部分(From空间和To空间), 当From空间不够分配时，就会执行GC复制算法，把From空间的活动对象复制到To空间，复制完成后交换From和To空间，GC结束，分配时去心的From空间查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">copying()&#123;</span><br><span class="line">    <span class="comment">#$to_start To空间的起始地址</span></span><br><span class="line">    <span class="comment">#$free 要copy到的起始地址</span></span><br><span class="line">    $free = $to_start</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = copy(*r)</span><br><span class="line">    <span class="comment">#交换From 和 To 空间</span></span><br><span class="line">    swap($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行From 到 To 的 copy</span></span><br><span class="line">copy(obj)&#123;</span><br><span class="line">    <span class="comment"># 如果obj.tag != COPIED, 此对象还没有被执行过COPY, 对其执行COPY</span></span><br><span class="line">    <span class="keyword">if</span>(obj.tag != COPIED)</span><br><span class="line">        copy_data($free, obj, obj.size)</span><br><span class="line">        <span class="comment">#执行完后改变tag值，下次不再对其执行COPY</span></span><br><span class="line">        obj.tag = COPIED</span><br><span class="line">        <span class="comment">#forwarding是原来对象指向复制后的对象的指针，便于新老节点对应起来，下面递归查询的时候好查找</span></span><br><span class="line">        obj.forwarding = $free</span><br><span class="line">        <span class="comment">#free是要复制到的起始地址，当复制完一个对象后，需要前进size, 到达新的地址(To空间空闲的起始地址)</span></span><br><span class="line">        $free += obj.size</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#对执行过的对象执行深度遍历，全部活动子节点都COPY到TO空间</span></span><br><span class="line">        <span class="keyword">for</span>(child : children(obj.forwarding))</span><br><span class="line">            *child = copy(*child)</span><br><span class="line">    <span class="comment">#注意，当对根节点的元素执行时，返回的是根节点执行的obj.forwarding, </span></span><br><span class="line">    <span class="comment">#所以全部执行完后，根节点结合就是原来的根节点集合的forwarding指针指向的元素</span></span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">new_obj()&#123;</span><br><span class="line">    <span class="comment">#这里FROM和TO等分，如果空间不够，执行GC</span></span><br><span class="line">    <span class="keyword">if</span>($free + size &gt; $from_start + HEAP_SIZE/<span class="number">2</span>)</span><br><span class="line">        copying()</span><br><span class="line">        <span class="comment">#执行完GC后空间还不够，返回失败</span></span><br><span class="line">        <span class="keyword">if</span>($free + size &gt; $from_start + HEAM_SIZE/<span class="number">2</span>)</span><br><span class="line">            allocation_fail()</span><br><span class="line"></span><br><span class="line">    obj = $free</span><br><span class="line">    obj.size = size</span><br><span class="line">    $free += size</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GC复制算法过程参考下面的图:<br><img src="/assets/img/gc/copy_1.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_2.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_3.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_4.png" alt="GC复制算法"></p><ul><li>优点:</li></ul><ol><li>优秀的吞吐量: 只需要搜索活动对象，不需要其他的搜索。</li><li>可实现高速分配: 不需要空闲链表，只移动$free指针，快速分配。</li><li>不会发生碎片化: 因为分配的都是连续的，GC之后也是连续的，对象都放在了堆的一端(叫做压缩)。</li><li>与缓存兼容: 深度优先遍历，关联的节点都被放到了相邻的位置。</li></ol><ul><li>缺点:</li></ul><ol><li>堆使用效率低下: GC复制算法通常把堆分为二等分，只有一半可以来安排对象。</li><li>不兼容保守式GC算法: 会发生对象的移动。</li><li>递归调动函数: 递归复制，每次调用都会消耗栈，会有栈溢出的可能。</li></ol><h3 id="Cheney的GC复制算法"><a href="#Cheney的GC复制算法" class="headerlink" title="Cheney的GC复制算法"></a>Cheney的GC复制算法</h3><p>上面提到GC复制算法用递归复制，会有栈溢出的可能。Cheney的GC复制算法则采用广度优先的方式，用循环代替递归，解决栈溢出的问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">copying()&#123;</span><br><span class="line">    scan = $free = $to_start</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = copy(r)</span><br><span class="line">    <span class="comment">#广度优先遍历需要一个队列保，scan 到 $free 就是这个隐藏的队列</span></span><br><span class="line">    <span class="keyword">while</span>(scan != $free)</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            *child = copy(*child)</span><br><span class="line">        scan += scan.size</span><br><span class="line">        </span><br><span class="line">    swap($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy()&#123;</span><br><span class="line">    <span class="comment">#如果obj.forwarding是指向To空间指针则返回TRUE, 如果不是则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span>(is_pointer_to_heap(obj.forwarding, $to_start) == FALSE)</span><br><span class="line">        copy_data($free, obj, obj.size)</span><br><span class="line">        obj.forwarding = $free</span><br><span class="line">        $free += obj.size</span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/gc/gc_copy_cheney_1.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_2.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_3.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_4.png" alt="Cheney复制算法"></p><p>这个算法的缺点是不能利用局部缓存，因为有关系的节点不是相邻的。</p><h3 id="近似深度优先搜索方法"><a href="#近似深度优先搜索方法" class="headerlink" title="近似深度优先搜索方法"></a>近似深度优先搜索方法</h3><p>为了解决Cheney算法不能利用局部缓存，这里进行了一个改进，对于每个“页面”内部都是广度优先搜索。下面通过一个例子，看一下Cheney与近似深度优先搜索的方法对比:<br>图1，原始的引用关系:<br><img src="/assets/img/gc/gc_cp_df_1.png" alt="近似深度优先搜索方法"><br>图2，假设每三个节点占用一个”页面”的空间，下面就是Cheney方法，广度优先遍历后的ji结果:<br><img src="/assets/img/gc/gc_cp_df_2.png" alt="近似深度优先搜索方法"><br>可以看出，上图中相互引用的节点之间存储的比较分散，不容里利用局部缓存。<br>图3是利用近似深度优先搜索方法后的结果，可以看出分布比较集中，可以很好利用局部缓存。<br><img src="/assets/img/gc/gc_cp_df_3.png" alt="近似深度优先搜索方法"></p><h3 id="多空间复制算法"><a href="#多空间复制算法" class="headerlink" title="多空间复制算法"></a>多空间复制算法</h3><p>上面降到复制算法的一个明显的特征就是堆的利用率低。为了改善这个问题，多空间复制的算法的思想就是把一个堆N等分，只对其中2块空间执行GC复制算法，对剩下的(N-2)块空间执行GC标记-清除算法，也就是把这两种算法组合起来使用。具体细节不再展开。这个方法的优点是可以更有效的利用堆，但是缺点也很明显，就是标记-清除算法的缺点:分配耗费时间，分块碎片化等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本算法是进行GC的基本思想，每个算法都有其缺点和优点，没有算法能够完美解决所有问题。所以后面的算法利用这几种基本算法的组合和变形，更好的提高GC的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章介绍GC的基本算法:GC标记-清除法，引用计数法, GC复制算法。这三种我认为是GC的三个方向的基本思维。其他方法都是围绕这个些基本方法展开的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;GC标记-清除法&quot;&gt;&lt;a href=&quot;#GC标
      
    
    </summary>
    
    
      <category term="gc" scheme="http://oohcode.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收算法总结</title>
    <link href="http://oohcode.com/2017/01/22/gc/"/>
    <id>http://oohcode.com/2017/01/22/gc/</id>
    <published>2017-01-22T06:56:28.000Z</published>
    <updated>2019-03-04T04:37:02.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近研读了《垃圾回收的算法与实现》这本书， 对来垃圾回收(<code>GC</code>)的来龙去脉及理论和实践有了一个概括性，深入性的了解，这里分多篇进行总结。首先本文先对GC的理论来一个总览性的回顾.</p></blockquote><h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>我们知道一台服务器的内存是有限的，而程序的运行需要占用内存空间，一个程序内部可能有些内存空间使用后不再使用，这部分不再使用的内从空间就被视为<code>垃圾</code>。而GC就是要</p><ol><li>找到内存空间里的垃圾</li><li>回收垃圾，让程序员能够再次利用这部分空间</li></ol><p>如果没有GC的情况下需要程序员自己手动管理内存，例如C/C++等程序。这个过程将会非常麻烦，如果管理不当就会照成内存泄露引起系统崩溃，引发各种恶性bug和安全问题。有了GC就会省去很大一部分精力，降低了开发的难度。</p><h2 id="垃圾回收基本概念"><a href="#垃圾回收基本概念" class="headerlink" title="垃圾回收基本概念"></a>垃圾回收基本概念</h2><p>要深入了解垃圾回收的理论知识，下面这些关键件信息比必要掌握:</p><ul><li>对象/头/域: 这里对象是由头(heder)和域(field)构成的。头是指保持对象本身信息的部分，主要包括<strong>对象的大小</strong>和<strong>对象的种类</strong>;域是对象使用者可以访问的部分，域的数据类型主要分为指针和非指针两种。</li><li>指针: GC根据对象的指针指向去搜寻其他对象，对于非指针不进行任何操作。</li><li>mutator: 程序运行过程中关系的改变，主要包括<strong>生成对象</strong>和<strong>更新指针</strong>等操作。</li><li>堆: 用于动态存放对象的内存空间。当mutator申请存放对象时，所需的内从空间就是从这个堆中被分配给mutator的。</li><li>活动对象/非活动对象: 内存空间中可以通过mutator引用的对象是”活动对象”, 不能通过程序引用的称为”非活动对象”。非活动对象无法重新被引用，所以就是”垃圾”。</li><li>分配: 内存空间中分配(allocatio)对象。当mutator需要新对象时，就会向分配器(allocator)申请一个大小合适的空间。</li><li>分块: 未利用对象而事先准备的空间。初始状态堆就是一个大分块，根据mutator的需求而分割成合适的大小。</li><li>根: 跟是指向对象的指针的起点，通过mutator可以直接调用的调用栈(call stack),寄存器和全局变量都是根。但是调用栈和寄存器中的值是不是指针，需要再做判断。</li><li>评价标准: GC算法的性能评价标准主要有<ol><li>吞吐量: 单位时间内的处理能力。</li><li>最大暂停时间: 因执行GC和停止mutator的最长时间。</li><li>堆使用效率</li><li>访问的局部性: 局部性原理，数据离得越近越好处理。</li></ol></li></ul><h2 id="垃圾回收算法总览"><a href="#垃圾回收算法总览" class="headerlink" title="垃圾回收算法总览"></a>垃圾回收算法总览</h2><p>首先先上一张垃圾回收算法的总概括图:<br><img src="/assets/img/gc/GC.png" alt="垃圾回收算法总览"><br>上面列举和好多算法及对应的细节。其实GC最基本的思想就是三种算法(GC标记-清除法, 引用计数法, GC复制算法), 其他算法都算是这几个算法的延伸和组合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近研读了《垃圾回收的算法与实现》这本书， 对来垃圾回收(&lt;code&gt;GC&lt;/code&gt;)的来龙去脉及理论和实践有了一个概括性，深入性的了解，这里分多篇进行总结。首先本文先对GC的理论来一个总览性的回顾.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="gc" scheme="http://oohcode.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>phpenv安装自定义配置</title>
    <link href="http://oohcode.com/2016/08/23/phpenv-configuration-options/"/>
    <id>http://oohcode.com/2016/08/23/phpenv-configuration-options/</id>
    <published>2016-08-23T08:45:47.000Z</published>
    <updated>2019-03-04T04:37:02.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>在使用phpenv安装php是，有时候需要对内置扩展进行自定义控制是否开启，比如我要开启<code>zts</code>模块, 源码安装我么可以用<code>./configure --enable-maintainer-zts</code>来安装，但是phpenv不支持直接这么写，这时候就要phpenv自己的方式来安装了。可以在phpenv安装的路径里找到下面这个文件：<code>~/.phpenv/plugins/php-build/bin/php-build</code>, 这个文件就是phpenv install时运行的脚本，可以找到如下内容:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">CONFIGURE_OPTIONS=$(cat <span class="string">"$PHP_BUILD_ROOT/share/php-build/default_configure_options"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"$PHP_BUILD_CONFIGURE_OPTS"</span> ]; then</span><br><span class="line">    CONFIGURE_OPTIONS=<span class="string">"$CONFIGURE_OPTIONS $PHP_BUILD_CONFIGURE_OPTS"</span></span><br><span class="line">fi</span><br><span class="line">...</span><br><span class="line">local append_default_libdir=<span class="string">'yes'</span></span><br><span class="line"><span class="keyword">for</span> option in $CONFIGURE_OPTIONS; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"$option"</span> in</span><br><span class="line">    <span class="string">"--with-libdir"</span>*) append_default_libdir=<span class="string">'no'</span> ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$(uname -p)"</span> = <span class="string">"x86_64"</span> ] &amp;&amp; [ <span class="string">"$&#123;append_default_libdir&#125;"</span> = <span class="string">'yes'</span> ]; then</span><br><span class="line">    argv=<span class="string">"$argv --with-libdir=lib64"</span></span><br><span class="line">fi</span><br><span class="line">...</span><br><span class="line">./configure $argv &gt; /dev/<span class="keyword">null</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>可见，默认会读取<code>~/.phpenv/plugins/php-build/share/php-build/default_configure_options</code>里面的配置加到<code>./configure</code>的参数里，当存在变量<code>$PHP_BUILD_CONFIGURE_OPTS</code>时，会把这个变量的值也加到<code>./configure</code>的参数里。<br>所以就存在两种方式实现上面的安装方法：</p><ol><li><code>~/.phpenv/plugins/php-build/share/php-build/default_configure_options</code>文件末尾加上<code>--enable-maintainer-zts</code></li><li>运行<code>PHP_BUILD_CONFIGURE_OPTS=--enable-maintainer-zts phpenv install 5.6.2</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自定义配置&quot;&gt;&lt;a href=&quot;#自定义配置&quot; class=&quot;headerlink&quot; title=&quot;自定义配置&quot;&gt;&lt;/a&gt;自定义配置&lt;/h2&gt;&lt;p&gt;在使用phpenv安装php是，有时候需要对内置扩展进行自定义控制是否开启，比如我要开启&lt;code&gt;zts&lt;/cod
      
    
    </summary>
    
    
      <category term="php" scheme="http://oohcode.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB关键特性</title>
    <link href="http://oohcode.com/2015/10/14/InnoDB-Key-Features/"/>
    <id>http://oohcode.com/2015/10/14/InnoDB-Key-Features/</id>
    <published>2015-10-14T14:10:14.000Z</published>
    <updated>2019-03-04T04:37:02.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇博客是《Mysql技术内幕 InnoDB存储引擎(第二版)》的阅读总结.</p></blockquote><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><p>首先Mysql进程模型是单进程多线程的。所以我们通过ps查找mysqld进程是只有一个。</p><h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><p>InnoDB存储引擎的架构如下图所以，是由多个内存块组成的内存池，同时又多个后台线程进行工作，文件是存储磁盘上的数据。</p><img src="http://www.plantuml.com/plantuml/svg/Kr3WAafDBadCIyz9LNWshVt9xcqArLmAG92IM9AOb5YSgg044JPKWeZNOfKrmYkR1vUjHRBkQLlhqxKpeDOXX9MUJkXxsh_X-QxzprTqAq6bDNmJYqjIYnH2CefI4rCq8MAU_gZyWjAYz5HKeO14e8XpJcfY7fhcMdHRFVFoybsSW0vwshJYwPwfpoRtGTptREC29Q2peM5Zesi7TJS0">  <h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>上面看到一共有四种后台线程，每种线程都在不停地做自己的工作，他们的分工如下:</p><ul><li><code>Master Thread</code>: 是最核心的线程，主要负责将缓冲池中的数据异步刷新的磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲(INSERT BUFFER),UNDO页的回收等。下面几个线程其实是为了分担主线程的压力而在最新的版本中添加的。</li><li><code>IO Thread</code>: InnoDB使用大量的异步IO来处理请求。IO Thread的主要工作就是负责IO请求的回调(call back)处理。异步IO可以分为4个，分别是:write, read, insert buffer 和 log IO thread。</li><li><code>Purge Thread</code>: undo log是用来保证事务的，当一个事务正常提交后，这个undo log可能就不再使用了。purge thread就是用来清除这部分log已经分配的undo页的。 </li><li><code>Page Cleaner Thread</code>: 主要是把脏页的刷新从主线程中拿到单独的线程，减轻主线程的压力，减少用户查询线程的阻塞，提高整体性能。</li></ul><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>由于InnoDB是基于磁盘存储的，为了使CPU与磁盘能够快的交互，提升整体性能而采用了缓冲池技术。<br>读数据简单的说可以用下面的流程图<br><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXidgnVlUpgHkUzQwpvifCKz20i9_EMV5yp-IdRPkURLoWgL2IaPgde56PMgp9fG04LY_sJtawUnvCLsfESQg2Hbu-LFB9xhxdYnkVpvu1DFXf_pIOAh2SafjdXDBJZWrmiwsn6fYNafd6LLoINm00"><br>更新数据的流程则如下:<br><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXidgnVlVJzbtFfcvurhlEcYilloHLeIWpFQF4Ik75_fdFfczxsZ0J8lbaHyFJTREUpbdnVC_afssRdcrSy6J7sYUxshYiditUycpQ1cJXvxDQO2PQFTkzyCMspS_cBdooUzlxFJrFExO35J-TFU_vuiRdisTOSnMNv1S00000"><br>由缓冲池的作用可以看到，缓冲池越大所容纳的数据就越多，与磁盘的交互就会越少，性能也就越高。所以缓冲池的大小直接影响着数据库的整体性能。<br>InnoDB在内存中主要有以下几部分组成:<br><img src="http://www.plantuml.com/plantuml/svg/TP31IiD048RlVOeX9tqDyU8x2CkskmcBszsoZI1AmGXfFLW4sneH15FiHQYrKg5AeI_ZnEOjZDbMH9CvVz_yCx_XDPygJtBOKqhlxc0xnF5DCdXEkayuULjDOpYfG3Rc1tJIJXU3soGQuJBwNFIm_GBx2hOCPngazaZrq7MvsNRWdpYymuVhTSJqFhT45ikgX38cVA4LbQJEwwIXjIHDSSmBjjZ8pD-uDYztCjoU-pr_HVjL6h_cmOpw51hKAuoO3N4ns912CNvKXYQNLnYEVjKWL9CR7yfBw0SVopW99ZajTUq0X79r0RdgFAQdP_ZUnzuvpY_iKKx9MpYEC9pRpMkcLMbz0G00"><br>具体来看缓冲池中缓存的数据页类型有:</p><ul><li><code>索引页</code>: 缓存数据表索引</li><li><code>数据页</code>: 缓存数据页，占缓冲池的绝大部分</li><li><code>undo页</code>: undo页是保存事务，为回滚做准备的。</li><li><code>插入缓冲(Insert buffer)</code>: 上面提到的插入数据时要先插入到缓存池中。</li><li><code>自适应哈希索引(adaptive hash index)</code>: 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。</li><li><code>InnoDB存储的锁信息(lock info)</code>: </li><li><code>数据字典(data dictionary)</code>:<br>内存中除了缓冲池外外还有:</li><li><code>重做日志缓冲redo log</code>: 为了避免数据丢失的问题，当前数据库系统普遍采用了write ahead log策略，既当事务提交时先写重做日志，再修改写页。当由于发生宕机而导致数据丢失时，可以通过重做日志进行恢复。InnoDB先将重做日志放到这个缓冲区，然后按照一定的频率更新到重做日志文件中。重做日志一般在下列情况下会刷新内容到文件:<ul><li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件</li><li>每个事务提交时会将重做日志缓冲刷新到重做日志文件</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li></ul></li><li><code>额外内存池</code>: InnoDB存储引擎中，对内存的管理师通过一种称为内存堆的方式进行的，在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</li></ul><p>缓冲池是一个很大的内存区域，InnoDB是如何对这些内存进行管理的呢。答案就使用LRU list。<br><a href="https://en.wikipedia.org/wiki/Page_replacement_algorithm#Variants_on_LRU" target="_blank" rel="noopener">LRU</a>(Latest Recent Used, 最近最少使用)算法默认的是最近使用的放到表头，最早使用的放到表尾，依次排列。当有LRU填满时有新的进来就把最早的淘汰掉。InnoDB则是在这个基础上进行了修改:</p><ol><li>最近使用的不放到表头，而是根据配置放到一定比例处，这个地方叫做midpoint, midpoint之前的成为new列表，之后的成为old列表。淘汰的同样是表尾的页。</li><li>为了保证new列表的不经常使用时能够淘汰，设置了一个超时时间:innodb_old_blocks_time，当数据在midpoint(我理解应该是在old列表中，不然这个点的页就一个，变化也比较频繁)的时间超过找个时间时就会被提升到表头，new列表的表尾页则被置换到old列表中。</li></ol><p>这么做的原因主要是因为常见的索引或数据的扫描操作会连续读取大量的页，甚至是全表扫描。如果采用原来的LRU算法就会更新全部的缓冲池，其他查询需要的热点数据就会被冲走，导致更多的磁盘读取操作，降低数据库的性能。<br>LRU是用来管理已经读取的页，当数据库启动时LRU是空列表,既只有表头，没有内容。这时页都放在Free List中。当需要有数据读写时要进行需要获取分页，这时要从Free List中删除分页，然后添加到LRU list中。到一定时间Free List中的分页就会被分配完毕，这时候就正常使用上面的LRU策略。<br>LRU列表中的页被修改后，称该页为脏页(dirty page),既缓冲池中的数据和磁盘上的数据产生了不一致，这时脏页会被加入到一个Flush 列表中(注意，同时存在两个列表中)。然后根据刷新的机制定时的刷新到磁盘中。</p><h3 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h3><p>checkpoint其实就是一个刷新缓冲到磁盘的触发机制，当满足一定的条件时就会刷新缓冲到磁盘，这样做可以解决以下几个问题:</p><ul><li>缩短数据库的恢复时间: 数据库恢复可以使用redo log，但是如果要恢复的数据很多就会很慢。如果使用checkpoint刷新到磁盘，只需要从checkpoint开始恢复就可以了，所以速度会变快。</li><li>缓冲池不够用时，将脏页刷新到磁盘。我们知道缓冲池的大小是由限制的，为了能够高效的使用缓冲池需要把一部分数据刷新到磁盘。</li><li>重做日志不可用时，刷新脏页。重做日志并不是无限增大的，而是循环利用的。当有些已经不需要的页存在时可以覆盖写，当可用的页放不下时就会触发checkpoint,刷新到磁盘一部分脏页到磁盘，这样就能覆盖掉一些不再使用的重做日志。</li></ul><p>checkpoint根据触发时间，刷新页的策略又可以分为:</p><ul><li><code>sharp checkpoint</code>:刷新所有的脏页到磁盘。一般发生在数据库关闭时，为了保证所有的数据能够正常持久化。</li><li><code>fuzzy checkpoint</code>:只刷新部分脏页。运行时使用这种可以保证系统的性能。<h3 id="Master-Thread的工作方式"><a href="#Master-Thread的工作方式" class="headerlink" title="Master Thread的工作方式"></a>Master Thread的工作方式</h3></li></ul><h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h2><h3 id="插入缓存"><a href="#插入缓存" class="headerlink" title="插入缓存"></a>插入缓存</h3><p>这里所说的插入缓存也是Insert Buffer, 区别是这个插入缓存不是缓冲池中的插入缓存,这里的插入缓存和数据页一样，业务物理页的组成部分。在介绍插入缓存之前先了解<a href="http://www.cnblogs.com/lwzz/archive/2012/08/05/2620824.html" target="_blank" rel="noopener">聚集索引和非聚集索引</a>，他们之间最重要的区别就是:聚集索引的叶子节点存储的是数据，而且是按照物理顺序存储的;非聚集索引叶子节点是地址(也就是聚集索引键地址)，是按照逻辑顺序存储的(以上言论是从网上了解到的，但是本书P194特别指出，聚集索引也不是按照物理地址连续的，而是逻辑上连续的)。<br>知道这个差别后就知道，当不停的插入数据时，如果是聚集索引的数据，按照物理顺序(这个应该是一般情况下，因为是一般聚集索引是主键，顺序递增的，所以这时候地址就是顺序的)连续插入，代价比较小。而如果是非聚集索引的插入则物理地址是离散的，会导致很大的系统开销，所以对于非聚集索引InnoDB开创性设计了Insert Buffer。使用InnoDB的Insert Buffer需要以下两个条件:</p><ul><li>索引是辅助索引(非聚集索引 secondary index);</li><li>索引不是唯一(unique)的。</li></ul><p>Insert Buffer的使用流程是:<br><img src="http://www.plantuml.com/plantuml/svg/LKvB2e906DxFAMPfLz1TkuuHD98G5iwqQ5U14j6Bx06zo22em5wOA5YdyH_r5WtOfc_vlIah6mp9V3m5yyXx2xxs-EAk84t5KhRTfPrLjhOIxm3HF7DUi3abaGtMap_sSU0MCAiI7KijGWi82yY9Y8-EUPk2I8qIBEdrdyXd7q77GJiEBYMT4eFXObDLYG6tC7queb39ZN1TyQN_RvaEqey9_NF-1SO-k9Eqtqsw8Knw4FhS7iRlZTZKAvgAAAitlW00"><br>要求索引不是唯一的是因为如果索引是唯一的，那么每次更新都要坚持是不是已经存在，每次还是要访问数据页，这就失去了使用Insert Buffer的优势。<br>后面还提到了Update buffer以及Merge的过程和Insert Buffer的实现，这里就不再一一说了。</p><h3 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h3><p>上面提到的Insert Buffer是提高了数据库的性能，doublewrite则是提高了数据库的可靠性。一个场景是当一个16k的数据页只写了一部分,比如4k,这时候突然断电，就会导致这个页的数据不全。所以就会导致这个页的数据丢失。我们知道重做日志是用来恢复数据的，但是重做日志记录的是对页的物理操作，如果这个页已经发生了损坏在对其进行重做是没有意义的。</p><blockquote><p>上面这段话，其实我并没有看懂，因为对页操作之前是先写重做日志的，当发生宕机时正在写数据页，证明这时候重做日志已经写完了。这时重做日志的记录的完整的，当用这个记录去恢复数据时，不管页是不是损坏，重做日志直接覆盖不就行了么？为什么不行呢？等到后面我更加深入的了解后再来补充。</p></blockquote><p>doublewrite有两部分组成，一部分是内存中的doublewrite buffer, 大小为2MB,另一部分是物理磁盘上共享表空间中连续的128个页，既两个区，大小同样为2MB<br>。对缓冲池的脏页进行刷新时，比不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer, 之后通过doublewrite buffer再分两次，每次1MB的写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中。</p><p>如果磁盘写入时发生崩溃，可以从共享表空间的doublewrite中找到副本，将其复制到表空间文件，再应用重做日志。</p><blockquote><p>这个地方也有一个疑问，当doublewrite写入的过程中发生了崩溃，这时候数据该怎么办呢？</p></blockquote><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>对于缓冲池中的页，为了能够快速的查找，InnoDB跟情况对其建立了一个hash index。这样对于等值查询就能够利用这个索引更加快速的查找，提高了查找的性能。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。<br>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS的性能。</p><h3 id="刷新临近页"><a href="#刷新临近页" class="headerlink" title="刷新临近页"></a>刷新临近页</h3><p>Flush Neighbor Page(刷新临近页)是当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇博客是《Mysql技术内幕 InnoDB存储引擎(第二版)》的阅读总结.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;工作方式&quot;&gt;&lt;a href=&quot;#工作方式&quot; class=&quot;headerlink&quot; title=&quot;工作方式&quot;&gt;&lt;/a&gt;工
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://oohcode.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>apache与nginx对比</title>
    <link href="http://oohcode.com/2015/10/09/apache-and-nginx/"/>
    <id>http://oohcode.com/2015/10/09/apache-and-nginx/</id>
    <published>2015-10-09T07:09:38.000Z</published>
    <updated>2019-03-04T04:37:02.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="apache工作原理"><a href="#apache工作原理" class="headerlink" title="apache工作原理"></a>apache工作原理</h2><p>apache httpd通过模块化的设计来适应各种环境，模块化的使用使其变得功能强大而且灵活。最基本的web服务器功能也是通过可选择的多处理模块(MPM)，用来绑定到网络端口上，以及调度子程序处理请求。这样做可以带来两个重要的好处:</p><ul><li>Apache httpd 能更优雅，更高效率的支持不同的平台。尤其是 Apache httpd 的 Windows 版本现在更有效率了，因为 <a href="http://httpd.apache.org/docs/2.4/zh-cn/mod/mpm_winnt.html" target="_blank" rel="noopener">mpm_winnt</a> 能使用原生网络特性取代在 Apache httpd 1.3 中使用的 POSIX 层。它也可以扩展到其它平台 来使用专用的 MPM。</li><li>Apache httpd 能更好的为有特殊要求的站点定制。例如，要求 更高伸缩性的站点可以选择使用线程的 MPM，即 <a href="http://httpd.apache.org/docs/2.4/zh-cn/mod/worker.html" target="_blank" rel="noopener">worker</a> 或 <a href="http://httpd.apache.org/docs/2.4/zh-cn/mod/event.html" target="_blank" rel="noopener">event</a>； 需要可靠性或者与旧软件兼容的站点可以使用 <a href="http://httpd.apache.org/docs/2.4/zh-cn/mod/prefork.html" target="_blank" rel="noopener">prefork</a>。</li></ul><p>下面主要介绍常用的两个MPM工作原理。</p><h3 id="perfork"><a href="#perfork" class="headerlink" title="perfork"></a>perfork</h3><p>一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口(注意这里是先绑定再fork的，所以意味着所有的子进程都监听了80端口)，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。运行子进程的用户必须要对他所服务的内容有读取的权限，但是对服务内容之外的其他资源必须拥有尽可能少的权限。<br>子进程的个数会随着请求量的大小动态调整。调整的策略与perfork的配置息息相关，httpd.conf的配置文件有以下配置:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule prefork.c&gt;</span><br><span class="line">StartServers 5</span><br><span class="line">MinSpareServers 5</span><br><span class="line">MaxSpareServers 10</span><br><span class="line">MaxClients 150</span><br><span class="line">MaxRequestsPerChild 0</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></p><p>具体的流程这里直接copy<a href="http://blog.csdn.net/hguisu/article/details/7395181" target="_blank" rel="noopener">Apache运行机制剖析</a>这篇博文的介绍。</p><ol><li>控制进程先建立’StartServers’个子进程;</li><li>当空闲进程数小于MinSpareServers时，继续创建子进程，直到满足空闲进程数大于等于MinSpareServers;</li><li>当并发请求高时而空闲进程数小于MinSpareServers时会继续创建子进程，最多可以创建MaxClients个;</li><li>当并发高峰过去时，空闲进程的数量大于MaxSpareServers时会删除多余的子进程，直到剩MaxSpareServers为止;</li><li>当子进程处理的连接数超过MaxRequestsPerChild时，自动关闭，当MaxRequestsPerChild为0时这没有这个限制;</li></ol><p>对每个参数的介绍如下:</p><ul><li><code>StartServers</code> 指定服务器启动时建立的子进程数量。</li><li><code>MinSpareServers</code> 最小的空闲进程数。如果当前空闲进程数少于MinSpareServers时，Apache将以每秒一个的速度产生新的子进程。</li><li><code>MaxSpareServers</code> 最大的空闲进程数。如果空闲进程数大于这个值，Apache父进程会自动kill掉一些多余的子进程。</li><li><code>MaxRequestsPerChild</code> 每个子进程可处理的请求数。每个子进程处理完<code>MaxRequestsPerChild</code>后将自动销毁。0意味着用户销毁。销毁的好处有以下两个:<ul><li>可以防止意外的内存泄露</li><li>在服务器负载下降的时候会自动减少子进程数</li></ul></li><li><code>MaxClients</code> 设定Apache可以同时处理的请求，是对性能影响最大的参数。如果请求数达到这个限制，那么后来的请求就需要排队，直到某个请求处理完毕。</li></ul><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。虽然子进程必须对其提供的内容拥有读权限，但应该尽可能给予他较少的特权。另外，除非使用了suexec ，否则，这些指令配置的权限将被CGI脚本所继承。<br>  相对于prefork，worker是2.0 版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理，所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器。但是，worker也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性。这种MPM的工作方式将是Apache 2.0的发展趋势。</p><p>http.conf中也有关于worker的配置项:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule worker.c&gt;</span><br><span class="line">StartServers 3</span><br><span class="line">MaxClients 2000</span><br><span class="line">ServerLimit 25</span><br><span class="line">MinSpareThreads 50</span><br><span class="line">MaxSpareThreads 200</span><br><span class="line">ThreadLimit 200</span><br><span class="line">ThreadsPerChild 100</span><br><span class="line">MaxRequestsPerChild 0</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></p><p>由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数。如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。<br>参数介绍:<br><code>StartServer</code> 服务器启动时建立的子进程数。<br><code>ServerLimit</code> 服务器允许配置的进程数上限。这个指令和ThreadLimit结合使用配置了MaxClients最大允许配置的数值。<br><code>MinSpareThreads</code> 最小空闲线程数。这个MPM将基于整个服务器监控空闲线程数。如果服务器中的总线程数太少，子进程将产生新的空闲线程。<br><code>MaxSpareThreads</code> 最大空闲线程数。这个MPM将基于整个服务器监控空闲线程数。如果服务器总的线程数太多，子进程将kill掉多余的空闲线程。MaxSpareThreads的取值范围是有限制的。<br><code>ThreadLimit</code> 每个子进程可配置的线程数上限。这个指令配置了每个子进程可配置的线程数ThreadsPerChild上限。<br><code>ThreadsPerChild</code> 每个子进程建立的常驻的执行线程数。子进程在启动时建立这些线程后就不再建立新的线程了。<br><code>MaxRequestsPerChild</code> 每个子进程在其生存期间允许执行的最大请求数量。到达这个限制后子进程将会结束，如果为0则永不结束( 注意，对于KeepAlive链接，只有第一个请求会被计数)。这样做的好处是:</p><ul><li>能够防止内存泄露无限进行，从而耗尽内存。</li><li>給进程一个有限寿命，从而有助于当服务器负载减轻时减少活动进程的数量。</li></ul><h3 id="apache”惊群”现象与解决方案"><a href="#apache”惊群”现象与解决方案" class="headerlink" title="apache”惊群”现象与解决方案"></a>apache”惊群”现象与解决方案</h3><p>无论是上面那个MPM被选择，都有一问题就是主进程先监听80端口，然后又fork出子进程。所以可以知道，fork出来的每个子进程都在监听80端口，如果这时候有请求过来就会出现所有的空闲进程都回来抢这个fd,也就是这些进程都被唤醒了，但是最终只有一个进程能够拿到这个fd进行处理，其他进程因为拿不到进程而再次进入休眠状态，这就是”惊群”现象。<br>apache的prefork模型下的处理方式如下如所示:<br><img src="http://dl.iteye.com/upload/attachment/385428/e0714d6e-1c19-3f2b-9f0a-0592eee7c3ec.png" alt><br>apache通过在每个accept()函数上 增加互斥锁和条件变量 来解决这个惊群问题。保证每个请求只会被一个线程刚好拿到，不会影响其他线程；<br>这里详细介绍下：条件变量与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用；互斥锁提供互斥机制，条件变量提供信号机制；<br>那么apache是如何利用条件变量和互斥锁来解决每次只有一个空闲线程被唤醒，并且处于监听者角色呢？<br>每次一个新的客户请求过来，正在监听的线程与该请求建立连接，并变为worker工作者线程。让出监听者角色时它同时发送信号到条件变量，并释放锁。这样在空闲（idle)状态的一个线程将被唤醒并获得锁。<br>也就是说：条件变量保证了其他线程在等待条件变化期间处于睡眠；互斥锁保证一次只有一个线程被唤醒<br>这个是参考<a href="http://alicsd.iteye.com/blog/865531" target="_blank" rel="noopener">客户/服务器程序设计范式</a>来的，但是有一个明显的问题是prefork是多进程模型不是多线程模型，由于现在还没读过apache源码，姑且认为总体的流程和思想是对的。有机会再深入阅读回来补充。</p><h2 id="nginx工作原理"><a href="#nginx工作原理" class="headerlink" title="nginx工作原理"></a>nginx工作原理</h2><p>nginx使用的是多进程模型，类似于apache的prefork，不同的是nginx的子进程个数是固定的。nginx的进程模型可以用下图来表示:<br><img src="http://tengine.taobao.org/book/_images/chapter-2-1.PNG" alt><br>可以看到nginx进程模型是由一个mater进程和多个worker进程组成的，master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。 worker进程则是来处理请求用的。</p><h3 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h3><p>上面提到nginx的worker进程用来处理请求，而worker的个数是有限的，当并发高的时候nginx是如何应对的呢？这里不得不提到一个概念<code>异步非阻塞</code>(参考UNP卷一第三版P160页的介绍)关于这个过程<a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="noopener">nginx平台初探</a>介绍的很好，直接COPY过来:</p><blockquote><p>为什么nginx可以采用异步非阻塞的方式来处理呢，或者异步非阻塞到底是怎么回事呢？我们先回到原点，看看一个请求的完整过程。首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧。阻塞调用会进入内核等待，cpu就会让出去给别人用了，对单线程的worker来说，显然不合适，当网络事件越多时，大家都在等待呢，cpu空闲下来没人用，cpu利用率自然上不去了，更别谈高并发了。好吧，你说加进程数，这跟apache的线程模型有什么区别，注意，别增加无谓的上下文切换。所以，在nginx里面，最忌讳阻塞的系统调用了。不要阻塞，那就非阻塞喽。非阻塞就是，事件没有准备好，马上返回EAGAIN，告诉你，事件还没准备好呢，你慌什么，过会再来吧。好吧，你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。所以，才会有了异步非阻塞的事件处理机制，具体到系统调用就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制正好解决了我们上面的两个问题，拿epoll为例(在后面的例子中，我们多以epoll为例子，以代表这一类函数)，当事件没准备好时，放到epoll里面，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里面。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。 我之前有对连接数进行过测试，在24G内存的机器上，处理的并发请求数达到过200万。现在的网络服务器基本都采用这种方式，这也是nginx性能高效的主要原因。</p></blockquote><p>所以推荐设置worker的个数为cpu的核数，在这里就很容易理解了，更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。</p><h3 id="nginx”惊群”现象与解决方案"><a href="#nginx”惊群”现象与解决方案" class="headerlink" title="nginx”惊群”现象与解决方案"></a>nginx”惊群”现象与解决方案</h3><p>worker进程之间是平等的，每个进程，处理请求的机会也是一样的。当我们提供80端口的http服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket（listenfd）之后，然后再fork出多个worker进程。所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。</p><p>因为这里主要是对比apache与nginx的原理的不同，所以更深入的探讨nginx这里先不做介绍更深入的探讨nginx这里先不做介绍，以后有机会学习nginx源码的时候再写。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://httpd.apache.org/docs/2.4/zh-cn/mpm.html" target="_blank" rel="noopener">多处理模块(MPM)</a><br><a href="http://blog.csdn.net/hguisu/article/details/7395181" target="_blank" rel="noopener">Apache运行机制剖析</a><br><a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="noopener">nginx平台初探</a><br><a href="http://alicsd.iteye.com/blog/865531" target="_blank" rel="noopener">客户/服务器程序设计范式</a><br><a href="http://blog.csdn.net/russell_tao/article/details/7204260" target="_blank" rel="noopener">“惊群”，看看nginx是怎么解决它的</a><br><a href="http://blog.csdn.net/zbszhangbosen/article/details/7982402" target="_blank" rel="noopener">web服务器nginx和apache的对比分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;apache工作原理&quot;&gt;&lt;a href=&quot;#apache工作原理&quot; class=&quot;headerlink&quot; title=&quot;apache工作原理&quot;&gt;&lt;/a&gt;apache工作原理&lt;/h2&gt;&lt;p&gt;apache httpd通过模块化的设计来适应各种环境，模块化的使用使其变得
      
    
    </summary>
    
    
      <category term="apache" scheme="http://oohcode.com/tags/apache/"/>
    
      <category term="nginx" scheme="http://oohcode.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>PHP数组的key溢出问题</title>
    <link href="http://oohcode.com/2015/09/15/PHP-array-hash-key-overflow/"/>
    <id>http://oohcode.com/2015/09/15/PHP-array-hash-key-overflow/</id>
    <published>2015-09-15T02:52:49.000Z</published>
    <updated>2019-03-04T04:37:02.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为PHP最重要的数据类型HashTable其key值是有一定的范围的，如果设置的key值过大就会出现溢出的问题，下面根据其内部结构及实现原理详细探讨一下key值溢出问题。</p></blockquote><p>下面先给出一个key溢出的例子:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">$arr[<span class="number">18446744073708551617333333333333</span>] = <span class="string">'18446744073708551617333333333333'</span>;</span><br><span class="line">$arr[] = <span class="string">'test'</span>;</span><br><span class="line">$arr[<span class="number">4294967296</span>] = <span class="string">'test'</span>;</span><br><span class="line">$arr[<span class="number">9223372036854775807</span>] = <span class="string">'test'</span>;</span><br><span class="line">$arr[<span class="number">9223372036854775808</span>] = <span class="string">'test'</span>;</span><br><span class="line">var_dump($arr);</span><br></pre></td></tr></table></figure></p><p>上面代码的输出结果如下:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">6</span>) &#123;</span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  string(<span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line">  [<span class="number">-999799117276250112</span>]=&gt;</span><br><span class="line">  string(<span class="number">32</span>) <span class="string">"18446744073708551617333333333333"</span></span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">  [<span class="number">4294967296</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">  [<span class="number">9223372036854775807</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">  [<span class="number">-9223372036854775808</span>]=&gt;</span><br><span class="line">  string(<span class="number">4</span>) <span class="string">"test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到当key值比较小是没有问题，当key值很大时输出的值溢出了，临界点是<code>9223372036854775807</code>这个数字。<br>下面分析一下原因 。首先我们先分析一下HashTable的结构(本文分析的是php-5.5.15版本的源码),可以通过源码看一下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file: Zend/zend_hash.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> &#123;</span></span><br><span class="line">    ulong h;                        <span class="comment">/* Used for numeric indexing */</span> <span class="comment">/*对char *key进行hash后的值，或者是用户指定的数字索引值，可能会溢出*/</span></span><br><span class="line">    uint nKeyLength; <span class="comment">/*hash关键字的长度，如果数组索引为数字，此值为0*/</span></span><br><span class="line">    <span class="keyword">void</span> *pData; <span class="comment">/*指向value,一般是用户数据的副本，如果是指针数据，则指向pDataPtr*/</span></span><br><span class="line">    <span class="keyword">void</span> *pDataPtr; <span class="comment">/*如果是指针数据，此值会指向真正的value,同时上面pData会指向此值*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListNext</span>;</span> <span class="comment">/*整个hash表的下一个元素*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListLast</span>;</span> <span class="comment">/*整个hash表该元素的上一个元素*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pNext</span>;</span> <span class="comment">/*存放在同一个hash Bucket的下一个元素*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pLast</span>;</span> <span class="comment">/*同一个hash bucket的上一个元素*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *arKey; <span class="comment">/*保存当前值所对于的key字符串,这个字段只能定义在最后,实现变长结构体*/</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtable</span> &#123;</span></span><br><span class="line">    uint nTableSize; <span class="comment">/*hash Bucket的大小，最小为8，最以2*x增长*/</span></span><br><span class="line">    uint nTableMask; <span class="comment">/*nTableSize-1, 索引取值的优化*/</span></span><br><span class="line">    uint nNumOfElements; <span class="comment">/*hash Bucket中当前存在的元素个数， count()函数会直接返回此值*/</span></span><br><span class="line">    ulong nNextFreeElement; <span class="comment">/*下一个数字索引的位置*/</span></span><br><span class="line">    Bucket *pInternalPointer;   <span class="comment">/* Used for element traversal ,当前遍历的指针，foreach比for快的原因之一,这个指针指向当前激活的元素*/</span></span><br><span class="line">    Bucket *pListHead; <span class="comment">/*存储数组头元素指针*/</span></span><br><span class="line">    Bucket *pListTail; <span class="comment">/*存储数组尾元素指针*/</span></span><br><span class="line">    Bucket **arBuckets; <span class="comment">/*存储hash数组*/</span></span><br><span class="line">    <span class="keyword">dtor_func_t</span> pDestructor; <span class="comment">/*在删除元素时执行的回调函数，用于资源的释放*/</span></span><br><span class="line">    zend_bool persistent; <span class="comment">/*指出了Bucket内存分配的方式。如果persistent为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> nApplyCount; <span class="comment">/*标记当前hash Bucket被递归访问的次数(防止多次递归)*/</span></span><br><span class="line">    zend_bool bApplyProtection; <span class="comment">/*标记当前hash桶允许不允许多次访问。不允许时，最多只能递归3次*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">    <span class="keyword">int</span> inconsistent;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure><p>假设我们已经对源码有了一定的了解了，我们可以知道<code>bucket.h</code>就是我们存储的key值，<code>bucket.h</code>的生成方法是根据<code>time33</code>算法获取的,对应到代码实现如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于字符串类型的key</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> _zend_hash_add_or_update(HashTable *ht, <span class="keyword">const</span> <span class="keyword">char</span> *arKey, uint nKeyLength, <span class="keyword">void</span> *pData, uint nDataSize, <span class="keyword">void</span> **pDest, <span class="keyword">int</span> flag ZEND_FILE_LINE_DC)</span><br><span class="line">&#123;</span><br><span class="line">    ulong h;</span><br><span class="line">    uint nIndex;</span><br><span class="line">    Bucket *p;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ZEND_SIGNALS</span></span><br><span class="line">    TSRMLS_FETCH();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IS_CONSISTENT(ht);</span><br><span class="line"></span><br><span class="line">    ZEND_ASSERT(nKeyLength != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CHECK_INIT(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//算出来hash key后需要根据hashTable的长度，把nIndex限制在这个长度内(通过nTableMask)</span></span><br><span class="line">    h = zend_inline_hash_func(arKey, nKeyLength);</span><br><span class="line">    nIndex = h &amp; ht-&gt;nTableMask;</span><br><span class="line"></span><br><span class="line">    p = ht-&gt;arBuckets[nIndex];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于数字类型的key</span></span><br><span class="line">ZEND_API <span class="keyword">int</span> _zend_hash_index_update_or_next_insert(HashTable *ht, ulong h, <span class="keyword">void</span> *pData, uint nDataSize, <span class="keyword">void</span> **pDest, <span class="keyword">int</span> flag ZEND_FILE_LINE_DC)</span><br><span class="line">&#123;</span><br><span class="line">    uint nIndex;</span><br><span class="line">    Bucket *p;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ZEND_SIGNALS</span></span><br><span class="line">    TSRMLS_FETCH();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    IS_CONSISTENT(ht);</span><br><span class="line">    CHECK_INIT(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是新增元素(如$arr[] = 'hello'), 则使用nNextFreeElement值作为hash值,否则直接使用传入的key h 最为hash值 */</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; HASH_NEXT_INSERT) &#123;</span><br><span class="line">        h = ht-&gt;nNextFreeElement;</span><br><span class="line">    &#125;</span><br><span class="line">    nIndex = h &amp; ht-&gt;nTableMask;</span><br><span class="line"></span><br><span class="line">    p = ht-&gt;arBuckets[nIndex];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串的hash函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ulong <span class="title">zend_inline_hash_func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *arKey, uint nKeyLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> ulong hash = <span class="number">5381</span>; <span class="comment">//这个常量是哪儿来的？</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* variant with the hash unrolled eight times */</span></span><br><span class="line">    <span class="keyword">for</span> (; nKeyLength &gt;= <span class="number">8</span>; nKeyLength -= <span class="number">8</span>) &#123;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (nKeyLength) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *arKey++; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">break</span>;</span><br><span class="line">EMPTY_SWITCH_DEFAULT_CASE()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面函数主要是插入或更新hashTable的函数，当插入的key是数字时，这个数字就是hastTable的索引值，其key值不经过hash算法，只经过<code>nIndex = h &amp; ht-&gt;nTableMask;</code>来确保存储的值范围属于hastTable的范围内，所以可以看出索引值<code>key</code> ,与其对应的时<code>nIndex</code>这个值，正在存储的槽位就是<code>nIndex</code>这个地方。</p><p>这个key类型是<code>ulong</code>，也就是<code>unsigned long</code>类型。由于我们的机器是64位的，所以<code>unsigned long</code>类型的取值范围应该是<code>0~1844674407370955161</code>。PHP有两个预定义的变量<code>PHP_INT_MAX</code>和<code>PHP_INT_SIZE</code>对于64位的机器他们的值分别是9223372036854775807和8，这恰好是hasttable所能表示key的最大值,到这里也许你会有一个疑问:为什么<code>PHP_INT_MAX</code>的值比<code>key</code>的范围不一致?<br>要回答这个问题首先要知道，hastTable的key输出可以是负值，这是怎么做到的呢？其实一个hashTable的hash值一定是一个正整数才行，但是输出的数和hash值只是一个对应关系，不需要都为正整数， 虽然我们定义的参数为<code>unsigned long</code>,其实我们却可以传一个负数,比如<code>$arr[-1] = &#39;test&#39;</code>，这时候也是和传递一个正数的处理过程是一样的。这时候<code>h</code>的值其实是<code>-1</code>的补码。再回到上面的问题，为什么<code>PHP_INT_MAX</code>的值比<code>key</code>范围不一致。当我们负值 PHP_INT_MAX时，其值是<code>9223372036854775807</code>，当赋值再比这个大时,输出的却是负数。这其实跟我们使用<code>var_dump</code>这个函数有关系, 下面代码是使用var_dump输出数组时所使用的方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_array_element_dump</span><span class="params">(zval **zv TSRMLS_DC, <span class="keyword">int</span> num_args, va_list args, zend_hash_key *hash_key)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    level = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_key-&gt;nKeyLength == <span class="number">0</span>) &#123; <span class="comment">/* numeric key */</span></span><br><span class="line">        php_printf(<span class="string">"%*c[%ld]=&gt;\n"</span>, level + <span class="number">1</span>, <span class="string">' '</span>, hash_key-&gt;h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* string key */</span></span><br><span class="line">        php_printf(<span class="string">"%*c[\""</span>, level + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">        PHPWRITE(hash_key-&gt;arKey, hash_key-&gt;nKeyLength - <span class="number">1</span>);</span><br><span class="line">        php_printf(<span class="string">"\"]=&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    php_var_dump(zv, level + <span class="number">2</span> TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，当key为数字时输出的格式时<code>%ld</code>,值是<code>hash_key-&gt;h</code>，这就是问题所在了，存储的是一个<code>unsigned long</code>，输出的却是<code>long</code>，当值比<code>long</code>大时，自然输出的就是负数了。</p><p>总结: PHP的hastTable是通过链表法实现的，按说是不会存在溢出的问题，但是其索引值表示的范围有限，当超出索引值时就会造成溢出，这个溢出只存在当索引值为数字时，输入的数字为正，输出却为负值的原因是函数参数与输出的类型不一致导致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作为PHP最重要的数据类型HashTable其key值是有一定的范围的，如果设置的key值过大就会出现溢出的问题，下面根据其内部结构及实现原理详细探讨一下key值溢出问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面先给出一个key溢出的例子:
      
    
    </summary>
    
    
      <category term="php" scheme="http://oohcode.com/tags/php/"/>
    
  </entry>
  
</feed>
