<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/12/10/go-modules/"><span>go modules</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/12/10/go-modules/" rel="bookmark">
        <time class="entry-date published" datetime="2019-12-10T06:39:02.000Z">
          2019-12-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="依赖的发展历史"><a href="#依赖的发展历史" class="headerlink" title="依赖的发展历史"></a>依赖的发展历史</h1><p><img src="/assets/img/go/modules/roadmap.jpeg" alt></p>
<h2 id="2009-年-1-月"><a href="#2009-年-1-月" class="headerlink" title="2009 年 1 月"></a>2009 年 1 月</h2><p> 刚开始 Go 语言雏形还不完善，用户只能使用官方库和自己开发的库来构建自己的程序，这时候使用还是 Makefile, 但是 Go 的设计目标是使写代码变得更加容易。 所以后来 Go 命令不使用 Makefiles 或者其他配置文件来指导程序的构建。Go 使用源代码来查找依赖关系并确定构建的条件。</p>
<h2 id="2010-年-2-月"><a href="#2010-年-2-月" class="headerlink" title="2010 年 2 月"></a>2010 年 2 月</h2><p>在 2010 年 2 月,  一篇名为：<a href="https://groups.google.com/forum/#!msg/golang-nuts/8JFwR3ESjjI/cy7qZzN7Lw4J" target="_blank" rel="noopener">goinstall: an experiment in package installation</a> 的文章在 Go 的讨论组中发布，主要是建立一个代码共享的机制，通过 <code>goinstall</code> 命令把依赖的代码库下载到本地，并通过 <code>import</code> 来引用这些代码。goinstall 的设计是下载的地址和引用的地址保持一致，比如 :</p>
<pre><code>-  goinstall github.com/user/project.git
</code></pre><p>那么使用的时候也是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/user/project.git"</span></span><br></pre></td></tr></table></figure>
<p>这种方式在社区引起了广泛的讨论, 主要包括引用的名字是否应该包含完整的路径，是否要考虑引用的版本，甚至有人提出把版本好加到引用路径中， 在当时的情况下 Russ Cox 选择了继续使用当前的方式，但是后来也证明有些建议是有用的，比如版本号。</p>
<h2 id="2011-年-12-月"><a href="#2011-年-12-月" class="headerlink" title="2011 年 12 月"></a>2011 年 12 月</h2><p>到了 2011 年 12 月， Go 语言统一了<a href="https://groups.google.com/forum/#!msg/golang-dev/8DNjlySemwI/-1CDvVX6QVcJ" target="_blank" rel="noopener">使用 <code>go</code> 命令</a>代替之前的 <code>gomake</code>/<code>gotest</code>/<code>goinstall</code>等命令。其中 <code>go get</code> 命令代替之前的 <code>goinstall</code> 正式加入 Go 语言中。</p>
<h2 id="2013-年-9-月"><a href="#2013-年-9-月" class="headerlink" title="2013 年 9 月"></a>2013 年 9 月</h2><p><code>go get</code> 虽然可以下载外部依赖，但是却没有版本的概念，这样就无法向用户保证每次下载代码的预期。 于是一些开源方案出现了。这些开源方案借鉴了其它语言的依赖管理方式，并结合 Go 语言自身的特点产生了<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="noopener">各种各样的方案</a>，其中最早的就是 <a href="https://github.com/tools/godep" target="_blank" rel="noopener">godep</a>, godep 主要是提供了一个依赖文件，这个文件记录了每个的依赖的具体的版本和路径，编译的时候把这些依赖下载到一个特定的目录 <code>workspace</code> 中, 然后 checkout 到特定的版本，再把这个目录加入到 <code>GOPATH</code>中，这样就能利用 Go 的编译查找路径编译特定的版本了。</p>
<h2 id="2013-年-11-月"><a href="#2013-年-11-月" class="headerlink" title="2013 年 11 月"></a>2013 年 11 月</h2><p>Go 官方同样注意到了这个问题，为了改善中情况在 Go 1.2 中添加了有关版本控制的相关建议:</p>
<blockquote>
<p>Packages intended for public use should try to maintain backwards compatibility as they evolve. The <a href="https://golang.org/doc/go1compat" target="_blank" rel="noopener">Go 1 compatibility guidelines</a> are a good reference here: don’t remove exported names, encourage tagged composite literals, and so on. If different functionality is required, add a new name instead of changing an old one. If a complete break is required, create a new package with a new import path.</p>
</blockquote>
<p> 主要是让用户遵循兼容性原则，不要随便删除和修改已经提供的方法，如果要修改最好是增加新的方法而不是修改旧的方法，如果真的需要不兼容则重新建立一个包。</p>
<p>但是这种建议是没有约束力的，开发者如果没有遵循这个建议还是会产生各种问题，无法从根本上保证。 </p>
<h2 id="2014-年-3-月"><a href="#2014-年-3-月" class="headerlink" title="2014 年 3 月"></a>2014 年 3 月</h2><p> 还有一种方案是 <a href="https://labix.org/gopkg.in" target="_blank" rel="noopener">gopkg.in</a> 采用的, 那就是对不同的版本进行不同的命名，通过引入路径的不同区分不同的版本。<br> 例如: <code>gopkg.in/yaml.v1</code>, 我们使用这个版本就要使用 <code>import &quot;gopkg.in/yaml.v1&quot;</code>。对于 gopkg.in 来说只是提供了一种利用 URL 版本化解决版本依赖的问题， 实际的存储地址在 github.com 上，如果版本号不发生改变就要保证向前兼容。</p>
<p>这种做法需要我们引入的时候带上版本号，并且之前 go get 的方案也有人提出了使用带版本的引入方案，但是都没有得到官方的认可，认为这种方法具有一定的侵入性。</p>
<h2 id="2014-年-10-月"><a href="#2014-年-10-月" class="headerlink" title="2014 年 10 月"></a>2014 年 10 月</h2><p>Glide 的发布提出了 <code>_vendor</code> 的概念，把所有依赖都放入这个目录，这其实与 godep 的 workspace 作用一样。Glide 还有一些优势就是可以添加包的映射关系，因为随着时间的推移很多包的地址发生了改变，或者报名发生了改变，但是为了不让使用者修改代码，可以使用这个映射来解决。 这也是后来 go module 方案借鉴的。</p>
<h2 id="2015-年-6-月"><a href="#2015-年-6-月" class="headerlink" title="2015 年 6 月"></a>2015 年 6 月</h2><p>随着社区的发展，官方也开始接纳社区的一些方案，总于在 Go 1.5 版本中正式加入了 <a href="https://go.googlesource.com/proposal/+/master/design/25719-go15vendor.md" target="_blank" rel="noopener">vendor 概念</a>。1.5 版本以后 Go 的编译从原来依赖 GOPATH和 GOROOT 有增加了一个 vendor 目录的依赖，这个目录存在于当前库的根目录，编译的时候会优先使用 vendor 目录，然后再去 GOPATH 下查找。<br>这个方案推出以后很多开源软件也很快进行跟进，把原来依赖 GOPATH 的修改改为依赖 vendor 目录。</p>
<p>之前GOPATH 的问题: Go程序通常由来自许多不同来源的程序包组成。 这些来源中的每一个都可以从GOPATH或标准库中获取。 但是，只有他们的项目受其自己的源代码管理。 依赖的包不受他们的管理和控制，如果依赖包发生更改或消失时就会影响项目的编译。 通常为了避免这些问题，有以下几种做法:</p>
<ol>
<li>将依赖包复制到项目目录中，并重写引用它的导入。</li>
<li>将相关程序包复制到项目代码库中，并修改GOPATH变量以包括项目特定的子目录。</li>
<li>将依赖包版本写到一个文件中，然后将现有的GOPATH软件包更新为该版本。</li>
</ol>
<p>但是这些做的后果同样会产生对应的问题:</p>
<ol>
<li>需要修改导入路径，还会存在包名冲突的问题, 分不清自己的和依赖的包。</li>
<li>存在多个 GOPATH, 而且是嵌套的，很容易出现查找不准等问题。</li>
<li>在正常的GOPATH中修改程序包要求每个项目都具有唯一的GOPATH。 否则不同项目就会产生相互干扰。</li>
</ol>
<p>vendor 的加入是为了解决 GOPATH 的不足， 开发者可以把依赖放到 vendor 中而不影响其它项目，也可以防止依赖的变更和丢失。对于第二个作用也会产生一个副作用：代码库依赖太庞大，照成存储上的浪费。<br>vendor 还有一个问题是版本不明确，无法通过 vendor 很好的进行版本管理。</p>
<h2 id="2016-年-8-月"><a href="#2016-年-8-月" class="headerlink" title="2016 年 8 月"></a>2016 年 8 月</h2><p>前面说开源工具比较混乱，是因为大家使用不同的依赖管理工具，有一个问题就是你的间接依赖的版本如何确定？ 因为某些间接依赖的版本根据依赖管理工具的使用来标明的，如果使用不同的依赖管理工具就无法获取你的间接依赖版本，或者需要兼容你得依赖管理工具，这样做太难了。最好的方式当然是统一依赖管理工具，这样能够很好的进行依赖的分析。<br>2016 年 GopherCon 大会后， 一个计划改善 Go 依赖管理的<a href="https://docs.google.com/document/d/18tNd8r5DV0yluCR7tPvkMTsWD_lYcRO7NhpNSDymRr8/edit" target="_blank" rel="noopener">民间组织</a>成立了。这个组织的目的就是为了开发一个能够完善的解决包依赖管理问题的方案。这个方案就是: <a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a> 。这个小组甚至邀请了一些开源的依赖管理工具的作者: </p>
<ul>
<li>Daniel Theophanes (govendor)</li>
<li>Dave Cheney (gb)</li>
<li>Matt Farina (Glide)</li>
<li>Steve Francia (Hugo, Cobra)</li>
</ul>
<p>作为顾问。<br>dep 工具和开源的依赖管理工具思路是一样的:</p>
<ol>
<li>依赖 GOPATH 判断包的依赖地址和版本</li>
<li>依赖 vendor 下载依赖到项目下，保证编译版本一致</li>
</ol>
<p>为了让你能够从其它依赖管理工具迁移到 dep, dep 还会分析已经项目中已经存在的常见的依赖管理文件，并在初始化的时候与里面的依赖版本保持一致。</p>
<h2 id="2018-年-2-月"><a href="#2018-年-2-月" class="headerlink" title="2018 年 2 月"></a>2018 年 2 月</h2><p>最终还是来到了 2018 年，这年 2 月 Russ Cox 在自己的个人网站上发布了 <a href="https://research.swtch.com/vgo" target="_blank" rel="noopener">7 篇博文</a>，并与 3 月份在 Go 官方网站开启了<a href="https://github.com/golang/go/issues/24301" target="_blank" rel="noopener">此提案</a>, 并且于 5 月 21 日(日子不错) 被接受。文章发布社区顿时就炸了，特别是 dep 的成员。因为这个提案完全不同于之前的工作方式，让之前的工作都付诸东流，甚至有人觉得 Go 的官方不尊重社区，太独裁了。随后 Russ Cox 又发表了 <a href="https://research.swtch.com/vgo" target="_blank" rel="noopener">4 篇博文</a>, 加上之前的一共发布了 11 篇博文来论证新的依赖管理方案: vgo。<br>关于 vgo 的方案下面会详细介绍。</p>
<h2 id="2018-年-8-月"><a href="#2018-年-8-月" class="headerlink" title="2018 年 8 月"></a>2018 年 8 月</h2><p>随着 Go 1.11 的发布，vgo 化身为 go modules, 对应命令 <code>go mod</code> 加入到了官方的工具链当中，并且从语言底层进行了支持。Go Modules 的发布意味着 Go 语言的依赖管理方案最终又要走向官方的统一方案，开源方案也纷纷表示不再支持更新，建议大家选用官方方案。</p>
<p>以上就是 Go 语言依赖管理发展的前世今生。</p>
<p>当然这不表示这个方案已经完美，Go Modules 还在不断发展当中，很多特性也会加入，但是总体的思想和设计方案不再会有变动。</p>
<h1 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h1><p>Go Modules 已经被官方发出，所以后面的趋势就是会统一 Go 语言依赖管理的方案，结束现在混乱的状态，所以每个 Go 语言开发者都应该学习和使用 Go Modules。 下面会花更多的篇幅对Go Modules的设计思想和使用进行详细介绍。</p>
<h2 id="Go-依赖管理的三个原则"><a href="#Go-依赖管理的三个原则" class="headerlink" title="Go 依赖管理的三个原则"></a>Go 依赖管理的三个原则</h2><p>Go 从出生开始的动机就是为了简化软件工程。这种动机也体现在 Go 的依赖管理设计上，分别是：兼容性，可重复性和合作性三个原则。<br>Go 依赖管理的设计原则是 Go Modules 设计与其它管理方案如: Dep，Cargo，Bundler等设计不同的原因。 也是为什么没有选择 Dep 的原因。</p>
<h3 id="1-兼容性-引入版本号到-import-语句中"><a href="#1-兼容性-引入版本号到-import-语句中" class="headerlink" title="1 兼容性 (引入版本号到 import 语句中)"></a>1 兼容性 (引入版本号到 import 语句中)</h3><p>兼容性或者成为稳定性，是指程序中名称的含义不应随时间而发生改变。  如果确实需要发生改变， 则需要跟之前的引入路径保持不同。<br>对于兼容性主要有一些异议:</p>
<ol>
<li>美学<br>对于 Go 来说良好的软件工程性比一些主观上的美学更加重要。 视觉美学我们会习惯它们， 但我们更重视它们带来的精确性和简单性。对于 Go 的设计可以举两个例子:<br>1.1 Go 语言去掉 export 关键字而使用首字母大小写代替是否可导出，从编程习惯是需要适应，但是也能够一眼看出哪些调用是可导出的。<br>1.2 导入路径看上去有点儿长，但是能够更加精细的表示导入的模块，从而避免了不必要的重复。</li>
<li>需要修改导入路径<br>我们把版本号加入导入路径使导入路径在语义上保持精确。另一个好处是，当您从软件包的v2升级到v3时，您可以逐步，分阶段地（一次可能一个软件包）逐步更新程序。这种方案之前也有提出，但是被否定了，就是处于美观的考虑，但是这种方式除了不太美观没有其他副作用，而且能够更好的解决问题。</li>
<li>构建中的多个主要版本<br>其它依赖管理工具不允许同一个代码库的不同版本同时被依赖, 这样能够降低开发者的复杂性，但是对用户来说则可能会更加复杂，而且时间情况中无法避免同一个项目的代码在他的所有依赖文件中出现不同的版本。</li>
</ol>
<h3 id="2-可重复性-最小版本选择"><a href="#2-可重复性-最小版本选择" class="headerlink" title="2 可重复性 (最小版本选择)"></a>2 可重复性 (最小版本选择)</h3><p>当您构建特定版本的程序包时，构建应以可重复的方式决定要使用的依赖项版本，该依赖关系不会随着时间的推移而改变。<br>对这个原则的主要异议在于，很多人认为使用最新的版本是一项基本的诉求，很多人希望能够使用最新的版本到达更新一些 bug 的修复和性能的提升等。但是同时大家都会认为构建的可重复性是更加重要的，因为这能够保证程序的稳定性，这是最基本的要求。一些依赖工具例如 Dep 会优先使用最新版本，但是为了保持稳定性还有一个 lock 文件保证某些依赖的版本不变。Dep 的 lock 文件问题在于只会对当前代码库生效，如果这个代码库是其他库的一部分，那么就无法保证这种稳定性。所以 Go Modules 通过最小版本依赖原则来优先保证构建的稳定性。</p>
<h3 id="3-合作性-共同致力于兼容性"><a href="#3-合作性-共同致力于兼容性" class="headerlink" title="3 合作性 (共同致力于兼容性)"></a>3 合作性 (共同致力于兼容性)</h3><p>为了维护Go软件包生态系统，我们必须共同努力, 致力于保证兼容性。工具无法解决缺乏合作的问题。<br>无论是基于 <a href="https://research.swtch.com/version-sat" target="_blank" rel="noopener">SAT</a> 算法的 Dep 还是基于最小版本原则的 Go Modules 都无法保证兼容性。但是最小版本选择比 SAT 更加具有稳定性( 证明可以看这里: <a href="https://research.swtch.com/vgo-principles#sat-example" target="_blank" rel="noopener">Go Modules 与 SAT 解决方案对比</a>)</p>
<h2 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h2><p>Go Modules 引入了<a href="https://semver.org/" target="_blank" rel="noopener">语义化版本</a>来标识软件的版本，而且是强制的。语义化版本就是把版本号分为三位，分别代表不同的含义:</p>
<ol>
<li>第一位版本号(major version): 一些不兼容的修改</li>
<li>第二位版本号(minor version): 一些新特性的增加</li>
<li>第三位版本号(patch version): 一些 bug 的修复</li>
</ol>
<p><img src="https://research.swtch.com/impver@2x.png" alt></p>
<p>小版本的更新不会破坏你的代码（向后兼容）, 如果出现了错误你应该报告给作者，让他进行修改；大版本的更新可能会让你的代码无法编译，因为大版本可能不是向后兼容的，但是这种改变可能正式作者期望的。</p>
<p>这个规范是建议性的并没有约束力，而且根据 <a href="https://www.hyrumslaw.com/" target="_blank" rel="noopener">hyrums 定律</a>:</p>
<blockquote>
<p>With a sufficient number of users of an API, it does not matter what you promise in the contract. All observable behaviors of your system will be depended on by somebody.<br>当接口的使用者数量达到一定数量后，你指定的规则就不重要了，所有的表现都取决于他的使用者。</p>
</blockquote>
<p>也就是无法保证大家都按照这个规范执行了，但是语义版本控制仍然是一种构架对发布之间关系的期望的有用方法。目前还没有其它更好的代替方法。 </p>
<p>关于语义化版本的引入, Russ Cox 还说:</p>
<blockquote>
<p>A year ago, I believed that putting versions in import paths like this was ugly, undesirable, and probably avoidable. But over the past year, I’ve come to understand just how much clarity and simplicity they bring to the system. In this post I hope to give you a sense of why I changed my mind. @Russ Cox</p>
</blockquote>
<p>可见大佬的想法也会随时间而改变， 没有一个东西开始就是完美的，但是谨慎的引入，原则的坚持总不会错的。</p>
<h2 id="最小版本原则"><a href="#最小版本原则" class="headerlink" title="最小版本原则"></a>最小版本原则</h2><p>在 Go Modules 之前，Go 版本选择有两种情况:</p>
<ol>
<li><p>第一种算法是默认行为go get：如果您有本地版本，请使用该版本，否则请下载并使用最新版本。此模式可能使用的版本过旧：如果您已安装B 1.1并运行go get以下载A，则go get不会更新为B 1.2，从而导致构建失败或错误。</p>
</li>
<li><p>第二种算法的行为是go get -u：下载并使用所有内容的最新版本。此模式通过使用太新的版本而失败：如果您运行go get -u下载A，它将正确更新为B 1.2，但也会更新为C 1.3和E 1.3，这不是A所要求的，可能没有经过测试，可能无法正常工作。</p>
</li>
</ol>
<p>可见这两种情况都不能保证构建的稳定性。</p>
<h3 id="最小版本原则的计算方式"><a href="#最小版本原则的计算方式" class="headerlink" title="最小版本原则的计算方式"></a>最小版本原则的计算方式</h3><p>为了说明最小版本原则，我们通过 Russ Cox <a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">博客</a>中给出的例子进行讲解。首先给出一个初始的依赖关系:<br><img src="/assets/img/go/modules/version-select-1.svg" alt><br>为了验证我在自己的 github 页面建立的对应的代码库，和对应的标签。 但是有一个循环依赖的问题我认为是无法满足的，所以做了一些改变, 但是并不影响整体的逻辑。 有关循环依赖的这个问题可以参考 <a href="https://github.com/golang/go/issues/24098" target="_blank" rel="noopener">#issue24098</a></p>
<h4 id="1-构建需求列表"><a href="#1-构建需求列表" class="headerlink" title="1. 构建需求列表"></a>1. 构建需求列表</h4><p>我们根据初始的依赖关系，可以按照下图中黄色的部分表示查找的路径:<br><img src="/assets/img/go/modules/version-select-2.svg" alt="查找路径"></p>
<p>对于同一个模块的不同版本，我们会选择最高的版本，下面就是这个算法的选择过程:<br><img src="https://research.swtch.com/version-select-list@2x.png" alt="算法演进"></p>
<p>最终我们的依赖关系可以在原来的基础上表示，黄色的部分我们保留，表示之前的查找路径，红色部分就是表示最终的依赖路径和依赖的模块版本：</p>
<p><img src="/assets/img/go/modules/version-select-2-2.svg" alt="选择路径"></p>
<p>我们也可以使用 <code>go list</code> 命令查看响应的依赖关系：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.2.0</span><br><span class="line">github.com/two/c v1.2.0</span><br><span class="line">github.com/two/d v1.4.0</span><br><span class="line">github.com/two/e v1.2.0</span><br></pre></td></tr></table></figure>
<p>这里的最小版本原则就是指及时 C 发布了更新的版本 C1.3，但是如果不主动更新这个版本，每次构建的依赖还是 C1.2 版本，最大程度的保证了构建稳定性。 而 dep 这些依赖管理工具则会选择最新版本，很容易就会发现依赖发生了非常大的变化，每次都见都会随着版本的发布而改变，不可预期的可能性大大提高了。</p>
<h4 id="2-升级所有模块"><a href="#2-升级所有模块" class="headerlink" title="2. 升级所有模块"></a>2. 升级所有模块</h4><p>如果我们想升级目前依赖的所有模块到最新版本(这里的最新版本是指经过发布的语义化版本), 保持之前的黄色模块依赖，红色部分表示最新的依赖关系和选择的模块。<br><img src="/assets/img/go/modules/version-select-3.svg" alt="升级所有模块"></p>
<p>升级所有模块的命令是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> get -u</span><br></pre></td></tr></table></figure></p>
<p>升级后可以查看模块选择:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.2.0</span><br><span class="line">github.com/two/c v1.3.0</span><br><span class="line">github.com/two/d v1.4.0</span><br><span class="line">github.com/two/e v1.3.0</span><br><span class="line">github.com/two/f v1.1.0</span><br><span class="line">github.com/two/g v1.2.0</span><br></pre></td></tr></table></figure></p>
<h4 id="3-计算最小需求列表"><a href="#3-计算最小需求列表" class="headerlink" title="3. 计算最小需求列表"></a>3. 计算最小需求列表</h4><p>对与使用 go.mod 的项目， 如果依赖的包也使用了 go.mod, 那其依赖的版本在go.mod 中已经做了说明了，所以当前的项目就可以不写这个依赖文件了。 例如前面升级所有模块后的 go.mod 文件长这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module github.com/two/a</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/two/b v1.2.0</span><br><span class="line">        github.com/two/c v1.3.0</span><br><span class="line">        github.com/two/d v1.4.0 // indirect</span><br><span class="line">        github.com/two/e v1.3.0 // indirect</span><br><span class="line">        github.com/two/g v1.2.0 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里只是列出了必须的模块的依赖, 例如 <code>github.com/two/f</code> 模块可以通过 <code>github.com/two/c</code>模块的依赖表示，就没有必要写进去。<br>但是 <code>github.com/two/f</code> 引用的是 <code>github.com/two/g</code> 的 <code>v1.1.0</code>, 这里由于需要的是 <code>v1.2.0</code>, 所以回单独列出来。</p>
<h4 id="4-升级单个模块"><a href="#4-升级单个模块" class="headerlink" title="4. 升级单个模块"></a>4. 升级单个模块</h4><p>大多数情况下我们并不会一次升级所有模块，因为这样带来的不确定性太大，我们一般都会根据需求来升级模块，如果你的依赖没有你需要的新的特性或者 bug 的修复你就没有必要升级。 假如我们要在初始的依赖关系中升级 C1.2 到 C1.3 版本， 我们可以使用命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/two/c</span><br></pre></td></tr></table></figure>
<p>升级完成后我们可以看一下依赖的关系:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.2.0</span><br><span class="line">github.com/two/c v1.3.0</span><br><span class="line">github.com/two/d v1.4.0</span><br><span class="line">github.com/two/e v1.2.0</span><br><span class="line">github.com/two/f v1.1.0</span><br><span class="line">github.com/two/g v1.1.0</span><br></pre></td></tr></table></figure>
<p>根据这个依赖关系，可以画出对应的依赖关系图，红色表示最终的依赖。<br><img src="/assets/img/go/modules/version-select-4.svg" alt="升级单个模块"></p>
<p>这里注意一个问题, C1.3 并不依赖 D1.4, 而 B1.2 依赖的是 D1.3, 也就是说没有模块依赖 D1.4, 但是在最终的版本选中却保留了 D1.4 而不是 D1.3。如果我们降级 D 则会带来一些非预期的结果，并且我们的依赖不再稳定，也违背了最小更改的原则。 所以 Go Modules 要保证不能为你带来非预期的自动降级。</p>
<h5 id="5-降级"><a href="#5-降级" class="headerlink" title="5. 降级"></a>5. 降级</h5><p>假如我们发现 D1.4 有一个 bug , 这个 Bug 是 D1.3 引入的，我们需要将 D1.3 降级到 D1.2, 这时我们也需要将引入 D1.3 及以上版本的 B1.2 和 C1.2进行降级，因为如果只降级了 D 则 B1.2 和 C1.2 很可能使用了 D1.3以上版本的功能导致不可预期的事情发生。 可以用灰色来表示不可用的模块版本:<br><img src="/assets/img/go/modules/version-select-5.svg" alt="不可用模块"></p>
<p>下面我们对 D 进行降级:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/two/d@v1.2.0</span><br></pre></td></tr></table></figure></p>
<p>降级后的依赖关系:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.1.0</span><br><span class="line">github.com/two/c v1.1.0</span><br><span class="line">github.com/two/d v1.2.0</span><br><span class="line">github.com/two/e v1.2.0</span><br></pre></td></tr></table></figure>
<p> 由于我们要遵循最小更改原则，所以我们不会主动降级下一层的依赖 E1.2, 最终我们的依赖关系用图来表示就是:<br><img src="/assets/img/go/modules/version-select-6.svg" alt="降级模块"></p>
<p>生成的 Go Module 文件如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module github.com/two/a</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/two/b v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">        github.com/two/c v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">        github.com/two/d v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">        github.com/two/e v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>依赖文件中的 <code>// indirect</code> 是非常有用的，特别是对于一些升级和降级的模块来说，我们不能直接按照新的规则来计算依赖的版本，而要保持最小的变动原则，这个注释就是指那些发生了模块的变动但是需要保持版本和依赖的一些模块。 如果我们不保留这个模块的描述最终的依赖就会是跟新生成的依赖一样，不会有这些版本的要求，会存在一些非预期的风险, 无法尽可能的保证依赖的稳定性。</p>
<p>假如我们删除这两行，改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module github.com/two/a</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/two/b v1.1.0</span><br><span class="line">        github.com/two/c v1.1.0</span><br><span class="line">        // github.com/two/d v1.2.0 // indirect</span><br><span class="line">        // github.com/two/e v1.2.0 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>通过命令查看依赖关系:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go list -m all</span><br><span class="line">github.com/two/a</span><br><span class="line">github.com/two/b v1.1.0</span><br><span class="line">github.com/two/c v1.1.0</span><br><span class="line">github.com/two/d v1.1.0</span><br><span class="line">github.com/two/e v1.1.0</span><br></pre></td></tr></table></figure>
<p>对应的依赖关系图:<br><img src="/assets/img/go/modules/version-select-6-2.svg" alt="降级模块"></p>
<p>这种降级是没有必要的，因为我们认为 D1.2 要比 D1.1 更好，而 E1.2也会比 E1.1 更好， 而且他们都做到了向下兼容，如果都进行了降级反而会产生一些不好的结果，稳定性也下降。</p>
<h2 id="Go-Modules-引入的变化"><a href="#Go-Modules-引入的变化" class="headerlink" title="Go Modules  引入的变化"></a>Go Modules  引入的变化</h2><p>有了以上的理论和算法基础，Go Modules 的引入就变得不那么难了，Module 的概念就是公共引用前缀，是版本控制的单位。Module 的引入带来了几个变化：</p>
<ol>
<li>提倡使用明确的发行版本而不是某个提交的 ID，可以清楚地表明预期。</li>
<li>引入了代理的概念(GOPROXY),<br> 2.1 不依赖各种版本控制工具下载，防止碎片化，都改为使用 HTTP 协议, 代码库都是以 zip  的形式存在。<br> 2.2 通过 GOPROXY 缓存依赖，保证可用性(可重复下载)和安全性(安全检测)<br> 2.3 将来还会引入共享代理，可以默认使用共享代理(类似其它语言的集中式管理)</li>
<li><p>通过独立的版本控制在单个代码库中开发多个模块<br> 有两种方式:</p>
<ol>
<li>使用单独的分支表示不同的版本<br><img src="https://research.swtch.com/gitmod-1@2x.png" alt></li>
<li>通过子目录表示不同的版本<br><img src="https://research.swtch.com/gitmod-2@2x.png" alt><br>vgo 两种都支持，但是第二种能够更加平滑</li>
</ol>
</li>
<li><p>不再需要 vendor<br>vendor 目录有两个作用。首先，他们通过其内容指定要在期间使用的依赖项的确切版本。其次，即使原始副本消失了，它们也可以确保这些依赖项的可用性。<br>但是 vendor 也有一个弊端就是代码的副本太多了，每个代码库都要提交依赖，占用了大量的存储库的信息。vgo 已经解决了 vendor 所带来的两个好处，所以它就没有存在的必要性了。<br>在编译时 vgo 会忽略 vendor 目录的存在，如果你还想强制使用 vendor 可以使用: <code>go build -mod=vendor</code></p>
</li>
<li>不再需要 GOPATH<br>注意你的代码库不再依赖 GOPATH, 但是目前如果还在 GOPATH 下，默认是不开启 Go Modules 的，如果你不在 GOPATH 则会开启 Go Modules。不依赖 GOPATH 不意味着不需要 GOPATH, 只是你自己的代码不需要放到这个目录下，但是一些编译的输出，和依赖库的缓存还是会放到这个目录下。</li>
</ol>
<p>为了保证再现性，可验证性和经过验证的构建方式, Go Modules 做了以下几点:</p>
<ol>
<li>通过最低版本原则保证每次构建下载的都是同一版本的代码</li>
<li>通过 hash 值保证每个版本代码都有一个唯一的标识</li>
<li>通过 hash 对比保证每个依赖的版本与 hash 对应，防止篡改</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="go-mod-amp-go-sum-文件"><a href="#go-mod-amp-go-sum-文件" class="headerlink" title="go.mod &amp; go.sum 文件"></a>go.mod &amp; go.sum 文件</h2><p>go.mod 和 go.sum 文件成对同时出现在模块的根目录中。<br>go.mod 文件记录了依赖的关系和版本。 go.mod 文件支持四种命令:</p>
<ul>
<li><code>module</code>:<br>出现在文件第一行表示的是此模块的名字，这个模块名字就是被其他模块引用时的名字，如果不一致就会报错。</li>
<li><code>require</code>:<br>记录依赖的包及版本号</li>
<li><code>replace</code><br>有些包的地址发生了变化，可以通过这个来指向另一个包, 不必修改 import 的地址</li>
<li><code>exclude</code><br>有些包的某个版本有问题，需要在这里明确支持不使用某个版本</li>
</ul>
<p>下面是一个 go.mod 文件的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module github.com/two/a</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/two/b v1.2.0</span><br><span class="line">        github.com/two/c v1.3.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>go.sum 记录用于安全性和完整性校验的信息。 go.sum 文件 每行的格式都是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;模块&gt; &lt;版本&gt; [/ go.mod] &lt;哈希&gt;</span><br></pre></td></tr></table></figure>
<p>没有 <code>/go.mod</code> 的是表示这个版本的模块的源代码的 hash 值(使用 SHA-256算法)<br>带有 <code>/go.mod</code> 的表示这个版本的模块的 go.sun 文件的 hash 值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">github.com/two/b v1.2.0 h1:1w6ZrvIUmiXBRX/cmUlzAy1fA76mgBY55/5LlpxfbiA=</span><br><span class="line">github.com/two/b v1.2.0/go.mod h1:I1qidS2xpjDqFf5kPEEWqlYII81sIAsewITgM3NnpnM=</span><br><span class="line">github.com/two/c v1.3.0 h1:BkIIZs1in6e4+8E/JrPG02IdO3Cw+k4YtlwXteCQaiI=</span><br><span class="line">github.com/two/c v1.3.0/go.mod h1:3Xpyx3nev6KimFlAAv4VqnfklWKOM6EWQHId5qr7cvw=</span><br><span class="line">github.com/two/d v1.3.0 h1:CowHIy3VdlGGBzmobCQXjS+8xkvAwTXqGJOEdSODwPQ=</span><br><span class="line">github.com/two/d v1.3.0/go.mod h1:fAg6MyXvtnCUuov3tcLoCmXTV7c99ECaEKVw442oC/c=</span><br><span class="line">github.com/two/e v1.2.0 h1:jJIqW7+D0MJh8g5B1amYojQvtQdhKsYqEe17QWU6oEw=</span><br><span class="line">github.com/two/e v1.2.0/go.mod h1:RczHMX2xzAngm2z2jYPtHRxyJWl99oJDlZI7RHy7zfo=</span><br><span class="line">github.com/two/f v1.1.0 h1:dNFUxmhP64A4BIxlI4F9vraG6snBV/UjGe0Vod8CXho=</span><br><span class="line">github.com/two/f v1.1.0/go.mod h1:buQ/ZEGBVlMU2xGMfgKig/Sn1d/6addjRnsFb1mH2DQ=</span><br><span class="line">github.com/two/g v1.1.0 h1:eBWE3BIwdZ3/tcnA/4KZWKRBxHnWGWopcn72wbhN/M8=</span><br><span class="line">github.com/two/g v1.1.0/go.mod h1:a/jbi0S1ZL9XI+Fqd3Ca1618vwkl8Js166KP13u/EHw=</span><br></pre></td></tr></table></figure>
<p>go.sum 文件并不是必须的，go.sum 中记录的模块主要是用户本地校验，既使用下载到本地的模块与 go.sum 中的校验值进行对比，如果 go.sum 中没有对应的模块，则会到一个远程的校验数据库进行校验，这个远程数据库通过 Go 语言环境变量 <code>GOSUMDB</code> 来设置，当然也可以选择不校验。</p>
<h2 id="相关环境变量"><a href="#相关环境变量" class="headerlink" title="相关环境变量"></a>相关环境变量</h2><p>通过 <code>go env</code> 命令我们可以看到所有的环境变量，其中跟 Go Modules 相关的主要有下面几个:</p>
<blockquote>
<p>注意: 这里是针对 Go 1.13 版本进行说明。由于 Go Modules 还在不断发展中，很多东西不太成熟，会存在一些新增的环境变量。</p>
</blockquote>
<ul>
<li><code>GOPATH</code>:<br>这个变量大家都很熟悉了，但是在 Go Modules 中他的含义发生了变化，用户的代码不需要放到这个路径下，但是依然需要这个路径，Go Modules 下载的依赖放在这个路径下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH/pkg/</span><br><span class="line">├── linux_amd64</span><br><span class="line">└── mod</span><br><span class="line">    ├── cache</span><br><span class="line">    │   ├── download</span><br><span class="line">    │   │   └── github.com</span><br><span class="line">    │   │       └── two</span><br><span class="line">    │   │           ├── b</span><br><span class="line">    │   │           │   └── @v</span><br><span class="line">    │   │           │       ├── list</span><br><span class="line">    │   │           │       ├── list.lock</span><br><span class="line">    │   │           │       ├── v1.2.0.lock</span><br><span class="line">    │   │           │       ├── v1.2.0.mod</span><br><span class="line">    │   │           │       ├── v1.2.0.zip</span><br><span class="line">    │   │           │       └── v1.2.0.ziphash</span><br><span class="line">    │   │           ├── c</span><br><span class="line">    │   │           │   └── @v</span><br><span class="line">    │   │           │       ├── list</span><br><span class="line">    │   │           │       ├── list.lock</span><br><span class="line">    │   │           │       ├── v1.3.0.lock</span><br><span class="line">    │   │           │       ├── v1.3.0.mod</span><br><span class="line">    │   │           │       ├── v1.3.0.zip</span><br><span class="line">    │   │           │       └── v1.3.0.ziphash</span><br><span class="line">    .   .</span><br><span class="line">    .   .</span><br><span class="line">    .   .  </span><br><span class="line">    │   └── lock</span><br><span class="line">    └── github.com</span><br><span class="line">        └── two</span><br><span class="line">            ├── b@v1.2.0</span><br><span class="line">            ├── c@v1.3.0</span><br><span class="line">            ├── d@v1.3.0</span><br><span class="line">            ├── e@v1.2.0</span><br><span class="line">            ├── f@v1.1.0</span><br><span class="line">            └── g@v1.1.0</span><br></pre></td></tr></table></figure>
<p>其中 mod/cache 目录下是从代理服务器下载下来的原始文件，包括打包好的源代码，依赖文件和hash 值等信息。<br><code>mod/github.com</code> 目录下放的是解压后的代码，其中每个代码库都会放到以 <code>module@version</code> 格式命名的目录中，这也解决了同一个环境下放置多个版本文件的问题，解决了环境的相互干扰。<br>另外说明的一点是: 下载的依赖都是针对特定版本的，不会包含提交的历史信息，大大减少依赖的文件大小。</p>
<p>如果我们要清楚缓存文件，可以使用 <code>go clean -modcache</code> 命令， 这个命令会删除 $GOPATH/pkg/mod 路径下的所有内容。</p>
<ul>
<li><p><code>GO111MODULE</code>:<br>这个变量表示是否开启 Go Modules 功能，因为是在 Go 1.11 版本加入的，所以叫 GO111MODULE。这个变量又三个值，分别是:</p>
<ul>
<li><code>GO111MODULE=off</code>  : 强制不使用，依赖 GOPATH</li>
<li><code>GO111MODULE=on</code>   : 强制使用</li>
<li><code>GO111MODULE=auto</code> : 如果当前模块在 $GOPATH/src 中不使用，如果不在 $GOPATH/src 目录中并且存在 go.mod 文件则使用</li>
</ul>
</li>
<li><p><code>GOPROXY</code> &amp; <code>GONOPROXY</code>:<br><code>GOPROXY</code> 是指代理服务器的地址, 用户可以指定代理服务器来下载依赖，目前有几个知名的代理服务器，包括 <a href="https://goproxy.io/" target="_blank" rel="noopener">goproxy.io</a>, <a href="https://goproxy.cn" target="_blank" rel="noopener">goproxy.cn</a> 以及官方提供的 <a href="https://proxy.golang.org/" target="_blank" rel="noopener">proxy.golang.org</a>。Go Modules 发布后有很多企业没有使用还有一个原因是所有的代码库都要走代理，但是有些代码库是企业内部的，并且有权限的控制的，这些不想走代理，于是在 Go 1.13 又加入了一个 <code>GONOPROXY</code> 变量，通过设置这个变量可以决定哪些依赖不走代理，而是直接通过原来的方式从源地址下载。</p>
</li>
<li><p><code>GOSUMDB</code> &amp; <code>GONOSUMDB</code>:<br>这两变量是控制完整性校验的。通过 <code>GOSUMDB</code> 我们可以设置远程的校验地址，当我们下载的依赖不在 go.sum 文件中时，我们就要通过这个地址远程校验。当然我们也可以忽略校验，通过设置 <code>GONOSUMDB</code> 可以选择哪些模块不需要进行校验，特别是一些私有的代码库。</p>
</li>
<li><p><code>GOPRIVATE</code>:<br>这个其实可以看成是 <code>GOPRIVATE</code> = <code>GONOPROXY</code> + <code>GONOSUMDB</code>。 如果设置了 <code>GOPRIVATE</code> 就相当于同时设置了 <code>GONOPROXY</code> 和 <code>GONUSUMDB</code>。</p>
</li>
<li><p><code>GOMOD</code>:<br>当前模块的 go.mod 文件路径，是动态的，如果不在 go 模块中则默认是: <code>/dev/null</code></p>
</li>
</ul>
<h2 id="相关命令行"><a href="#相关命令行" class="headerlink" title="相关命令行"></a>相关命令行</h2><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h3><p>运行  <code>go help mod</code> 命令可以看到支持下列几个参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"></span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">        go mod &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">        download    download modules to local cache</span><br><span class="line">        edit        edit go.mod from tools or scripts</span><br><span class="line">        graph       print module requirement graph</span><br><span class="line">        init        initialize new module in current directory</span><br><span class="line">        tidy        add missing and remove unused modules</span><br><span class="line">        vendor      make vendored copy of dependencies</span><br><span class="line">        verify      verify dependencies have expected content</span><br><span class="line">        why         explain why packages or modules are needed</span><br><span class="line"></span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure>
<p>一般我们的使用步骤是这样：</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>go mod init [package name]</code><br>如果在 GOPATH下面之行，则默认使用的是相对 GOPATH 的路径，如果不是则需要加包名作为参数。建立一个空的包:<br> 例如:<br><code>go mod init example.com/m</code></p>
<p>生成 go.mod 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module example.com/m</span><br><span class="line"></span><br><span class="line">go 1.13</span><br></pre></td></tr></table></figure>
<h4 id="自动添加"><a href="#自动添加" class="headerlink" title="自动添加"></a>自动添加</h4><p>我们可以不用特意添加自己的依赖，如果我们执行 <code>go build</code> 或者 <code>go test</code> 等命令则会自动帮我们下载依赖并写入到 go.mod 文件中。版本选择，如果我们的依赖中有依赖文件并且写明了版本则会根据最小版本原则进行选择，如果我们的依赖没有指名版本则会下载最新的版本，这个最新版本是指语义优化标签最大的版本，如果没有语义化标签则自动生成一个标签: <code>(v0.0.0)-(提交时间, UTC 时间)-(commit id)</code> 作为版本的标识。</p>
<h4 id="自动整理"><a href="#自动整理" class="headerlink" title="自动整理"></a>自动整理</h4><p><code>go mod tidy</code>， 通过这个命令我们可以自动整理当前的依赖文件，把需要的文件加入，把不再需要的依赖删除。 其实如果我们执行 <code>go build</code> 或者 <code>go test</code> 也会自动更新这个依赖文件。Go 语言的目的是尽量减轻用户的操作，所以能帮你做的都做了。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p><code>go get -u [package name]</code>  可以用来更新依赖的版本，如果加了具体的包名则只更新这一个包，如果没加则更新所有依赖包。</p>
<h4 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h4><p>使用 Go Module 后如果我们需要依赖一个或者多个包来进行调试，而这个依赖的包还没有正式提交，我们该如何做呢? 这里有两种方案:</p>
<ol>
<li><p>使用 replace:<br>我们可以借助 go modules 的 replace 关键字把依赖的地址改为本地未提交的版本所在的地址, 例如我们依赖 <code>example.com/m2</code>，但是这个包还在开发中并未发布，我们可以在 go mod 文件中加上:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace example.com/m2 =&gt; /local/path/to/my/module</span><br></pre></td></tr></table></figure>
<p> 这样我们就可以在本地随时修改依赖包进行调试了。 但是这样做有一个缺点就是我们需要修改 go.mod 文件，如果我们调试完不小心提交了这个文件，可能会照成一些不必要的麻烦，我们还有第二种方式。</p>
</li>
<li><p>使用 vendor:<br>虽然 vendor 目录已经不是 go modules 所需要的了，但是这个目录不会从 Go 语言中去掉，相关的讨论可以看 <a href="https://groups.google.com/forum/#!msg/golang-dev/FTMScX1fsYk/uEUSjBAHAwAJ" target="_blank" rel="noopener">vgo &amp; vendoring</a> 的内容。默认如果开启了 go module 那么 <code>go build</code> 将会忽略 vendor 目录的内容，但是如果我们在编译的时候加上一个参数: <code>go build -mod=vendor</code> 则还是会优先查找 vendor 下的依赖。如果我们将在开发中的依赖放入 vendor 目录中，编译的时候加上这个 <code>mod=vendor</code> 参数则可以满足我们调试的需求。如果我们将 vendor 目录加入版本控制之外，则不会影响我们的正常开发和提交。</p>
</li>
</ol>
<h3 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h3><ul>
<li><code>go list -m [all]</code>: 列出当面 module, all 表示所有依赖的模块也列出来</li>
<li><code>go list -m -versions (package name)</code>: 列出某个依赖的所有版本</li>
</ul>
<h3 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h3><p>清除一些编译的缓存文件，go moduels 之后加了一个新参数: <code>-modcache</code>, 如果执行:<br><code>go clean -modcache</code> 则会清楚所有$GOPATH/pkg/mod 目录下的已经下载的依赖文件，这个在一些第三方依赖存在错误，或者校验失败的情况下可以使用。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">Semantic Import Versioning</a></li>
<li><a href="https://blog.golang.org/versioning-proposal" target="_blank" rel="noopener">A Proposal for Package Versioning in Go</a></li>
<li><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">Using Go Modules</a></li>
<li><a href="https://blog.golang.org/migrating-to-go-modules" target="_blank" rel="noopener">Migrating to Go Modules</a></li>
<li><a href="https://blog.golang.org/publishing-go-modules" target="_blank" rel="noopener">Publishing Go Modules</a></li>
<li><a href="https://blog.golang.org/v2-go-modules" target="_blank" rel="noopener">Go Modules: v2 and Beyond </a></li>
<li><a href="https://semver.org/" target="_blank" rel="noopener">Semantic Versioning 2.0.0</a></li>
<li><a href="https://research.swtch.com/deps" target="_blank" rel="noopener">Our Software Dependency Problem</a></li>
<li><a href="https://go.googlesource.com/proposal/+/master/design/25719-go15vendor.md" target="_blank" rel="noopener">Go 1.5 Vendor Experiment</a></li>
<li><a href="https://divan.dev/posts/gopath/" target="_blank" rel="noopener">I still love you , GOPATH</a></li>
<li><a href="https://go.googlesource.com/go/+refs" target="_blank" rel="noopener">Go source code</a></li>
<li><a href="https://medium.com/@freeformz/go-1-5-s-vendor-experiment-fd3e830f52c3" target="_blank" rel="noopener">Go 1.5’s vendor/ experiment</a></li>
<li><a href="https://blog.gopheracademy.com/advent-2015/vendor-folder/" target="_blank" rel="noopener">Understanding and using the vendor folder</a></li>
<li><a href="https://github.com/golang/go/wiki/vgo" target="_blank" rel="noopener">vgo</a></li>
<li><a href="https://groups.google.com/forum/#!msg/go-package-management/a55P0_FU_jA/Y9t_mBroBwAJ" target="_blank" rel="noopener">Dependency Management session at GopherCon</a></li>
<li><a href="https://docs.google.com/document/d/18tNd8r5DV0yluCR7tPvkMTsWD_lYcRO7NhpNSDymRr8/edit" target="_blank" rel="noopener">Go Packaging Proposal Process</a></li>
<li><a href="https://github.com/golang/go/issues/24301" target="_blank" rel="noopener">add package version support to Go toolchain</a></li>
<li><a href="https://docs.google.com/document/d/1xMJ0c-YxvcgNglzjbALzncs5_Acr0MST29oMf9TkgQI/edit" target="_blank" rel="noopener">Vendoring discussion at GopherCon</a></li>
<li><a href="https://www.hyrumslaw.com/" target="_blank" rel="noopener">Hyrum’s law</a>:</li>
<li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">Go 1.11 Modules wiki</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/11/25/go-context/"><span>go context</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/11/25/go-context/" rel="bookmark">
        <time class="entry-date published" datetime="2019-11-25T10:42:54.000Z">
          2019-11-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Contex-的作用"><a href="#Contex-的作用" class="headerlink" title="Contex 的作用"></a>Contex 的作用</h1><p>在 Go 服务器中, 每个请求都是由一个独立的 goroutine 进行处理的。请求处理程序<br>往往会启动其它的 goroutine 来访问后端，比如数据库和 RPC 服务。 处理请求的<br>goroutine 通常需要访问特定的值，比如用户身份的标识，token, 请求的超时时间。<br>当一个请求被取消或者超时时，处理改请求的所有 goroutine 都应该迅速退出，这样<br>系统就可以回收他们正在使用的资源。</p>
<p>对于 Go 语言，由于是单进程的模式 goroutine 之间内存是共享的，那么 goroutine 是<br>如何获取自己的上下文数据的呢？对于一些多线程模式运行的语言中，比如 Java  可以<br>通过 ThreadLocal 来传递线程间的上下文，但是 Go 语言并不提倡这种模式，Go 语言中<br>你甚至无法知道 goroutine 的编号，一切都是 Go 自己帮你管理的。为了解决这个问题<br>Go 使用的就是传递 Context 参数。</p>
<p>这种方式是 Go 语言比较特殊的地方，也是很多人诟病的地方，如果你要传递上下文正规<br>的方式就是这种，Go 语言甚至规定了它的具体用法：</p>
<ol>
<li>不要把它放到一个结构体中, 而是在需要的地方直接传递它</li>
<li>放到函数的第一个参数中，并且命名为 ctx</li>
</ol>
<p>对于第一个限制，后面会详细讲解其原因。</p>
<h1 id="Context-结构"><a href="#Context-结构" class="headerlink" title="Context 结构"></a>Context 结构</h1><p>Context 本质上是为了传递上下文，这个上下文不止是一些变量，还包括传递事件。<br>下面我们给一个使用的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ctx1 := context.Background()</span><br><span class="line"></span><br><span class="line">        ctx2, _ := context.WithCancel(ctx1)</span><br><span class="line">        ctx3, _ := context.WithCancel(ctx1)</span><br><span class="line"></span><br><span class="line">        ctx4, _ := context.WithCancel(ctx2)</span><br><span class="line">        ctx5, _ := context.WithCancel(ctx2)</span><br><span class="line"></span><br><span class="line">        ctx6, _ := context.WithCancel(ctx3)</span><br><span class="line">        ctx7, _ := context.WithCancel(ctx3)</span><br><span class="line"></span><br><span class="line">        ctx8, _ := context.WithCancel(ctx4)</span><br><span class="line">        ctx9, _ := context.WithCancel(ctx4)</span><br><span class="line"></span><br><span class="line">        ctx10, _ := context.WithCancel(ctx5)</span><br><span class="line">        ctx11, _ := context.WithCancel(ctx5)</span><br><span class="line"></span><br><span class="line">        ctx12, _ := context.WithCancel(ctx6)</span><br><span class="line">        ctx13, _ := context.WithCancel(ctx6)</span><br><span class="line"></span><br><span class="line">        ctx14, _ := context.WithCancel(ctx7)</span><br><span class="line">        ctx15, _ := context.WithCancel(ctx7)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(ctx8)</span><br><span class="line">        <span class="built_in">println</span>(ctx9)</span><br><span class="line">        <span class="built_in">println</span>(ctx10)</span><br><span class="line">        <span class="built_in">println</span>(ctx11)</span><br><span class="line">        <span class="built_in">println</span>(ctx12)</span><br><span class="line">        <span class="built_in">println</span>(ctx13)</span><br><span class="line">        <span class="built_in">println</span>(ctx14)</span><br><span class="line">        <span class="built_in">println</span>(ctx15)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前面这个例子，最终会形成一个 Context 的树形结构，结构如下：</p>
<p><img src="/assets/img/go/context/context_tree.svg" alt></p>
<h2 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h2><p>前面的结构中 <code>ctx1</code> 是根节点, 根节点通过 <code>context.Background()</code>  函数创建的，<br>函数源码如下: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">        todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到根节点是一个 <code>emptyCtx</code> 类型的数据,  这个结构实现了 <code>Context</code> 接口:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line"> Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> Err() error</span><br><span class="line"> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到 <code>emptyCtx</code> 实现很简单，基本都是返回 <code>nil</code>。对于根节点来说它并不能够<br>真正的传递一些信息和事件，其它的 context 则是依赖这个作为根节点来实现的。</p>
<h2 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h2><h3 id="树的建立"><a href="#树的建立" class="headerlink" title="树的建立"></a>树的建立</h3><p>cancelCtx 是一个可以传递 cancel 事件的 context， 通过 <code>WithCancel</code> 函数可以获取<br>一个 cancelCtx 类型的结构，并且还会返回它对应的 cancel 函数，当我们调用这个函数<br>时就会把事件传递到这个结构及他的所有子节点。源码实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">        c := newCancelCtx(parent) <span class="comment">// 新建一个 cancelCtx</span></span><br><span class="line">        propagateCancel(parent, &amp;c) <span class="comment">// 把当前新节点放到 parent 的子节点中</span></span><br><span class="line">        <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125; <span class="comment">// 返回 cancel 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>newCancelCtx</code> 函数我们把当前节点的 <code>Context</code> 字段指向了 <code>parent</code>, 也就是父节点。</p>
<p>通过调用 <code>propagateCancel</code> 函数我们可以把当前新建的节点放到对应的 context 树中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123; <span class="comment">// 对于 parent.Done() == nil 直接返回，</span></span><br><span class="line">                                  <span class="comment">// 因为这个节点是空节点, 没有 children 字段</span></span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">                p.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// parent has already been canceled</span></span><br><span class="line">                        child.cancel(<span class="literal">false</span>, p.err) <span class="comment">// 如果父节点存在错误信息，</span></span><br><span class="line">                                                   <span class="comment">// 证明父节点已经被取消，那么子节点也应该取消</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                        p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 放入子节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                p.mu.Unlock()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">                        <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于根节点，执行到下面这里就会返回:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是根节点是没有 <code>children</code> 字段的, 无法通过根节点查找子节点, 但是子节点<br>可以通过 <code>Context</code> 字段找到父节点。</p>
<p>我们再看另一种情况 <code>ctx4</code> 是如何挂载到 <code>ctx2</code>。前面的操作基本都一致，但是会走到<br>下面这段逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// parent has already been canceled</span></span><br><span class="line">                child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                        p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用 <code>parentCancelCtx</code> 函数判断父节点的类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">                        <span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">                <span class="keyword">case</span> *timerCtx:</span><br><span class="line">                        <span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">                <span class="keyword">case</span> *valueCtx:</span><br><span class="line">                        parent = c.Context</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>cancelCtx</code>, <code>timerCtx</code> 这些类型会返回 true, 然后判断父节点是否已经有错误信息，<br>如果有错误信息表示父节点已经调用了 cancel, 那么为了传播这个事件，子节点也应该调用<br>cancel, 对于没有 cancel 的父节点则把当前节点放到父节点的 children 结构中。</p>
<p>如果 <code>parentCancelCtx</code> 返回 false 呢？也就是不属于前面几种类型。这个跟前面解释的 context<br>的使用原则: “1. 不要把它放到一个结构体中, 而是在需要的地方直接传递它” 相关的，也就是当我们<br>把 context 放到结构体中进行传递则会满足这个条件，走到下面的逻辑: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">        &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>会开起一个新的 goroutine 来监听这个节点，而不会放到树中。 可以看出其实是监听了父节点和<br>本身节点, 因为如果父节点 cancel 了，子节点也需要 cancel ，因为父节点的事件要传播到子节点;<br>本身节点也是需要监听，调用 cancel 后也要结束这个 goroutine，如果不监听则需要依赖父节点，<br>如果父节点不接受这个节点即使调用了 cancel 也无法结束，所以两者缺一不可。</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>前面说 <code>WithCancel</code> 函数会返回一个 <code>cancel</code> 函数，如果我们调用的话会传递这个消息到所有的<br>子节点中。 我们修改一下前面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ctx4, cancel4 := context.WithCancel(ctx2)</span><br><span class="line">cancel4()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当我调用 <code>cancel4()</code>, 其实调用的是 <code>cancel(true, err)</code>, 第一个参数传 true 表示需要从树中<br>删除其子节点，第二个参数传取消的错误信息。 具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">                c.mu.Unlock()</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.err = err</span><br><span class="line">        <span class="comment">// 通过 chan 传递给所有监听的程序</span></span><br><span class="line">        <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">                c.done = closedchan</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">close</span>(c.done)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归传递消息给所有子节点</span></span><br><span class="line">        <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">                child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        c.children = <span class="literal">nil</span></span><br><span class="line">        c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从树中删除子节点</span></span><br><span class="line">        <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">                removeChild(c.Context, c)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cancel</code> 函数主要是有三个作用:</p>
<ol>
<li><p>通过 close(chan) 传递给所有的监听的程序这个消息<br>监听的程序如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">                c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        d := c.done</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息传递个所有子节点，所有监听子节点的程序也收到消息</p>
</li>
<li>把当前子节点机器及其下面的所有节点从树中删除</li>
</ol>
<p>前面可以看出消息传递给子节点的时候调用了 <code>cancel</code> 函数，但是第一个参数传递的是 <code>false</code>,<br>为什么呢? 显然后面把当前节点的子节点已经删除了,  没有必要在对其所有下面的节点执行<br>删除操作了, 否则就是重复删除。</p>
<p>下面用图来表示, 首先是消息的传播，红色表示收到了消息的节点:</p>
<p><img src="/assets/img/go/context/context_tree_cancel.svg" alt></p>
<p>然后把节点从树中删除:</p>
<p><img src="/assets/img/go/context/context_tree_remove.svg" alt></p>
<h2 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h2><p>timerCtx  是跟时间相关的 Contex, 可以通过这个设置过期时间，并且传播消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">        cancelCtx</span><br><span class="line">        timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">        deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想新建一个 timerCtx 需要通过 <code>WithDeadline</code> 函数(也可以通过 <code>WithTimeout</code>， 但这个<br>函数其实是 <code>WithDeadline</code> 的包装调用，无需详细讲解), 第一个参数是父节点，第二个参数是<br>过期时间。 源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">       <span class="comment">// 由于父节点的过期时间比子节点的早，不需要单独设置过期,可以直接返回</span></span><br><span class="line">        <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">                <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">                <span class="keyword">return</span> WithCancel(parent) </span><br><span class="line">        &#125;</span><br><span class="line">        c := &amp;timerCtx&#123;</span><br><span class="line">                cancelCtx: newCancelCtx(parent),</span><br><span class="line">                deadline:  d,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建context 树</span></span><br><span class="line">        propagateCancel(parent, c)</span><br><span class="line">        dur := time.Until(d)</span><br><span class="line">       <span class="comment">// 已经过了过期时间，直接返回, 不需要设置过期时间</span></span><br><span class="line">        <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">                c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">                <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">        <span class="comment">// 设置过期时间，在过期时间会调用 cancel 函数</span></span><br><span class="line">        <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">                c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回取消函数</span></span><br><span class="line">        <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现由很多优化的地方，首先对于设置的过期时间会和父节点进行比较，如果父节点过期<br>时间比当前节点的过期时间早，则直接返回一个 cancelCtx, 不需要设置过期时间，因为父节点肯定<br>比子节点过期的早，会触发消息的传递，然后传递个子节点，子节点没有机会执行自己的消息传递。<br>其次，计算完时间后，如果发现已经过期了，直接调用子节点的 cancel 函数，这时已经出发了消息<br>传递。 上面两个条件都不满足，则会调用 <code>time.AfterFunc</code> 函数设置一个时间，到这个时间后会<br>主动调用 cancel 函数进行消息的传播。</p>
<p>函数也会返回对应的 cancel 函数，我们也可以主动调用, 这个函数实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">        c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">        <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">                <span class="comment">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class="line">                removeChild(c.cancelCtx.Context, c)</span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">                c.timer.Stop()</span><br><span class="line">                c.timer = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际调用了 <code>cancelCtx</code>的 cancel 函数, 还有一点要注意这里调用了<code>c.timer.Stop()</code>,<br>这里是如果主动调用了 cancel 函数，则其对应的计时器就没有作用了，应该提前停止，这样<br>可以主动释放资源。</p>
<h2 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h2><p>前面讲的都是如何利用 context 传递消息，这里讲的是如何通过 context 传递数据。<br>context 的数据传递是通过 <code>valueCtx</code> 来完成的，他的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">        Context</span><br><span class="line">        key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是包含了 一对 key, val</p>
<p>valueCtx 的生成是通过 <code>WithValue</code> 来实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断类型是否可以使用 ==  比较</span></span><br><span class="line">        <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断当前的 key 是否可以使用 == 判断相等(这个定义在 <code>runtime/alg.go</code>中<br>可以看到, 这里不是重点就不介绍了)。 然后返回一个 <code>valueCtx</code> 结构。<code>valueCtx</code><br>的 <code>Context</code> 字段指向的是父节点。</p>
<p><code>valueCtx</code> 实现的也是一个树结构, 但是跟前面的 <code>cancelCtx</code> 不同，这里的 <code>valueCtx</code><br>没有指向子节点的指针，只有指向父节点的指针，也就是说只能子节点访问父节点，父节点<br>无法方位子节点。</p>
<p>通过 <code>WithValue</code> 可以给一个 <code>valueCtx</code> 设置 key 和 value, 这样就能携带一些信息。<br>构建的树如下：</p>
<img src="http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuN9AJCvEByelpKjHiD7LLIXBp2bDTIwfCCGbOSG5Lu8YRen3t0GkReGYRef3t8oBApyfApMvH07XW6gkMfWWmf9gBkVyl9BKYXAkxDHAY66Ooeo8KsPCd38JufIP4gVC38SoXzIy563C0000">
<p>对于 valueCtx, 我们通过 <code>Value</code> 函数来获取这个信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">                <span class="keyword">return</span> c.val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到如何当前的 key 匹配到了,则返回对应的值，如果没有找打则会寻找父节点，这样递归的往上找，<br>直到不是 <code>valueCtx</code> 的节点, 返回 nil。 可见 value 的查找是非常低效的。最重要的是当你使用 context<br>传递数据时，可能会滥用，比如在过渡依赖 context, 在各个地方都会设置值:</p>
<ol>
<li>查找的时候不一定会从哪个节点开始，如果从父节点查找，而值存在子节点你是查找不到的</li>
<li>如果 key 一致可能会无意中覆盖原来的值</li>
<li>如果多个几点都有查找的 key, 那么查找的结果不一定会是哪一个</li>
</ol>
<p>对于 key 的限制，golint 有一条规则 : <code>should not use basic type %s as key in context.WithValue</code><br>哪些是基本类型呢？golint 中定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicTypeKinds = <span class="keyword">map</span>[types.BasicKind]<span class="keyword">string</span>&#123;</span><br><span class="line">    types.UntypedBool:    <span class="string">"bool"</span>,</span><br><span class="line">    types.UntypedInt:     <span class="string">"int"</span>,</span><br><span class="line">    types.UntypedRune:    <span class="string">"rune"</span>,</span><br><span class="line">    types.UntypedFloat:   <span class="string">"float64"</span>,</span><br><span class="line">    types.UntypedComplex: <span class="string">"complex128"</span>,</span><br><span class="line">    types.UntypedString:  <span class="string">"string"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是因为对于基本类型而言，复制会出现覆盖，查找出现不确定的情况。一般情况下建议<br>使用一些自定义类型作为 key, 避免与其他的key冲突。</p>
<h1 id="数据结构之间的关系："><a href="#数据结构之间的关系：" class="headerlink" title="数据结构之间的关系："></a>数据结构之间的关系：</h1><p>前面讲了 context 中好几种数据结构及其实现，其实他们之间是有这非常紧密的联系的，<br>为了更加直观的看出的他们的关系，这里用一张图来表示：</p>
<img src="http://www.plantuml.com/plantuml/svg/TT513i8W40NGFQTWgIRr0CPTzGGcxWaTbOHIGz3KnCDBfKC_67VqGVxCT8mBv2zAaso7U1o3C5cqSfeiUI74V2btya3AMkDejKOSAZXwNtoVbNrCBmHdHal7Y61paA3-7bvj62ETWZVk6X4Cca0TQabj0EG-Wkd9vx1k3WFDPS5Ie_7yYyjiHIz8gHcKN0EHzu2cRyPsdbo9kV1pcggA1EEXWRW8h7R_tcub_wfbm4tJmDnvLT_NYnSXVvZBLo5SINm0">
<p>这些结构体基本上都实现了 Context 接口，但是一般每个结构的侧重不一样，对于一些<br>接口的函数都是默认的实现。 比如 <code>cancelCtx</code> 并没有定义 <code>Value</code> 函数, <code>valueCtx</code><br>也没有具体实现 <code>Done</code>, 这些函数是什么都不做的。</p>
<h1 id="context-使用举例"><a href="#context-使用举例" class="headerlink" title="context 使用举例"></a>context 使用举例</h1><p> 对于 context 的使用 context 包里有说明：</p>
<ul>
<li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li>
<li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li>
<li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。<br>例如：登陆的 session、cookie 等。</li>
<li>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</li>
</ul>
<p>context 的使用常见主要有以下几个。下面分别做一下介绍。</p>
<h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><p>在 web 开发中，我们为了串联整个请求的路径，会在日志中记录每条请求的唯一 id, 并且在访问下游服务<br>的时候把这个 id 传递下去。通过这个 id, 我们就能够对本次请求的路径进行了解，并且在遇到问题的时候<br>很好的定位在哪一步出现了问题。下面我们使用 context 来传递这个数据:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> traceType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ctx := context.Background()</span><br><span class="line">        ctx = context.WithValue(ctx, traceType(<span class="string">"traceId"</span>), rand.Int())</span><br><span class="line">        process(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        traceID, ok := ctx.Value(traceType(<span class="string">"traceId"</span>)).(<span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"traceType traceID=%d\n"</span>, traceID)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"no traceType tranceID"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceID, ok = ctx.Value(<span class="string">"traceId"</span>).(<span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"string type traceID=%d\n"</span>, traceID)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"no string type tranceID"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意一点，<code>WithValue</code> 的 key 使用的是自定义的类型 <code>traceType</code> 而不是基本类型 <code>string</code>,<br>避免了查找冲突和覆盖的问题。所以输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traceType traceID=5577006791947779410</span><br><span class="line">no string type tranceID</span><br></pre></td></tr></table></figure></p>
<p>在实际的开发中我们要需要在 server 端给每个请求都加上这个 ID, 这个数据优先是从 HEADER 里传过来。<br>所以一般实际业务中我们这么写：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> requestType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> traceID = requestType(<span class="string">"traceID"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        h := hand&#123;&#125;</span><br><span class="line">        http.HandleFunc(<span class="string">"/hi"</span>, hi)</span><br><span class="line">        http.ListenAndServe(<span class="string">":8000"</span>, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hand)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        v := req.Header.Get(<span class="string">"X-TRACE-ID"</span>)</span><br><span class="line">        ctx := context.WithValue(req.Context(), traceID, v)</span><br><span class="line">        reqCtx := req.WithContext(ctx)</span><br><span class="line"></span><br><span class="line">        http.DefaultServeMux.ServeHTTP(rw, reqCtx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hi</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        v := req.Context().Value(traceID).(<span class="keyword">string</span>)</span><br><span class="line">        resp := fmt.Sprintf(<span class="string">"traceID = %s\n"</span>, v)</span><br><span class="line">        fmt.Fprintf(rw, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="防止-goroutine-泄露"><a href="#防止-goroutine-泄露" class="headerlink" title="防止 goroutine 泄露"></a>防止 goroutine 泄露</h2><p>参考文献中的例子:<br>有一个 goroutine 往 chan 发送信息:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gen is a broken generator that will leak a goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ch &lt;- n</span><br><span class="line">            n++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用这个函数，当信息发送次数等于 5 就停止运行:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The call site of gen doesn't have a </span></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen() &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>停止运行后有一个问题，就是 gen 函数里的 goroutine 会一直存在，不会退出。<br>这样就照成了 goroutine 泄露，下面我们利用 context 改进一下这个程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gen is a generator that can be cancellable by cancelling the ctx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// avoid leaking of this goroutine when ctx is done.</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">                n++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入了 context 参数，for 循环利用 select 监听取消的消息。调用的程序也改进了。<br>当 接收5次消息后会调用  cancel 函数发送消息，这样前面的 gen 就能够及时退出了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// make sure all paths cancel the context to avoid context leak</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">        cancel()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>超时控制也是用的比较多的场景。在实际的工作场景中，我们对外提供服务要保证服务的可用性，<br>可用性的一个指标是响应时间。 一般上游访问我们都会有一个超时时间，当过了这个超时时间<br>上游就会结束访问，认为这次请求失败了，这时如果我们的服务还在处理响应的请求已经没有必要<br>了，所以我们应该及时退出，尽快回收资源，提高程序的性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"context"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        http.HandleFunc(<span class="string">"/hi"</span>, hi)</span><br><span class="line">        http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hi</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        ctx, cancel := context.WithTimeout(req.Context(), time.Millisecond*<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">defer</span> cancel()</span><br><span class="line">        reqCtx := req.WithContext(ctx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-reqCtx.Context().Done():</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">                        <span class="comment">// do something</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，如果已经进入了业务的处理内部，无法再回到 select 的阶段是无法取消这个<br>goroutine 的，也就是只有提前检查，或者周期性的检测才能使用。 </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.golang.org/context" target="_blank" rel="noopener">Go Concurrency Patterns: Context</a><br><a href="https://mp.weixin.qq.com/s/GpVy1eB5Cz_t-dhVC6BJNw" target="_blank" rel="noopener">深度解密Go语言之context</a><br><a href="https://rakyll.org/leakingctx/" target="_blank" rel="noopener">Using contexts to avoid leaking goroutines</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/10/21/etcd-server-md/"><span>etcd server 启动</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/10/21/etcd-server-md/" rel="bookmark">
        <time class="entry-date published" datetime="2019-10-21T03:01:48.000Z">
          2019-10-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>文件入口:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"go.etcd.io/etcd/etcdmain"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    etcdmain.Main()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="开始启动过程"><a href="#开始启动过程" class="headerlink" title="开始启动过程"></a>开始启动过程</h2><ol>
<li>平台支持检查</li>
<li>启动参数解析</li>
<li>启动服务或者 proxy</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// etcdmain/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查支持的平台</span></span><br><span class="line">    checkSupportArch()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数解析</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        cmd := os.Args[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> covArgs := os.Getenv(<span class="string">"ETCDCOV_ARGS"</span>); <span class="built_in">len</span>(covArgs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            args := strings.Split(os.Getenv(<span class="string">"ETCDCOV_ARGS"</span>), <span class="string">"\xe7\xcd"</span>)[<span class="number">1</span>:]</span><br><span class="line">            rootCmd.SetArgs(args)</span><br><span class="line">            cmd = <span class="string">"grpc-proxy"</span> <span class="comment">// 如果设置了 ETCDCOV_ARGS 环境变量，就是以 grpc-proxy 方式启动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> cmd &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"gateway"</span>, <span class="string">"grpc-proxy"</span>: <span class="comment">// 如果设置了 cmd变量，就以变量的形式启动,包括 gateway, grpc-proxy 两种方式</span></span><br><span class="line">            <span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123; <span class="comment">// rootCmd.Execute 就等于调用 `etcd gateway` 或者 `etcd grpc-proxy`, 其它的参数不支持，调用的是 `etcd`</span></span><br><span class="line">                fmt.Fprint(os.Stderr, err)</span><br><span class="line">                os.Exit(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startEtcdOrProxyV2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置检查-amp-启动-etcdServer"><a href="#配置检查-amp-启动-etcdServer" class="headerlink" title="配置检查 &amp; 启动 etcdServer"></a>配置检查 &amp; 启动 etcdServer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// etcdmain/etcd.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startEtcdOrProxyV2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    grpc.EnableTracing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    cfg := newConfig()                             <span class="comment">// 默认配置项</span></span><br><span class="line">    defaultInitialCluster := cfg.ec.InitialCluster <span class="comment">// 对应配置文件中的 ETCD_INITIAL_CLUSTER 变量，默认的集群节点配置</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        logger := cfg.ec.GetLogger()</span><br><span class="line">        <span class="keyword">if</span> logger != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Sync()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新修改一下 cluster 配置中的 cluster 相关的信息，比如获取当前计算机的 hostname 代替 0.0.0.0 或 localhost</span></span><br><span class="line">    defaultHost, dhErr := (&amp;cfg.ec).UpdateDefaultClusterFromName(defaultInitialCluster)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stopped &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> errc &lt;-<span class="keyword">chan</span> error</span><br><span class="line"></span><br><span class="line">    which := identifyDataDirOrDie(cfg.ec.GetLogger(), cfg.ec.Dir) <span class="comment">// 检查存储数据的目录, 返回数据存储的类型是成员还是 proxy 等</span></span><br><span class="line">    <span class="keyword">if</span> which != dirEmpty &#123;                                        <span class="comment">// 节点目录不为空，证明不是第一次使用，恢复之前的配置</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> which &#123;</span><br><span class="line">        <span class="keyword">case</span> dirMember: <span class="comment">// 如果是成员类型，需要开启一个 etcd 服务</span></span><br><span class="line">            stopped, errc, err = startEtcd(&amp;cfg.ec)</span><br><span class="line">        <span class="keyword">case</span> dirProxy: <span class="comment">// 如果是proxy, 则开启一个 proxy 服务</span></span><br><span class="line">            err = startProxy(cfg)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果为空，则根据参数启动服务</span></span><br><span class="line">        shouldProxy := cfg.isProxy()</span><br><span class="line">        <span class="keyword">if</span> !shouldProxy &#123; <span class="comment">// 如果不是 proxy, 则启动一个正常的 server</span></span><br><span class="line">            stopped, errc, err = startEtcd(&amp;cfg.ec)</span><br><span class="line">            <span class="keyword">if</span> derr, ok := err.(*etcdserver.DiscoveryError); ok &amp;&amp; derr.Err == v2discovery.ErrFullCluster &#123;</span><br><span class="line">                <span class="keyword">if</span> cfg.shouldFallbackToProxy() &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    shouldProxy = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> shouldProxy &#123; <span class="comment">// 如果是 proxy ,则启动一个 proxy 服务</span></span><br><span class="line">            err = startProxy(cfg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    osutil.HandleInterrupts(lg) <span class="comment">// 接收外界信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point, the initialization of etcd is done.</span></span><br><span class="line">    <span class="comment">// The listeners are listening on the TCP ports and ready</span></span><br><span class="line">    <span class="comment">// for accepting connections. The etcd instance should be</span></span><br><span class="line">    <span class="comment">// joined with the cluster and ready to serve incoming</span></span><br><span class="line">    <span class="comment">// connections.</span></span><br><span class="line">    notifySystemd(lg) <span class="comment">// 把型号发送给正在运行的 etcd 守护进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123; <span class="comment">// 进入阻塞状态，除非出现错误或者服务关闭</span></span><br><span class="line">    <span class="keyword">case</span> lerr := &lt;-errc:</span><br><span class="line">        <span class="comment">// fatal out on listener errors</span></span><br><span class="line">        <span class="keyword">if</span> lg != <span class="literal">nil</span> &#123;</span><br><span class="line">            lg.Fatal(<span class="string">"listener failed"</span>, zap.Error(lerr))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            plog.Fatal(lerr)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopped:</span><br><span class="line">    &#125;</span><br><span class="line">    osutil.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startEtcd runs StartEtcd in addition to hooks needed for standalone etcd.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startEtcd</span><span class="params">(cfg *embed.Config)</span> <span class="params">(&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> error, error)</span></span> &#123;</span><br><span class="line">    e, err := embed.StartEtcd(cfg) <span class="comment">// 根据配置开启一个 etcd server</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    osutil.RegisterInterruptHandler(e.Close) <span class="comment">// 注册通过信号关闭时的回调函数</span></span><br><span class="line">    <span class="keyword">select</span> &#123;                                 <span class="comment">// 进入阻塞,除非接收到下面的信号</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-e.Server.ReadyNotify(): <span class="comment">// wait for e.Server to join the cluster  阻塞，直到当前 server 注册到了集群中</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-e.Server.StopNotify(): <span class="comment">// publish aborted from 'ErrStopped' 注册失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.Server.StopNotify(), e.Err(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开启-peer-client-和-metrics-server"><a href="#开启-peer-client-和-metrics-server" class="headerlink" title="开启 peer , client 和 metrics server"></a>开启 peer , client 和 metrics server</h2><ol>
<li>etcd Server 启动会开起多个 server</li>
<li>peer server 用于 etcd 集群之间的选举，探活, 默认端口 2380</li>
<li>client 用于监听客户端请求，处理客户端读写, 默认端口 2379</li>
<li>metrics  用户监控集群状态，需要手动指定端口，否则不开启</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// embed/etcd.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StartEtcd 回开启一个 etcd server, 并且接收 HTTP 请求，但是这个函数并不会保证加入到了集群中</span></span><br><span class="line"><span class="comment">// 加入集群是由  Etcd.Server.ReadyNotify() 来实现的</span></span><br><span class="line"><span class="comment">// StartEtcd launches the etcd server and HTTP handlers for client/server communication.</span></span><br><span class="line"><span class="comment">// The returned Etcd.Server is not guaranteed to have joined the cluster. Wait</span></span><br><span class="line"><span class="comment">// on the Etcd.Server.ReadyNotify() channel to know when it completes and is ready for use.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartEtcd</span><span class="params">(inCfg *Config)</span> <span class="params">(e *Etcd, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err = inCfg.Validate(); err != <span class="literal">nil</span> &#123; <span class="comment">// 检查一些参数是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    serving := <span class="literal">false</span></span><br><span class="line">    e = &amp;Etcd&#123;cfg: *inCfg, stopc: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">    cfg := &amp;e.cfg</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">nil</span> || err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !serving &#123;</span><br><span class="line">            <span class="comment">// errored before starting gRPC server for serveCtx.serversC</span></span><br><span class="line">            <span class="keyword">for</span> _, sctx := <span class="keyword">range</span> e.sctxs &#123;</span><br><span class="line">                <span class="built_in">close</span>(sctx.serversC)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.Close()</span><br><span class="line">        e = <span class="literal">nil</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 开启 peer server, 默认端口 2380</span></span><br><span class="line">    <span class="keyword">if</span> e.Peers, err = configurePeerListeners(cfg); err != <span class="literal">nil</span> &#123; <span class="comment">// 节点数据赋值</span></span><br><span class="line">        <span class="keyword">return</span> e, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启 client server,  默认端口 2379，并且支持多协议(grpc,http, https)</span></span><br><span class="line">    <span class="keyword">if</span> e.sctxs, err = configureClientListeners(cfg); err != <span class="literal">nil</span> &#123; <span class="comment">// client 数据赋值</span></span><br><span class="line">        <span class="keyword">return</span> e, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, sctx := <span class="keyword">range</span> e.sctxs &#123; <span class="comment">// 当前 server ctx 记录</span></span><br><span class="line">        e.Clients = <span class="built_in">append</span>(e.Clients, sctx.l)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 token</span></span><br><span class="line">    memberInitialized := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> !isMemberInitialized(cfg) &#123;</span><br><span class="line">        memberInitialized = <span class="literal">false</span></span><br><span class="line">        urlsmap, token, err = cfg.PeerURLsMapAndToken(<span class="string">"etcd"</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e, fmt.Errorf(<span class="string">"error setting up initial cluster: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AutoCompactionRetention defaults to "0" if not set.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cfg.AutoCompactionRetention) == <span class="number">0</span> &#123;</span><br><span class="line">        cfg.AutoCompactionRetention = <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    autoCompactionRetention, err := parseCompactionRetention(cfg.AutoCompactionMode, cfg.AutoCompactionRetention)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backendFreelistType := parseBackendFreelistType(cfg.ExperimentalBackendFreelistType)</span><br><span class="line">    <span class="comment">// 根据配置新建一个 server 对象</span></span><br><span class="line">    <span class="keyword">if</span> e.Server, err = etcdserver.NewServer(srvcfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer channel 保证服务关闭的时候不会阻塞</span></span><br><span class="line">    <span class="comment">// buffer channel so goroutines on closed connections won't wait forever</span></span><br><span class="line">    e.errc = <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="built_in">len</span>(e.Peers)+<span class="built_in">len</span>(e.Clients)+<span class="number">2</span>*<span class="built_in">len</span>(e.sctxs))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newly started member ("memberInitialized==false")</span></span><br><span class="line">    <span class="comment">// does not need corruption check</span></span><br><span class="line">    <span class="keyword">if</span> memberInitialized &#123;</span><br><span class="line">        <span class="keyword">if</span> err = e.Server.CheckInitialHashKV(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// set "EtcdServer" to nil, so that it does not block on "EtcdServer.Close()"</span></span><br><span class="line">            <span class="comment">// (nothing to close since rafthttp transports have not been started)</span></span><br><span class="line">            e.Server = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">return</span> e, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e.Server.Start() <span class="comment">// 开启一个 etcd server</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与每个 peer 保持通信</span></span><br><span class="line">    <span class="keyword">if</span> err = e.servePeers(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  开启 server 与每个 client 保持通信, 可以同时支持多重协议</span></span><br><span class="line">    <span class="keyword">if</span> err = e.serveClients(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与每个 metrics 保持通信</span></span><br><span class="line">    <span class="keyword">if</span> err = e.serveMetrics(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e, err</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    serving = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> e, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>e.Server.Start()</code>函数实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start performs any initialization of the Server necessary for it to</span></span><br><span class="line"><span class="comment">// begin serving requests. It must be called before Do or Process.</span></span><br><span class="line"><span class="comment">// Start must be non-blocking; any long-running server functionality</span></span><br><span class="line"><span class="comment">// should be implemented in goroutines.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.start()</span><br><span class="line">    <span class="comment">// 下面的函数将在 server 关闭后等执行完成</span></span><br><span class="line">    s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.adjustTicks() &#125;)</span><br><span class="line">    s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.publish(s.Cfg.ReqTimeout()) &#125;)</span><br><span class="line">    s.goAttach(s.purgeFile)</span><br><span class="line">    s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; monitorFileDescriptor(s.getLogger(), s.stopping) &#125;)</span><br><span class="line">    s.goAttach(s.monitorVersions)</span><br><span class="line">    s.goAttach(s.linearizableReadLoop)</span><br><span class="line">    s.goAttach(s.monitorKVHash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start prepares and starts server in a new goroutine. It is no longer safe to</span></span><br><span class="line"><span class="comment">// modify a server's fields after it has been sent to Start.</span></span><br><span class="line"><span class="comment">// This function is just used for testing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过一个 goroutine 开启服务</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> if this is an empty log, writes all peer infos</span></span><br><span class="line">    <span class="comment">// into the first entry</span></span><br><span class="line">    <span class="keyword">go</span> s.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lg := s.getLogger()</span><br><span class="line">    sn, err := s.r.raftStorage.Snapshot()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// asynchronously accept apply packets, dispatch progress in-order</span></span><br><span class="line">    sched := schedule.NewFIFOScheduler()</span><br><span class="line">    ...</span><br><span class="line">    s.r.start(rh)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.wgMu.Lock() <span class="comment">// block concurrent waitgroup adds in goAttach while stopping</span></span><br><span class="line">        <span class="built_in">close</span>(s.stopping)</span><br><span class="line">        s.wgMu.Unlock()</span><br><span class="line">        s.cancel()</span><br><span class="line"></span><br><span class="line">        sched.Stop()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wait for gouroutines before closing raft so wal stays open</span></span><br><span class="line">        s.wg.Wait()</span><br><span class="line"></span><br><span class="line">        s.SyncTicker.Stop()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// must stop raft after scheduler-- etcdserver can leak rafthttp pipelines</span></span><br><span class="line">        <span class="comment">// by adding a peer after raft stops the transport</span></span><br><span class="line">        s.r.stop()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// kv, lessor and backend can be nil if running without v3 enabled</span></span><br><span class="line">        <span class="comment">// or running unit tests.</span></span><br><span class="line">        <span class="keyword">if</span> s.lessor != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.lessor.Stop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s.kv != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.kv.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s.authStore != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.authStore.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s.be != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.be.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s.compactor != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.compactor.Stop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(s.done)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> expiredLeaseC &lt;-<span class="keyword">chan</span> []*lease.Lease</span><br><span class="line">    <span class="keyword">if</span> s.lessor != <span class="literal">nil</span> &#123;</span><br><span class="line">        expiredLeaseC = s.lessor.ExpiredLeasesC()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ap := &lt;-s.r.apply(): <span class="comment">// 数据更新</span></span><br><span class="line">            f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line">            sched.Schedule(f)</span><br><span class="line">        <span class="keyword">case</span> leases := &lt;-expiredLeaseC: <span class="comment">// 租期过期处理</span></span><br><span class="line">            s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            ...</span><br><span class="line">             &#125;)</span><br><span class="line">        <span class="keyword">case</span> err := &lt;-s.errorc: <span class="comment">// 出现错误，退出 server</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-getSyncC(): <span class="comment">// 定期同步数据</span></span><br><span class="line">            <span class="keyword">if</span> s.v2store.HasTTLKeys() &#123;</span><br><span class="line">                s.sync(s.Cfg.ReqTimeout())</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-s.stop: <span class="comment">// 停止信号，停止 server</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// etcdserver/raft.go.start</span></span><br><span class="line"><span class="comment">// raft node 启动，保持心跳</span></span><br><span class="line"><span class="comment">// start prepares and starts raftNode in a new goroutine. It is no longer safe</span></span><br><span class="line"><span class="comment">// to modify the fields after it has been started.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raftNode)</span> <span class="title">start</span><span class="params">(rh *raftReadyHandler)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多协议支持"><a href="#多协议支持" class="headerlink" title="多协议支持"></a>多协议支持</h2><p>如何做到监听一个端口, 开启多个协议的 server 进行处理呢？ 借助 <code>github.com/soheilhy/cmux</code> 来完成的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Etcd)</span> <span class="title">serveClients</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !e.cfg.ClientTLSInfo.Empty() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.cfg.logger != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.cfg.logger.Info(</span><br><span class="line">                <span class="string">"starting with client TLS"</span>,</span><br><span class="line">                zap.String(<span class="string">"tls-info"</span>, fmt.Sprintf(<span class="string">"%+v"</span>, e.cfg.ClientTLSInfo)),</span><br><span class="line">                zap.Strings(<span class="string">"cipher-suites"</span>, e.cfg.CipherSuites),</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            plog.Infof(<span class="string">"ClientTLS: %s"</span>, e.cfg.ClientTLSInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a client server goroutine for each listen address</span></span><br><span class="line">    <span class="keyword">var</span> h http.Handler</span><br><span class="line">    <span class="keyword">if</span> e.Config().EnableV2 &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(e.Config().ExperimentalEnableV2V3) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            srv := v2v3.NewServer(e.cfg.logger, v3client.New(e.Server), e.cfg.ExperimentalEnableV2V3)</span><br><span class="line">            h = v2http.NewClientHandler(e.GetLogger(), srv, e.Server.Cfg.ReqTimeout())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = v2http.NewClientHandler(e.GetLogger(), e.Server, e.Server.Cfg.ReqTimeout())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mux := http.NewServeMux()</span><br><span class="line">        etcdhttp.HandleBasic(mux, e.Server)</span><br><span class="line">        h = mux</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gopts := []grpc.ServerOption&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> e.cfg.GRPCKeepAliveMinTime &gt; time.Duration(<span class="number">0</span>) &#123;</span><br><span class="line">        gopts = <span class="built_in">append</span>(gopts, grpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy&#123;</span><br><span class="line">            MinTime:             e.cfg.GRPCKeepAliveMinTime,</span><br><span class="line">            PermitWithoutStream: <span class="literal">false</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> e.cfg.GRPCKeepAliveInterval &gt; time.Duration(<span class="number">0</span>) &amp;&amp;</span><br><span class="line">        e.cfg.GRPCKeepAliveTimeout &gt; time.Duration(<span class="number">0</span>) &#123;</span><br><span class="line">        gopts = <span class="built_in">append</span>(gopts, grpc.KeepaliveParams(keepalive.ServerParameters&#123;</span><br><span class="line">            Time:    e.cfg.GRPCKeepAliveInterval,</span><br><span class="line">            Timeout: e.cfg.GRPCKeepAliveTimeout,</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start client servers in each goroutine</span></span><br><span class="line">    <span class="keyword">for</span> _, sctx := <span class="keyword">range</span> e.sctxs &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s *serveCtx)</span></span> &#123; <span class="comment">// 这里正式启动多个 client server， 包括不同的协议</span></span><br><span class="line">            e.errHandler(s.serve(e.Server, &amp;e.cfg.ClientTLSInfo, h, e.errHandler, gopts...))</span><br><span class="line">        &#125;(sctx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面函数中 s.serve 函数的实现</span></span><br><span class="line"><span class="comment">// serve accepts incoming connections on the listener l,</span></span><br><span class="line"><span class="comment">// creating a new service goroutine for each. The service goroutines</span></span><br><span class="line"><span class="comment">// read requests and then call handler to reply to them.</span></span><br><span class="line"><span class="comment">// 这里使用了 github.com/soheilhy/cmux 来实现链接复用器</span></span><br><span class="line"><span class="comment">// 同一个链接可以根据其协议分发到不同的 server 协议处理</span></span><br><span class="line"><span class="comment">// 支持 grpc, ssh, http, https等</span></span><br><span class="line"><span class="comment">// 同一个链接依次只能是一个协议</span></span><br><span class="line"><span class="comment">// 根据协议头的前几个字段来判断协议</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sctx *serveCtx)</span> <span class="title">serve</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    s *etcdserver.EtcdServer,</span></span></span><br><span class="line"><span class="function"><span class="params">    tlsinfo *transport.TLSInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    handler http.Handler,</span></span></span><br><span class="line"><span class="function"><span class="params">    errHandler <span class="keyword">func</span>(error)</span>,</span></span><br><span class="line"><span class="function">    <span class="title">gopts</span> ...<span class="title">grpc</span>.<span class="title">ServerOption</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    logger := defaultLog.New(ioutil.Discard, <span class="string">"etcdhttp"</span>, <span class="number">0</span>)</span><br><span class="line">    &lt;-s.ReadyNotify()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sctx.lg == <span class="literal">nil</span> &#123;</span><br><span class="line">        plog.Info(<span class="string">"ready to serve client requests"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := cmux.New(sctx.l)</span><br><span class="line">    v3c := v3client.New(s)</span><br><span class="line">    servElection := v3election.NewElectionServer(v3c)</span><br><span class="line">    servLock := v3lock.NewLockServer(v3c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gs *grpc.Server</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; gs != <span class="literal">nil</span> &#123;</span><br><span class="line">            gs.Stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// http 请求</span></span><br><span class="line">    <span class="keyword">if</span> sctx.insecure &#123;</span><br><span class="line">        gs = v3rpc.Server(s, <span class="literal">nil</span>, gopts...)</span><br><span class="line">        v3electionpb.RegisterElectionServer(gs, servElection)</span><br><span class="line">        v3lockpb.RegisterLockServer(gs, servLock)</span><br><span class="line">        <span class="keyword">if</span> sctx.serviceRegister != <span class="literal">nil</span> &#123;</span><br><span class="line">            sctx.serviceRegister(gs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配 HTTP2 协议</span></span><br><span class="line">        grpcl := m.Match(cmux.HTTP2())</span><br><span class="line">        <span class="comment">// 启动 grpc server</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errHandler(gs.Serve(grpcl)) &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> gwmux *gw.ServeMux</span><br><span class="line">        <span class="keyword">if</span> s.Cfg.EnableGRPCGateway &#123;</span><br><span class="line">            gwmux, err = sctx.registerGateway([]grpc.DialOption&#123;grpc.WithInsecure()&#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpmux := sctx.createMux(gwmux, handler)</span><br><span class="line"></span><br><span class="line">        srvhttp := &amp;http.Server&#123;</span><br><span class="line">            Handler:  createAccessController(sctx.lg, s, httpmux),</span><br><span class="line">            ErrorLog: logger, <span class="comment">// do not log user error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配 HTTP1 协议</span></span><br><span class="line">        httpl := m.Match(cmux.HTTP1())</span><br><span class="line">        <span class="comment">// 启动 client HTTP Server</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errHandler(srvhttp.Serve(httpl)) &#125;()</span><br><span class="line">        sctx.serversC &lt;- &amp;servers&#123;grpc: gs, http: srvhttp&#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// https 请求</span></span><br><span class="line">    <span class="keyword">if</span> sctx.secure &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sctx.serversC)</span><br><span class="line">    <span class="keyword">return</span> m.Serve()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/etcd-Go/">etcd Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/09/19/golang-sync-mutex/"><span>golang sync.mutex</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/09/19/golang-sync-mutex/" rel="bookmark">
        <time class="entry-date published" datetime="2019-09-19T07:58:18.000Z">
          2019-09-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>##</p>
<p>##</p>
<p>##</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// 1 = 0b001</span></span><br><span class="line">    mutexWoken                  <span class="comment">// 2 = 0b010</span></span><br><span class="line">    mutexStarving               <span class="comment">// 4 = 0b100</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>     <span class="comment">// 3  用来屏蔽低三位，取数量</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 10^6 ns = 1 ms</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// state</span><br><span class="line">   +-----------------------------+---+---+---+                          </span><br><span class="line">   |00000000000000000000000000000|0/1|0/1|0/1|                          </span><br><span class="line">   +-----------------------------+---+---+---+                          </span><br><span class="line">                  |                |   |   |                            </span><br><span class="line">                  |                |   |   |        +-----------+       </span><br><span class="line">                  |                |   |   +-------&gt;|mutexLocked|       </span><br><span class="line">                  |                |   |            +-----------+       </span><br><span class="line">                  |                |   |            +----------+        </span><br><span class="line">                  |                |   +-----------&gt;|mutexWoken|        </span><br><span class="line">                  |                |                +----------+        </span><br><span class="line">                  |                |                +-------------+     </span><br><span class="line">                  |                +---------------&gt;|mutexStarving|     </span><br><span class="line">                  |                                 +-------------+     </span><br><span class="line">                  |                                 +------------------+</span><br><span class="line">                  +--------------------------------&gt;| wait list count  |</span><br><span class="line">                                                    +------------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="keyword">int64</span> <span class="comment">// 开始等待锁的时间点</span></span><br><span class="line">    starving := <span class="literal">false</span> <span class="comment">// 当前 goroutine 是否处于饥饿状态</span></span><br><span class="line">    awoke := <span class="literal">false</span>    <span class="comment">// 当前 goroutine 是否被唤醒</span></span><br><span class="line">    iter := <span class="number">0</span>         <span class="comment">//</span></span><br><span class="line">    old := m.state    <span class="comment">// 当前锁的状态</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// Don't spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">        <span class="comment">// so we won't be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">// 饥饿模式不要自旋， 因为锁的所有权回直接交给 waiters, 所以我们不会获取到锁</span></span><br><span class="line">        <span class="comment">// 条件翻译为伪代码: isLocked() &amp;&amp; isNotStarving() &amp;&amp; canSpin() </span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// Active spinning makes sense.</span></span><br><span class="line">            <span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">            <span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">            <span class="comment">//  尝试设置 mutexWoken  标志来通知 Unlock 不唤醒其它被阻塞的 goroutine</span></span><br><span class="line">            <span class="comment">//  条件可以转换为: 当前 goroutine 没有被唤醒     &amp;&amp; </span></span><br><span class="line">                                锁状态没有被唤醒              &amp;&amp; </span><br><span class="line">                                等待获取锁的 goroutine 不为 <span class="number">0</span> &amp;&amp; </span><br><span class="line">                                锁的状态改从未唤醒更新为 被唤醒</span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span> <span class="comment">// 设置当前 goroutine 为唤醒状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime_doSpin() <span class="comment">// 进入自旋</span></span><br><span class="line">            iter++</span><br><span class="line">            old = m.state <span class="comment">// 更新锁状态</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 经过上一步后，锁和状态的组合有下面几个:</span></span><br><span class="line">        <span class="comment">// 获取锁   + 正常模式</span></span><br><span class="line">        <span class="comment">// 获取锁   + 饥饿模式</span></span><br><span class="line">        <span class="comment">// 未获取锁 + 正常模式</span></span><br><span class="line">        <span class="comment">// 未获取锁 + 饥饿模式</span></span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// Don't try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">// 正常模式: 期望设置为获取锁</span></span><br><span class="line">        <span class="comment">// 如果是饥饿模式, 新来的 goroutine 必须放到锁队列尾部排队</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (锁被获取 || 饥饿模式): 等待锁的 goroutine 数量 +1</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">        <span class="comment">// But if the mutex is currently unlocked, don't do the switch.</span></span><br><span class="line">        <span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">        <span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">// 当前 gorutine 是（饥饿状态 &amp;&amp; 锁被获取): 期望设置锁状态为饥饿模式</span></span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 goroutine 处于被唤醒状态</span></span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">            <span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">            <span class="comment">// 如果锁状态为被唤醒状态，证明存在冲突</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  new 期望设置为非被唤醒状态</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新锁状态为  从 old 变为 new</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// old 原来锁状态不是被获取 &amp;&amp; 锁状态不是饥饿状态</span></span><br><span class="line">            <span class="comment">// 根据前面的条件 new 现在是获取锁状态</span></span><br><span class="line">            <span class="comment">// old 和 new 交换成功，所以当前 goroutine 获取到了锁, 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到这里: old 是被获取 || old 是饥饿状态</span></span><br><span class="line">            <span class="comment">// waitStartTime != 0 证明等待过, 否则未等待过</span></span><br><span class="line">            <span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span> <span class="comment">// true or false</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果等待过则放到锁队列头</span></span><br><span class="line">            <span class="comment">// 否则放到锁队列尾部</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 如果等待时间超过了 starvationThresholdNs (1ms), 则设置当前 goroutine 为饥饿模式</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">// 如果原来处于饥饿模式</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">                <span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">                <span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">                <span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">                <span class="comment">// 如果当前 goroutine 处于饥饿模式, 但是 mutex出一些冲突的状态: mutexLocked 状态没有设置，当前 goroutine 仍处于 waiter 中</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">// 当前 goroutine 不是饥饿状态 || 等待的 gorouine == 1, 退出饥饿模式</span></span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="comment">// 退出饥饿模式</span></span><br><span class="line">                    <span class="comment">// Exit starvation mode.</span></span><br><span class="line">                    <span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">                    <span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">                    <span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">                    <span class="comment">// to starvation mode.</span></span><br><span class="line">                    delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  等待队列数量 -1 &amp;&amp;  获取锁</span></span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            old = m.state <span class="comment">// 更新 state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">        race.Acquire(unsafe.Pointer(m))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// Lock locks m.</span><br><span class="line">// If the lock is already in use, the calling goroutine</span><br><span class="line">// blocks until the mutex is available.</span><br><span class="line">func (m *Mutex) Lock() &#123;</span><br><span class="line">	// Fast path: grab unlocked mutex.</span><br><span class="line">	if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) &#123;</span><br><span class="line">		if race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var waitStartTime int64 // 用来存当前goroutine等待的时间</span><br><span class="line">	starving := false       // 用来存当前goroutine是否饥饿</span><br><span class="line">	awoke := false          // 用来存当前goroutine是否已唤醒</span><br><span class="line">	iter := 0               // 用来存当前goroutine的循环次数(想一想一个goroutine如果循环了2147483648次咋办……)</span><br><span class="line">	old := m.state          // 复制一下当前锁的状态</span><br><span class="line">	for &#123; // 自旋</span><br><span class="line">		// 如果是饥饿情况之下，就不要自旋了，因为锁会直接交给队列头部的goroutine</span><br><span class="line">		// 如果锁是被获取状态，并且满足自旋条件（canSpin见后文分析），那么就自旋等锁</span><br><span class="line">		// 伪代码：if isLocked() &amp;&amp; isNotStarving() &amp;&amp; canSpin()</span><br><span class="line">        // old&amp;(mutexLocked|mutexStarving) == mutexLocked  满足的条件为: (0x1) &amp; (101) ; 不满足的条件为: (1xx) &amp; (101) 或 (0x1) &amp;&amp; (101)</span><br><span class="line">		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			// 将自己的状态以及锁的状态设置为唤醒，这样当Unlock的时候就不会去唤醒其它被阻塞的goroutine了</span><br><span class="line">            // 自己为未唤醒状态, 锁状态为未唤醒, 等待锁的goroutine 数量不为0, 将锁状态从未唤醒更新为唤醒</span><br><span class="line">			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = true // 当前 goroutine 状态更新为唤醒</span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin() // 进行自旋(分析见后文)</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state // 更新锁的状态(有可能在自旋的这段时间之内锁的状态已经被其它goroutine改变)</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 当走到这一步的时候，可能会有以下的情况：</span><br><span class="line">		// 1. 锁被获取+ 饥饿</span><br><span class="line">		// 2. 锁被获取+ 正常</span><br><span class="line">		// 3. 锁空闲 + 饥饿</span><br><span class="line">		// 4. 锁空闲 + 正常</span><br><span class="line">		</span><br><span class="line">		// goroutine的状态可能是唤醒以及非唤醒</span><br><span class="line">		</span><br><span class="line">		// 复制一份当前的状态，目的是根据当前状态设置出期望的状态，存在new里面，</span><br><span class="line">		// 并且通过CAS来比较以及更新锁的状态</span><br><span class="line">		// old用来存锁的当前状态</span><br><span class="line">		new := old</span><br><span class="line"></span><br><span class="line">		// 如果说锁不是饥饿状态，就把期望状态设置为被获取(获取锁)</span><br><span class="line">		// 也就是说，如果是饥饿状态，就不要把期望状态设置为被获取</span><br><span class="line">		// 新到的goroutine乖乖排队去</span><br><span class="line">		// 伪代码：if isNotStarving()</span><br><span class="line">		if old&amp;mutexStarving == 0 &#123;</span><br><span class="line">			// 伪代码：newState = locked</span><br><span class="line">			new |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果锁是被获取状态，或者饥饿状态</span><br><span class="line">		// 就把期望状态中的等待队列的等待者数量+1(实际上是new + 8)</span><br><span class="line">		// (会不会可能有三亿个goroutine等待拿锁……)</span><br><span class="line">		if old&amp;(mutexLocked|mutexStarving) != 0 &#123;</span><br><span class="line">			new += 1 &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果说当前的goroutine是饥饿状态，并且锁被其它goroutine获取</span><br><span class="line">		// 那么将期望的锁的状态设置为饥饿状态</span><br><span class="line">		// 如果锁是释放状态，那么就不用切换了</span><br><span class="line">		// Unlock期望一个饥饿的锁会有一些等待拿锁的goroutine，而不只是一个</span><br><span class="line">		// 这种情况下不会成立</span><br><span class="line">		if starving &amp;&amp; old&amp;mutexLocked != 0 &#123;</span><br><span class="line">			// 期望状态设置为饥饿状态</span><br><span class="line">			new |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果说当前goroutine是被唤醒状态，我们需要reset这个状态</span><br><span class="line">		// 因为goroutine要么是拿到锁了，要么是进入sleep了</span><br><span class="line">		if awoke &#123;</span><br><span class="line">			// 如果说期望状态不是woken状态，那么肯定出问题了</span><br><span class="line">			// 这里看不懂没关系，wake的逻辑在下面</span><br><span class="line">			if new&amp;mutexWoken == 0 &#123;</span><br><span class="line">				throw(&quot;sync: inconsistent mutex state&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">			// 这句就是把new设置为非唤醒状态</span><br><span class="line">			// &amp;^的意思是and not</span><br><span class="line">			new &amp;^= mutexWoken</span><br><span class="line">		&#125;</span><br><span class="line">		// 通过CAS来尝试设置锁的状态</span><br><span class="line">		// 这里可能是设置锁，也有可能是只设置为饥饿状态和等待数量</span><br><span class="line">		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) &#123;</span><br><span class="line">			// 如果说old状态不是饥饿状态也不是被获取状态</span><br><span class="line">			// 那么代表当前goroutine已经通过CAS成功获取了锁</span><br><span class="line">			// (能进入这个代码块表示状态已改变，也就是说状态是从空闲到被获取)</span><br><span class="line">			if old&amp;(mutexLocked|mutexStarving) == 0 &#123;</span><br><span class="line">				break // locked the mutex with CAS</span><br><span class="line">			&#125;</span><br><span class="line">			// 如果之前已经等待过了，那么就要放到队列头</span><br><span class="line">			queueLifo := waitStartTime != 0</span><br><span class="line">			// 如果说之前没有等待过，就初始化设置现在的等待时间</span><br><span class="line">			if waitStartTime == 0 &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">			&#125;</span><br><span class="line">			// 既然获取锁失败了，就使用sleep原语来阻塞当前goroutine</span><br><span class="line">			// 通过信号量来排队获取锁</span><br><span class="line">			// 如果是新来的goroutine，就放到队列尾部</span><br><span class="line">			// 如果是被唤醒的等待锁的goroutine，就放到队列头部</span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line">			</span><br><span class="line">			// 这里sleep完了，被唤醒</span><br><span class="line">			</span><br><span class="line">			// 如果当前goroutine已经是饥饿状态了</span><br><span class="line">			// 或者当前goroutine已经等待了1ms（在上面定义常量）以上</span><br><span class="line">			// 就把当前goroutine的状态设置为饥饿</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			// 再次获取一下锁现在的状态</span><br><span class="line">			old = m.state</span><br><span class="line">			// 如果说锁现在是饥饿状态，就代表现在锁是被释放的状态，当前goroutine是被信号量所唤醒的</span><br><span class="line">			// 也就是说，锁被直接交给了当前goroutine</span><br><span class="line">			if old&amp;mutexStarving != 0 &#123;</span><br><span class="line">				// 如果说当前锁的状态是被唤醒状态或者被获取状态，或者说等待的队列为空</span><br><span class="line">				// 那么是不可能的，肯定是出问题了，因为当前状态肯定应该有等待的队列，锁也一定是被释放状态且未唤醒</span><br><span class="line">				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 &#123;</span><br><span class="line">					throw(&quot;sync: inconsistent mutex state&quot;)</span><br><span class="line">				&#125;</span><br><span class="line">				// 当前的goroutine获得了锁，那么就把等待队列-1</span><br><span class="line">				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)</span><br><span class="line">				// 如果当前goroutine非饥饿状态，或者说当前goroutine是队列中最后一个goroutine</span><br><span class="line">				// 那么就退出饥饿模式，把状态设置为正常</span><br><span class="line">				if !starving || old&gt;&gt;mutexWaiterShift == 1 &#123;</span><br><span class="line">					// Exit starvation mode.</span><br><span class="line">					// Critical to do it here and consider wait time.</span><br><span class="line">					// Starvation mode is so inefficient, that two goroutines</span><br><span class="line">					// can go lock-step infinitely once they switch mutex</span><br><span class="line">					// to starvation mode.</span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				// 原子性地加上改动的状态</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			// 如果锁不是饥饿模式，就把当前的goroutine设为被唤醒</span><br><span class="line">			// 并且重置iter(重置spin)</span><br><span class="line">			awoke = true</span><br><span class="line">			iter = 0</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 如果CAS不成功，也就是说没能成功获得锁，锁被别的goroutine获得了或者锁一直没被释放</span><br><span class="line">			// 那么就更新状态，重新开始循环尝试拿锁</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/09/04/go-interface-use/"><span>Go Interface 使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/09/04/go-interface-use/" rel="bookmark">
        <time class="entry-date published" datetime="2019-09-04T08:04:29.000Z">
          2019-09-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本文基于<code>go1.12.4</code>源码</p>
</blockquote>
<h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><h2 id="面相对象"><a href="#面相对象" class="headerlink" title="面相对象"></a>面相对象</h2><h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><p> 下面举一个例子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mather <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sub(a, b <span class="keyword">int64</span>) <span class="keyword">int64</span></span><br><span class="line">    Add(a, b <span class="keyword">int32</span>) <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Caller <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span>&#123; id <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">    CallAdd(adder)</span><br><span class="line">    CallSub(adder)</span><br><span class="line">    CallName(adder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Sub</span><span class="params">(a, b <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123; <span class="keyword">return</span> a - b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"Adder"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallAdd</span><span class="params">(m Mather)</span></span> &#123;</span><br><span class="line">    m.Add(<span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallSub</span><span class="params">(m Mather)</span></span> &#123;</span><br><span class="line">    m.Sub(<span class="number">19</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallName</span><span class="params">(c Caller)</span></span> &#123;</span><br><span class="line">    c.Name()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Adder</code>实现了两个接口<code>Mather</code>和<code>Caller</code>, 定义<code>CallAdd</code>和<code>CallSub</code>调用<code>Mather</code>类型，可以看到:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0031</span> <span class="number">00049</span> (main.go:<span class="number">16</span>)   MOVL    <span class="number">$6754</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0038</span> <span class="number">00056</span> (main.go:<span class="number">16</span>)   <span class="keyword">CALL</span>    runtime.convT32(SB)</span><br><span class="line"><span class="number">0x003d</span> <span class="number">00061</span> (main.go:<span class="number">16</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; 返回值, data 字段</span></span><br><span class="line"><span class="number">0x0042</span> <span class="number">00066</span> (main.go:<span class="number">16</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_1+<span class="number">40</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0047</span> <span class="number">00071</span> (main.go:<span class="number">16</span>)   LEAQ    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather(SB), <span class="built_in">CX</span> <span class="comment">; Mather 类型</span></span><br><span class="line"><span class="number">0x004e</span> <span class="number">00078</span> (main.go:<span class="number">16</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>) <span class="comment">; 类型从 CX 放到栈底</span></span><br><span class="line"><span class="number">0x0052</span> <span class="number">00082</span> (main.go:<span class="number">16</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">;  值 data 从 AX 放到 8(SP)位置</span></span><br><span class="line"><span class="number">0x0057</span> <span class="number">00087</span> (main.go:<span class="number">16</span>)   <span class="keyword">CALL</span>    <span class="string">""</span>.CallAdd(SB) <span class="comment">; 前面 (SP)和8(SP)加起来就是一个 adder 实现的 Mather 类型，作为这个函数调用的参数</span></span><br><span class="line"><span class="number">0x005c</span> <span class="number">00092</span> (main.go:<span class="number">17</span>)   MOVL    <span class="string">""</span>.adder+<span class="number">20</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x0060</span> <span class="number">00096</span> (main.go:<span class="number">17</span>)   MOVL    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0063</span> <span class="number">00099</span> (main.go:<span class="number">17</span>)   <span class="keyword">CALL</span>    runtime.convT32(SB)</span><br><span class="line"><span class="number">0x0068</span> <span class="number">00104</span> (main.go:<span class="number">17</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x006d</span> <span class="number">00109</span> (main.go:<span class="number">17</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0072</span> <span class="number">00114</span> (main.go:<span class="number">17</span>)   LEAQ    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather(SB), <span class="built_in">CX</span></span><br><span class="line"><span class="number">0x0079</span> <span class="number">00121</span> (main.go:<span class="number">17</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x007d</span> <span class="number">00125</span> (main.go:<span class="number">17</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0082</span> <span class="number">00130</span> (main.go:<span class="number">17</span>)   <span class="keyword">CALL</span>    <span class="string">""</span>.CallSub(SB)<span class="comment">; 处理同上 CallAdd</span></span><br></pre></td></tr></table></figure></p>
<p>接着调用<code>CallName</code>, 需要的是一个<code>Caller</code>类型的参数:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0087</span> <span class="number">00135</span> (main.go:<span class="number">18</span>)   MOVL    <span class="string">""</span>.adder+<span class="number">20</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; adder 的值放到 AX</span></span><br><span class="line"><span class="number">0x008b</span> <span class="number">00139</span> (main.go:<span class="number">18</span>)   MOVL    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)<span class="comment">; 放到栈底</span></span><br><span class="line"><span class="number">0x008e</span> <span class="number">00142</span> (main.go:<span class="number">18</span>)   <span class="keyword">CALL</span>    runtime.convT32(SB)</span><br><span class="line"><span class="number">0x0093</span> <span class="number">00147</span> (main.go:<span class="number">18</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; 返回处理后的值 unsafe.Pointer</span></span><br><span class="line"><span class="number">0x0098</span> <span class="number">00152</span> (main.go:<span class="number">18</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_3+<span class="number">24</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x009d</span> <span class="number">00157</span> (main.go:<span class="number">18</span>)   LEAQ    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Caller(SB), <span class="built_in">CX</span> <span class="comment">; Caller 类型地址放到 CX</span></span><br><span class="line"><span class="number">0x00a4</span> <span class="number">00164</span> (main.go:<span class="number">18</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>)<span class="comment">; 类型地址从 CX 赋值到栈底</span></span><br><span class="line"><span class="number">0x00a8</span> <span class="number">00168</span> (main.go:<span class="number">18</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; 值 data 从 AX 赋值到 8(SP)</span></span><br><span class="line"><span class="number">0x00ad</span> <span class="number">00173</span> (main.go:<span class="number">18</span>)   <span class="keyword">CALL</span>    <span class="string">""</span>.CallName(SB): 前面两行把 adder 转换为Caller 类型，并做为参数本函数</span><br></pre></td></tr></table></figure>
<p>通过上面可以看出，一个实例实现了多个接口，在具体调用的地方会根据接口的类型转换为不同的接口</p>
<h3 id="未实现接口"><a href="#未实现接口" class="headerlink" title="未实现接口"></a>未实现接口</h3><p>如果我们调用一个接口的方法，而对应的实例没有实现这个接口会出现什么问题呢？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span>&#123; id <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span> &#123;</span><br><span class="line">    F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">    CallF(adder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallF</span><span class="params">(e Empty)</span></span> &#123;</span><br><span class="line">    e.F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对上面的代码进行编译，得到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./main2.go:11:7: cannot use adder (type Adder) as type Empty in argument to CallF:</span><br><span class="line">        Adder does not implement Empty (missing F method)</span><br></pre></td></tr></table></figure></p>
<p>可见编译器会在编译阶段对 AST 数据结构进行检查，如果发现没有实现对应的函数，就会报错。具体代码在<code>cmd/compile/internal/gc/subr.go</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> why != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isptrto(src, TINTER) &#123;</span><br><span class="line">        *why = fmt.Sprintf(<span class="string">":\n\t%v is pointer to interface, not interface"</span>, src)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> have != <span class="literal">nil</span> &amp;&amp; have.Sym == missing.Sym &amp;&amp; have.Nointerface() &#123;</span><br><span class="line">        *why = fmt.Sprintf(<span class="string">":\n\t%v does not implement %v (%v method is marked 'nointerface')"</span>, src, dst, missing.Sym)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> have != <span class="literal">nil</span> &amp;&amp; have.Sym == missing.Sym &#123;</span><br><span class="line">        *why = fmt.Sprintf(<span class="string">":\n\t%v does not implement %v (wrong type for %v method)\n"</span>+</span><br><span class="line">            <span class="string">"\t\thave %v%0S\n\t\twant %v%0S"</span>, src, dst, missing.Sym, have.Sym, have.Type, missing.Sym, missing.Type)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ptr != <span class="number">0</span> &#123;</span><br><span class="line">        *why = fmt.Sprintf(<span class="string">":\n\t%v does not implement %v (%v method has pointer receiver)"</span>, src, dst, missing.Sym)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> have != <span class="literal">nil</span> &#123;</span><br><span class="line">        *why = fmt.Sprintf(<span class="string">":\n\t%v does not implement %v (missing %v method)\n"</span>+</span><br><span class="line">            <span class="string">"\t\thave %v%0S\n\t\twant %v%0S"</span>, src, dst, missing.Sym, have.Sym, have.Type, missing.Sym, missing.Type)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *why = fmt.Sprintf(<span class="string">":\n\t%v does not implement %v (missing %v method)"</span>, src, dst, missing.Sym)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="值接收与指针接收"><a href="#值接收与指针接收" class="headerlink" title="值接收与指针接收"></a>值接收与指针接收</h3><p>实现接口方法的时候可以使用指针接收也可以使用值接收，他们有什么区别？不通的接收方式存在什么问题呢？针对实现和调用的方式，我们可以有四种组合，分别是:</p>
<ol>
<li>值接收，值调用</li>
<li>值接收，指针调用</li>
<li>指针接收，指针调用</li>
<li>指针接收，值调用</li>
</ol>
<h4 id="值接收，值调用"><a href="#值接收，值调用" class="headerlink" title="值接收，值调用"></a>值接收，值调用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifer <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending user email to %d\n"</span>, u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := user&#123;<span class="number">9527</span>&#125;</span><br><span class="line">    sendNotification(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifer)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是最常见的，可以编译和调用，<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x001d</span> <span class="number">00029</span> (main3.go:<span class="number">18</span>)  MOVL    <span class="number">$0</span>, <span class="string">""</span>.u+<span class="number">20</span>(<span class="built_in">SP</span>) <span class="comment">; 初始化 u 为空值</span></span><br><span class="line"><span class="number">0x0025</span> <span class="number">00037</span> (main3.go:<span class="number">18</span>)  MOVL    <span class="number">$9527</span>, <span class="string">""</span>.u+<span class="number">20</span>(<span class="built_in">SP</span>) <span class="comment">; 给 u 赋值</span></span><br><span class="line"><span class="number">0x002d</span> <span class="number">00045</span> (main3.go:<span class="number">19</span>)  MOVL    <span class="number">$9527</span>, (<span class="built_in">SP</span>) <span class="comment">; 放到栈底，作为下面函数调用的参数</span></span><br><span class="line"><span class="number">0x0034</span> <span class="number">00052</span> (main3.go:<span class="number">19</span>)  <span class="keyword">CALL</span>    runtime.convT32(SB) <span class="comment">; 返回新申请的堆上的数据，并且返回</span></span><br><span class="line"><span class="number">0x0039</span> <span class="number">00057</span> (main3.go:<span class="number">19</span>)  <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; 函数的返回值放到 AX 中</span></span><br><span class="line"><span class="number">0x003e</span> <span class="number">00062</span> (main3.go:<span class="number">19</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_1+<span class="number">24</span>(<span class="built_in">SP</span>) <span class="comment">;放到临时变量 autotmp_1中</span></span><br><span class="line"><span class="number">0x0043</span> <span class="number">00067</span> (main3.go:<span class="number">19</span>)  LEAQ    go.itab.<span class="string">""</span>.user,<span class="string">""</span>.notifer(SB), <span class="built_in">CX</span> <span class="comment">; 把 user 转换为 notifer 类型，并把 itab 地址放到 CX</span></span><br><span class="line"><span class="number">0x004a</span> <span class="number">00074</span> (main3.go:<span class="number">19</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>) <span class="comment">; _type 地址 赋值到栈底</span></span><br><span class="line"><span class="number">0x004e</span> <span class="number">00078</span> (main3.go:<span class="number">19</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; data 赋值到 8(SP)</span></span><br><span class="line"><span class="number">0x0053</span> <span class="number">00083</span> (main3.go:<span class="number">19</span>)  <span class="keyword">CALL</span>    <span class="string">""</span>.sendNotification(SB) <span class="comment">; 前面两行组成的 interface 作为参数进行函数调用</span></span><br></pre></td></tr></table></figure></p>
<p>这里详细分析一下下面这行代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAQ    go.itab.<span class="string">""</span>.user,<span class="string">""</span>.notifer(SB), <span class="built_in">CX</span></span><br></pre></td></tr></table></figure></p>
<p>详细解释一下这里的含义: <code>go tool compile</code>生成的是一个间接目标文件，还没有经过 链接器的链接, 符号没有把 package 名字填充上，如果填充上的话应该是这样:<br><code>go.itab.main.user,main.notifer(SB)</code>(package是main), 这个代码可以看出其作用是为了把<code>user</code>和<code>notifer</code>关联起来，并且取出<code>itab</code>的地址。在汇编代码中还可以找出这样一段:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go.itab.<span class="string">""</span>.user,<span class="string">""</span>.notifer SRODATA dupok size=<span class="number">32</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line">    <span class="number">0x0010</span> <span class="number">56</span> e9 <span class="number">47</span> <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  V.G.............</span><br><span class="line">    <span class="built_in">rel</span> <span class="number">0</span>+<span class="number">8</span> t=<span class="number">1</span> type.<span class="string">""</span>.notifer+<span class="number">0</span></span><br><span class="line">    <span class="built_in">rel</span> <span class="number">8</span>+<span class="number">8</span> t=<span class="number">1</span> type.<span class="string">""</span>.user+<span class="number">0</span></span><br><span class="line">    <span class="built_in">rel</span> <span class="number">24</span>+<span class="number">8</span> t=<span class="number">1</span> <span class="string">""</span>.(*user).notify+<span class="number">0</span></span><br><span class="line">go.itablink.<span class="string">""</span>.user,<span class="string">""</span>.notifer SRODATA dupok size=<span class="number">8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                          ........</span><br><span class="line">    <span class="built_in">rel</span> <span class="number">0</span>+<span class="number">8</span> t=<span class="number">1</span> go.itab.<span class="string">""</span>.user,<span class="string">""</span>.notifer+<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>对上面的代码我们一句一句来分析，首先第一句是声明和符号和他的属性: <code>go.itab.&quot;&quot;.user,&quot;&quot;.notifer SRODATA dupok size=32</code><br>我们这里得到的是一个 32 字节的全局对象的符号，该符号将被存到二进制文件的 .rodata 段中</p>
<ul>
<li><code>dupok</code>表示: 该变量对应的标识符可能有多个， 链接时 只选择其中一个即可，一般用于合并相同的常量字符串，减少重复数据占用的空间</li>
<li><code>RODATA</code>表示: 将变量定义在只读内存段，因此后续任何对此变量的修改操作将导致异常(recover()也无法捕获) )</li>
</ul>
<p>后面的 两行表示的是这32个字节存储的数据内容,  也就是<code>itab</code>被序列化之后的表示方法。 我们再来回顾一下<code>itab</code>类型的定义:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;       <span class="comment">// 32 bytes on a 64bit arch</span></span><br><span class="line">    inter *interfacetype <span class="comment">// offset 0x00 ($00)</span></span><br><span class="line">    _type *_type         <span class="comment">// offset 0x08 ($08)</span></span><br><span class="line">    hash  <span class="keyword">uint32</span>         <span class="comment">// offset 0x10 ($16)</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span>        <span class="comment">// offset 0x14 ($20)</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span>     <span class="comment">// offset 0x18 ($24)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出前面 32 字节中有内容的部分对应的就是<code>itab.hash</code>的四个字节<br>再往下:</p>
<ul>
<li><code>rel 0+8 t=1 type.&quot;&quot;.notifer+0</code>   : 告诉链接器需要将内容的前8个字节填充为全局符号 <code>type.&quot;&quot;.notifer</code> 的地址 , 也就是 <code>itab.inter</code> 字段</li>
<li><code>rel 8+8 t=1 type.&quot;&quot;.user+0</code>      : 告诉链接器需要将内容的 8-16 字节填充为全局符号 <code>type.&quot;&quot;.user</code> 的地址 , 也就是 <code>itab._type</code>字段</li>
<li><code>rel 24+8 t=1 &quot;&quot;.(*user).notify+0</code>: 这里对应的是<code>itab.func</code>的值, 填充的是 user.notify 函数的地址</li>
</ul>
<p>总结一下<code>LEAQ    go.itab.&quot;&quot;.user,&quot;&quot;.notifer(SB), CX</code>的含义就是:</p>
<ol>
<li>使用 接口 <code>notifer</code> 和  类型 <code>user</code> 组合成一个 <code>itab</code>类型</li>
<li>取 <code>itab</code> 地址加载到 <code>CX</code> 编译器</li>
</ol>
<h4 id="值接收，指针调用"><a href="#值接收，指针调用" class="headerlink" title="值接收，指针调用"></a>值接收，指针调用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifer <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending user email to %d\n"</span>, u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := &amp;user&#123;<span class="number">9527</span>&#125;</span><br><span class="line">    sendNotification(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifer)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x001d</span> <span class="number">00029</span> (main3.go:<span class="number">18</span>)  LEAQ    type.<span class="string">""</span>.user(SB), <span class="built_in">AX</span> <span class="comment">; 获取 user 的类型_type 地址放到 AX</span></span><br><span class="line"><span class="number">0x0024</span> <span class="number">00036</span> (main3.go:<span class="number">18</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>) <span class="comment">; _type 地址放到栈底，作为参数</span></span><br><span class="line"><span class="number">0x0028</span> <span class="number">00040</span> (main3.go:<span class="number">18</span>)  <span class="keyword">CALL</span>    runtime.newobject(SB) <span class="comment">; 调用 runtime.newobject 会从堆上申请内存 用来存放数据</span></span><br><span class="line"><span class="number">0x002d</span> <span class="number">00045</span> (main3.go:<span class="number">18</span>)  <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; 返回值放到 AX</span></span><br><span class="line"><span class="number">0x0032</span> <span class="number">00050</span> (main3.go:<span class="number">18</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">24</span>(<span class="built_in">SP</span>) <span class="comment">; 返回值赋值给 autotmp_2</span></span><br><span class="line"><span class="number">0x0037</span> <span class="number">00055</span> (main3.go:<span class="number">18</span>)  MOVL    <span class="number">$9527</span>, (<span class="built_in">AX</span>)<span class="comment">; 9527 赋值给 AX 所指向的地址的值</span></span><br><span class="line"><span class="number">0x003d</span> <span class="number">00061</span> (main3.go:<span class="number">18</span>)  <span class="keyword">MOVQ</span>    <span class="string">""</span>..autotmp_2+<span class="number">24</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> </span><br><span class="line"><span class="number">0x0042</span> <span class="number">00066</span> (main3.go:<span class="number">18</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.u+<span class="number">16</span>(<span class="built_in">SP</span>) <span class="comment">; AX 赋值给变量 u, u 的地址是指向 runtime.newobject 新申请的地址，值为 9527</span></span><br><span class="line"><span class="number">0x0047</span> <span class="number">00071</span> (main3.go:<span class="number">19</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_1+<span class="number">32</span>(<span class="built_in">SP</span>) <span class="comment">; AX 赋值给临时变量 autotmp_1</span></span><br><span class="line"><span class="number">0x004c</span> <span class="number">00076</span> (main3.go:<span class="number">19</span>)  LEAQ    go.itab.*<span class="string">""</span>.user,<span class="string">""</span>.notifer(SB), <span class="built_in">CX</span> <span class="comment">;  获取 user 实现 notifer 接口类型的地址，放到 CX</span></span><br><span class="line"><span class="number">0x0053</span> <span class="number">00083</span> (main3.go:<span class="number">19</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>) <span class="comment">; itab 地址放到栈底</span></span><br><span class="line"><span class="number">0x0057</span> <span class="number">00087</span> (main3.go:<span class="number">19</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; data 放到 8(SP)</span></span><br><span class="line"><span class="number">0x005c</span> <span class="number">00092</span> (main3.go:<span class="number">19</span>)  <span class="keyword">CALL</span>    <span class="string">""</span>.sendNotification(SB) <span class="comment">; 前面两行做给一个 interface 参数，调用此函数</span></span><br></pre></td></tr></table></figure>
<p>跟<strong>值接收，值调用</strong>不通的点有:</p>
<ol>
<li>变量<code>u</code>是<code>user</code>类型的变量的地址，需要通过<code>runtime.newobject</code>申请新的地址</li>
<li><p>获取<code>itab</code>类型的地址方式不一样: 在<code>go.itab</code> 和<code>user</code>之间多了一个<code>*</code>号</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAQ    go.itab.*<span class="string">""</span>.user,<span class="string">""</span>.notifer(SB), <span class="built_in">CX</span></span><br></pre></td></tr></table></figure>
<p>关于这个符号的具体细节如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go.itab.*<span class="string">""</span>.user,<span class="string">""</span>.notifer SRODATA dupok size=<span class="number">32</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line">    <span class="number">0x0010</span> c9 <span class="number">1b</span> ab 4c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ...L............</span><br><span class="line">    <span class="built_in">rel</span> <span class="number">0</span>+<span class="number">8</span> t=<span class="number">1</span> type.<span class="string">""</span>.notifer+<span class="number">0</span></span><br><span class="line">    <span class="built_in">rel</span> <span class="number">8</span>+<span class="number">8</span> t=<span class="number">1</span> type.*<span class="string">""</span>.user+<span class="number">0</span></span><br><span class="line">    <span class="built_in">rel</span> <span class="number">24</span>+<span class="number">8</span> t=<span class="number">1</span> <span class="string">""</span>.(*user).notify+<span class="number">0</span></span><br><span class="line">go.itablink.*<span class="string">""</span>.user,<span class="string">""</span>.notifer SRODATA dupok size=<span class="number">8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                          ........</span><br><span class="line">    <span class="built_in">rel</span> <span class="number">0</span>+<span class="number">8</span> t=<span class="number">1</span> go.itab.*<span class="string">""</span>.user,<span class="string">""</span>.notifer+<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到唯一不一样的地方就是:<br><code>rel 8+8 t=1 type.*&quot;&quot;.user+0</code>: 把 user地址类型放到<code>_type</code>字段的位置。</p>
</li>
</ol>
<p>从上面的代码可以看出，不一样的地方就是 <code>_type</code>这个字段，函数的调用都是一样的，所以<strong>值接收</strong> 也可以用指针类型调用。</p>
<h4 id="指针接收，指针调用"><a href="#指针接收，指针调用" class="headerlink" title="指针接收，指针调用"></a>指针接收，指针调用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifer <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending user email to %d\n"</span>, u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := &amp;user&#123;<span class="number">9527</span>&#125;</span><br><span class="line">    sendNotification(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifer)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式其实跟<strong>值接收, 指针调用</strong> 基本上是一样的，<code>interface.itab</code> 和<code>interface.data</code>都是一样的。</p>
<h4 id="指针接收，值调用"><a href="#指针接收，值调用" class="headerlink" title="指针接收，值调用"></a>指针接收，值调用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifer <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending user email to %d\n"</span>, u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := user&#123;<span class="number">9527</span>&#125;</span><br><span class="line">    sendNotification(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifer)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式编译时无法通过的，报错如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main3.go:22:18: cannot use u (type user) as type notifer in argument to sendNotification:</span><br><span class="line">        user does not implement notifer (notify method has pointer receiver)</span><br></pre></td></tr></table></figure></p>
<p>编译器认为<code>user</code>并没有实现<code>notifer</code>接口, 为什么呢？为了一探究竟，我们改一下上面的代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifer <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending user email to %d\n"</span>, u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">ptrnotify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending user email to %d\n"</span>, u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u1 := user&#123;<span class="number">9527</span>&#125;</span><br><span class="line">    u2 := &amp;user&#123;<span class="number">9527</span>&#125;</span><br><span class="line"></span><br><span class="line">    sendNotification(u1)</span><br><span class="line">    sendNotification(u2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifer)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>notify</code> 函数是值接收者，<code>ptrnotify</code>是指针接收者, 观察一下生成的汇编:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">""</span>.notifer.notify STEXT dupok size=<span class="number">92</span> args=<span class="number">0x10</span> locals=<span class="number">0x10</span></span><br><span class="line">...</span><br><span class="line"><span class="string">""</span>.(*user).notify STEXT dupok size=<span class="number">108</span> args=<span class="number">0x8</span> locals=<span class="number">0x18</span></span><br><span class="line">...</span><br><span class="line"><span class="string">""</span>.user.notify STEXT size=<span class="number">206</span> args=<span class="number">0x8</span> locals=<span class="number">0x80</span></span><br><span class="line">...</span><br><span class="line"><span class="string">""</span>.(*user).ptrnotify STEXT size=<span class="number">229</span> args=<span class="number">0x8</span> locals=<span class="number">0x88</span></span><br><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">185</span> args=<span class="number">0x0</span> locals=<span class="number">0x40</span></span><br><span class="line">...</span><br><span class="line"><span class="string">""</span>.sendNotification STEXT size=<span class="number">68</span> args=<span class="number">0x10</span> locals=<span class="number">0x10</span></span><br><span class="line">...</span><br><span class="line"><span class="string">""</span>.init STEXT size=<span class="number">100</span> args=<span class="number">0x0</span> locals=<span class="number">0x8</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>发现生成的函数中<code>notify</code>既实现了<strong>值接收</strong>类型的函数，又实现了<strong>指针接收</strong>类型的函数, 所以<code>notify</code>对于<code>user</code>和<code>*user</code>类型都可以调用<br>而<code>ptrnoitfy</code>函数只实现了<strong>指针接收</strong> 类型的函数，没有实现<strong>值接收</strong>类型的函数，所以无法通过<code>user</code>类型调用这个函数<br>那么为什么会有这个限制呢？ 因为<strong>编辑器不是总能自动获取一个值得地址。</strong>, 看一下下面的代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> duration <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *duration)</span> <span class="title">pretty</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Duration: %d"</span>, *d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    duration(<span class="number">42</span>).pretty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 运行时报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./main2.go:12:14: cannot call pointer method on duration(42)</span><br><span class="line">./main2.go:12:14: cannot take the address of duration(42)</span><br></pre></td></tr></table></figure></p>
<p> 如果改一下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> duration <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *duration)</span> <span class="title">pretty</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Duration: %d"</span>, *d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := duration(<span class="number">42</span>)</span><br><span class="line">    d.pretty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 则可以正常运行，证明第一种方式没有中间变量, 所以<code>duration(42)</code>是一个常量，常量无法取地址。</p>
<p><a href="http://xargin.com/go-and-interface/" target="_blank" rel="noopener">Go 和 interface 探究</a><br><a href="https://colobu.com/2018/02/27/go-addressable/" target="_blank" rel="noopener">go addressable 详解</a><br>《go in action 中文版》p98-p103</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/09/02/go-interface-implement/"><span>Go Interface 源码解析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/09/02/go-interface-implement/" rel="bookmark">
        <time class="entry-date published" datetime="2019-09-02T02:18:00.000Z">
          2019-09-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本文基于<code>go1.12.4</code>源码</p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义:"></a>类型定义:</h3><p><code>runtime/runtime2.go</code></p>
<h4 id="不含method的interface"><a href="#不含method的interface" class="headerlink" title="不含method的interface"></a>不含<code>method</code>的<code>interface</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含method的interface"><a href="#包含method的interface" class="headerlink" title="包含method的interface"></a>包含<code>method</code>的<code>interface</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eface-分析"><a href="#eface-分析" class="headerlink" title="eface 分析"></a><code>eface</code> 分析</h2><p>首先写一个<code>eface</code>的具体<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br><span class="line">    e := *(*eface)(unsafe.Pointer(&amp;inter))</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, e)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *(*<span class="keyword">int</span>)(e.data))</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, &amp;num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    kind       <span class="keyword">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">    <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">    <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span></span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tflag <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// function for hashing objects of this type</span></span><br><span class="line">    <span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">    hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">    // <span class="title">function</span> <span class="title">for</span> <span class="title">comparing</span> <span class="title">objects</span> <span class="title">of</span> <span class="title">this</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">    // <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function">    <span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">nameOff</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">typeOff</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure></p>
<p>对应汇编:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">782</span> args=<span class="number">0x0</span> locals=<span class="number">0x128</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (main.go:<span class="number">8</span>)    TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$296</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0032</span> <span class="number">00050</span> (main.go:<span class="number">9</span>)    LEAQ    type.int(SB), <span class="built_in">AX</span> <span class="comment">;  通过 type.int  把 int 类型 转换为 *_type  类型，并把地址放到寄存器 AX</span></span><br><span class="line">    <span class="number">0x0039</span> <span class="number">00057</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)<span class="comment">; 把 AX 内容放到栈底, 这里是下一个函数 newobject 调用的参数</span></span><br><span class="line">    <span class="number">0x003d</span> <span class="number">00061</span> (main.go:<span class="number">9</span>)    <span class="keyword">CALL</span>    runtime.newobject(SB) <span class="comment">; 函数调用</span></span><br><span class="line">    <span class="number">0x0042</span> <span class="number">00066</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; newobject 返回值放到8(SP), 然后再放到 AX</span></span><br><span class="line">    <span class="number">0x0047</span> <span class="number">00071</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.&amp;num+<span class="number">128</span>(<span class="built_in">SP</span>)<span class="comment">; 返回值从 AX 放到 &amp;num 变量位置, 表示 num 的地址</span></span><br><span class="line">    <span class="number">0x004f</span> <span class="number">00079</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="number">$3</span>, (<span class="built_in">AX</span>)<span class="comment">; (AX)表示 AX 的地址对应的值, 赋值为 3</span></span><br><span class="line">    <span class="number">0x0056</span> <span class="number">00086</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.&amp;num+<span class="number">128</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; num 地址的值赋值个 AX </span></span><br><span class="line">    <span class="number">0x005e</span> <span class="number">00094</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    (<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; AX 值是地址，其对应的值赋值给 AX, 也就是常量 3</span></span><br><span class="line">    <span class="number">0x0061</span> <span class="number">00097</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_7+<span class="number">64</span>(<span class="built_in">SP</span>)<span class="comment">; 把这个值赋值给一个临时变量 autotmp_7</span></span><br><span class="line">    <span class="number">0x0066</span> <span class="number">00102</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>) <span class="comment">; 把值赋值给SP，栈底，是下一个函数 convT64 的参数</span></span><br><span class="line">    <span class="number">0x006a</span> <span class="number">00106</span> (main.go:<span class="number">10</span>)   <span class="keyword">CALL</span>    runtime.convT64(SB)<span class="comment">; 调用 runtime.convT64, 参数为 uint64, 返回值为 unsafe.Pointer</span></span><br><span class="line">    <span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; convT64 返回值放到8(SP), 并且赋值到 AX</span></span><br><span class="line">    <span class="number">0x0074</span> <span class="number">00116</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_8+<span class="number">80</span>(<span class="built_in">SP</span>)<span class="comment">; AX 的值放到临时变量 `autotmp_8`</span></span><br><span class="line">    <span class="number">0x0079</span> <span class="number">00121</span> (main.go:<span class="number">10</span>)   LEAQ    type.int(SB), <span class="built_in">CX</span> <span class="comment">; 通过 type.int  把 int 类型 转换为 *_type  类型，并把地址放到寄存器 CX</span></span><br><span class="line">    <span class="number">0x0080</span> <span class="number">00128</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.inter+<span class="number">136</span>(<span class="built_in">SP</span>)<span class="comment">; 将 CX 中代表*_type 地址的值放到 inter 变量eface类型的 _type 变量中</span></span><br><span class="line">    <span class="number">0x0088</span> <span class="number">00136</span> (main.go:<span class="number">10</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.inter+<span class="number">144</span>(<span class="built_in">SP</span>)<span class="comment">; 将 AX 中代表 convT64返回值 3 的 unsafe.Pointer 类型 放到 inter 变量 eface 类型的 data 中 </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p> 这里只关注<code>main.go:9</code>和<code>main.go:10</code>的处理, 对应代码为:<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> num := <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>初始化变量<code>num</code>为<code>int</code>类型，并赋值为<code>3</code>, 具体的过程已经在前面汇编代码中通过注释的方式标出，下面来看一些细节:</p>
<ol>
<li>新建 <code>int</code> 类型变量需要申请内存, 通过<code>runtime.newobject</code>来申请</li>
<li><code>type.int</code>  可以获取 <code>int</code>类型的 <code>_type</code> 结构的地址 <code>*_type</code> (具体实现方式被编译优化了，需要再进一步深究)</li>
<li><p><code>MOVQ AX, (SP)</code>是为了把前面放到<code>AX</code>的<code>*_type</code> 放到栈底, 这个位置下面调用函数<code>runtime.newobject</code>的参数, 具体函数实现:</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完函数调用用会把返回值<code>unsafe.Pointer</code>放到<code>8(SP)</code>, 然后在放入 <code>AX</code></p>
</li>
<li><code>MOV $3,(AX)</code> 向表示寄存器<code>AX</code>包含的地址对应的值设置为常量<code>3</code></li>
<li><code>autotmp</code>是一个临时变量，是为了在程序内复用全局临时变量, 防止变量被修改:<br> <a href="https://github.com/golang/go/issues/21557" target="_blank" rel="noopener">https://github.com/golang/go/issues/21557</a>,<br> <a href="https://github.com/golang/go/issues/29547" target="_blank" rel="noopener">https://github.com/golang/go/issues/29547</a><br> <strong>具体需要再深入研究</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br></pre></td></tr></table></figure>
<p> 初始化变量<code>inter</code>,类型为<code>interface{}</code>, 并且指向<code>num</code>, 具体过程参考上面的注释部分，一些细节:</p>
<ol>
<li><p>这里会调用<code>runtime.convT64</code>函数，定义如下: ( 在<code>go 1.8</code>版本调用的是<code>runtime.convT2E</code>, 在<code>go1.10</code>调用的是<code>runtime.convT2E64</code>):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT64</span><span class="params">(val <span class="keyword">uint64</span>)</span> <span class="params">(x unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> val == <span class="number">0</span> &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = mallocgc(<span class="number">8</span>, uint64Type, <span class="literal">false</span>)</span><br><span class="line">        *(*<span class="keyword">uint64</span>)(x) = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参就是 <code>num</code> 的值 <code>3</code>, 返回值是转换为<code>uint64</code>的值，并且申请一个地址，值为<code>3</code>, <strong>注意: 这里发生了值的<code>copy</code></strong></p>
</li>
<li>通过最后两行赋值<code>inter</code>, <code>inter</code>类型为<code>eface</code>, 定义前面提过，最终给<code>eface._type</code> 和<code>eface.data</code>赋值</li>
<li><code>eface.type</code>的查看这里还没有找到好的方法来查看，<code>dlv</code>无法深入到内置的实现。</li>
</ol>
<p>为了查看<code>_type</code> 类型，定义了一个跟 <code>runtime</code> 内部实现一样的数据结构，并且通过<code>unsafe</code>强制进行数据类型转换，可以得到<code>_type</code>的值。<br>借助<code>dlv</code>对上面的程序进行<code>debug</code>:</p>
<ol>
<li>在<code>e := *(*eface)(unsafe.Pointer(&amp;inter))</code>处打断点</li>
<li><p>执行到上面这行后打印出<code>e</code>的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p e</span><br><span class="line">main.eface &#123;</span><br><span class="line">        _type: *main._type &#123;</span><br><span class="line">                size: 8,</span><br><span class="line">                ptrdata: 0,</span><br><span class="line">                hash: 4149441018,</span><br><span class="line">                tflag: 7,</span><br><span class="line">                align: 8,</span><br><span class="line">                fieldalign: 8,</span><br><span class="line">                kind: 130,</span><br><span class="line">                alg: *(*main.typeAlg)(0x57adf0),</span><br><span class="line">                gcdata: *1,</span><br><span class="line">                str: 1059,</span><br><span class="line">                ptrToThis: 47520,&#125;,</span><br><span class="line">        data: unsafe.Pointer(0xc000080018),&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>*_type</code>源码的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有类型信息结构体的公共部分</span></span><br><span class="line"><span class="comment">// src/rumtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span>  <span class="comment">// 类型的大小</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span>  <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span>   <span class="comment">// 类型的Hash值</span></span><br><span class="line">    tflag      tflag    <span class="comment">// 类型的Tags </span></span><br><span class="line">    align      <span class="keyword">uint8</span>    <span class="comment">// 结构体内对齐</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span>    <span class="comment">// 结构体作为field时的对齐</span></span><br><span class="line">    kind       <span class="keyword">uint8</span>    <span class="comment">// 类型编号 定义于runtime/typekind.go</span></span><br><span class="line">    alg        *typeAlg <span class="comment">// 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span>     <span class="comment">// GC相关信息</span></span><br><span class="line">    str       nameOff   <span class="comment">// 类型名字的偏移    </span></span><br><span class="line">    ptrToThis typeOff    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为了查看<code>eface.data</code>的值，可以通过<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, *(*<span class="keyword">int</span>)(e.data))</span><br></pre></td></tr></table></figure></p>
<p> 输出，可以看到运行结果为<code>3</code>, 正是<code>num</code>的值。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p> 对于上面的程序我们只修改两行:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = num</span><br><span class="line">    e := *(*eface)(unsafe.Pointer(&amp;inter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = <span class="number">3</span> </span><br><span class="line">    e := *(*eface)(unsafe.Pointer(&amp;inter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再查看其对应的汇编:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x002f</span> <span class="number">00047</span> (main.go:<span class="number">9</span>)    LEAQ    type.int(SB), <span class="built_in">AX</span> <span class="comment">; int 转为的_type类型</span></span><br><span class="line"><span class="number">0x0036</span> <span class="number">00054</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.inter+<span class="number">96</span>(<span class="built_in">SP</span>) <span class="comment">; 赋值给 inter._type</span></span><br><span class="line"><span class="number">0x003b</span> <span class="number">00059</span> (main.go:<span class="number">9</span>)    LEAQ    <span class="string">""</span>.statictmp_0(SB), <span class="built_in">AX</span> <span class="comment">; 取一个静态变量的是到 AX</span></span><br><span class="line"><span class="number">0x0042</span> <span class="number">00066</span> (main.go:<span class="number">9</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.inter+<span class="number">104</span>(<span class="built_in">SP</span>) <span class="comment">; 赋值给 inter.data</span></span><br></pre></td></tr></table></figure></p>
<p><code>statictmp_0</code>代表的是一个全局静态变量，值是<code>3</code>:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.statictmp_0 SRODATA size=<span class="number">8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure></p>
<p>对于<code>statictmp</code> 时一个全局变量，一半的常量为了节省空间都会使用这个来代替，数据来源于’runtime/iface.go`:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// staticbytes is used to avoid convT2E for byte-sized values.</span></span><br><span class="line"><span class="keyword">var</span> staticbytes = [...]<span class="keyword">byte</span>&#123;</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>,</span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x0b</span>, <span class="number">0x0c</span>, <span class="number">0x0d</span>, <span class="number">0x0e</span>, <span class="number">0x0f</span>,</span><br><span class="line">    <span class="number">0x10</span>, <span class="number">0x11</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, <span class="number">0x15</span>, <span class="number">0x16</span>, <span class="number">0x17</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0x1a</span>, <span class="number">0x1b</span>, <span class="number">0x1c</span>, <span class="number">0x1d</span>, <span class="number">0x1e</span>, <span class="number">0x1f</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x21</span>, <span class="number">0x22</span>, <span class="number">0x23</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0x26</span>, <span class="number">0x27</span>,</span><br><span class="line">    <span class="number">0x28</span>, <span class="number">0x29</span>, <span class="number">0x2a</span>, <span class="number">0x2b</span>, <span class="number">0x2c</span>, <span class="number">0x2d</span>, <span class="number">0x2e</span>, <span class="number">0x2f</span>,</span><br><span class="line">    <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>,</span><br><span class="line">    <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x3a</span>, <span class="number">0x3b</span>, <span class="number">0x3c</span>, <span class="number">0x3d</span>, <span class="number">0x3e</span>, <span class="number">0x3f</span>,</span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x49</span>, <span class="number">0x4a</span>, <span class="number">0x4b</span>, <span class="number">0x4c</span>, <span class="number">0x4d</span>, <span class="number">0x4e</span>, <span class="number">0x4f</span>,</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>,</span><br><span class="line">    <span class="number">0x58</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x5b</span>, <span class="number">0x5c</span>, <span class="number">0x5d</span>, <span class="number">0x5e</span>, <span class="number">0x5f</span>,</span><br><span class="line">    <span class="number">0x60</span>, <span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x66</span>, <span class="number">0x67</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x69</span>, <span class="number">0x6a</span>, <span class="number">0x6b</span>, <span class="number">0x6c</span>, <span class="number">0x6d</span>, <span class="number">0x6e</span>, <span class="number">0x6f</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x71</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x76</span>, <span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x79</span>, <span class="number">0x7a</span>, <span class="number">0x7b</span>, <span class="number">0x7c</span>, <span class="number">0x7d</span>, <span class="number">0x7e</span>, <span class="number">0x7f</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x81</span>, <span class="number">0x82</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0x88</span>, <span class="number">0x89</span>, <span class="number">0x8a</span>, <span class="number">0x8b</span>, <span class="number">0x8c</span>, <span class="number">0x8d</span>, <span class="number">0x8e</span>, <span class="number">0x8f</span>,</span><br><span class="line">    <span class="number">0x90</span>, <span class="number">0x91</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>, <span class="number">0x95</span>, <span class="number">0x96</span>, <span class="number">0x97</span>,</span><br><span class="line">    <span class="number">0x98</span>, <span class="number">0x99</span>, <span class="number">0x9a</span>, <span class="number">0x9b</span>, <span class="number">0x9c</span>, <span class="number">0x9d</span>, <span class="number">0x9e</span>, <span class="number">0x9f</span>,</span><br><span class="line">    <span class="number">0xa0</span>, <span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>, <span class="number">0xa4</span>, <span class="number">0xa5</span>, <span class="number">0xa6</span>, <span class="number">0xa7</span>,</span><br><span class="line">    <span class="number">0xa8</span>, <span class="number">0xa9</span>, <span class="number">0xaa</span>, <span class="number">0xab</span>, <span class="number">0xac</span>, <span class="number">0xad</span>, <span class="number">0xae</span>, <span class="number">0xaf</span>,</span><br><span class="line">    <span class="number">0xb0</span>, <span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>, <span class="number">0xb4</span>, <span class="number">0xb5</span>, <span class="number">0xb6</span>, <span class="number">0xb7</span>,</span><br><span class="line">    <span class="number">0xb8</span>, <span class="number">0xb9</span>, <span class="number">0xba</span>, <span class="number">0xbb</span>, <span class="number">0xbc</span>, <span class="number">0xbd</span>, <span class="number">0xbe</span>, <span class="number">0xbf</span>,</span><br><span class="line">    <span class="number">0xc0</span>, <span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>, <span class="number">0xc4</span>, <span class="number">0xc5</span>, <span class="number">0xc6</span>, <span class="number">0xc7</span>,</span><br><span class="line">    <span class="number">0xc8</span>, <span class="number">0xc9</span>, <span class="number">0xca</span>, <span class="number">0xcb</span>, <span class="number">0xcc</span>, <span class="number">0xcd</span>, <span class="number">0xce</span>, <span class="number">0xcf</span>,</span><br><span class="line">    <span class="number">0xd0</span>, <span class="number">0xd1</span>, <span class="number">0xd2</span>, <span class="number">0xd3</span>, <span class="number">0xd4</span>, <span class="number">0xd5</span>, <span class="number">0xd6</span>, <span class="number">0xd7</span>,</span><br><span class="line">    <span class="number">0xd8</span>, <span class="number">0xd9</span>, <span class="number">0xda</span>, <span class="number">0xdb</span>, <span class="number">0xdc</span>, <span class="number">0xdd</span>, <span class="number">0xde</span>, <span class="number">0xdf</span>,</span><br><span class="line">    <span class="number">0xe0</span>, <span class="number">0xe1</span>, <span class="number">0xe2</span>, <span class="number">0xe3</span>, <span class="number">0xe4</span>, <span class="number">0xe5</span>, <span class="number">0xe6</span>, <span class="number">0xe7</span>,</span><br><span class="line">    <span class="number">0xe8</span>, <span class="number">0xe9</span>, <span class="number">0xea</span>, <span class="number">0xeb</span>, <span class="number">0xec</span>, <span class="number">0xed</span>, <span class="number">0xee</span>, <span class="number">0xef</span>,</span><br><span class="line">    <span class="number">0xf0</span>, <span class="number">0xf1</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>, <span class="number">0xf4</span>, <span class="number">0xf5</span>, <span class="number">0xf6</span>, <span class="number">0xf7</span>,</span><br><span class="line">    <span class="number">0xf8</span>, <span class="number">0xf9</span>, <span class="number">0xfa</span>, <span class="number">0xfb</span>, <span class="number">0xfc</span>, <span class="number">0xfd</span>, <span class="number">0xfe</span>, <span class="number">0xff</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译阶段会调用这个，  在<code>src/cmd/compile/internal/gc/walk.go</code> 中有相关代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> staticbytes == <span class="literal">nil</span> &#123;</span><br><span class="line">     staticbytes = newname(Runtimepkg.Lookup(<span class="string">"staticbytes"</span>)) <span class="comment">// 重 runtime 包中查找这个变量</span></span><br><span class="line">     staticbytes.SetClass(PEXTERN)</span><br><span class="line">     staticbytes.Type = types.NewArray(types.Types[TUINT8], <span class="number">256</span>)</span><br><span class="line">     zerobase = newname(Runtimepkg.Lookup(<span class="string">"zerobase"</span>))</span><br><span class="line">     zerobase.SetClass(PEXTERN)</span><br><span class="line">     zerobase.Type = types.Types[TUINTPTR]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Optimize convT2&#123;E,I&#125; for many cases in which T is not pointer-shaped,</span></span><br><span class="line"> <span class="comment">// by using an existing addressable value identical to n.Left</span></span><br><span class="line"> <span class="comment">// or creating one on the stack.</span></span><br><span class="line"> <span class="keyword">var</span> value *Node</span><br><span class="line"> <span class="keyword">switch</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> fromType.Size() == <span class="number">0</span>:</span><br><span class="line">     <span class="comment">// n.Left is zero-sized. Use zerobase.</span></span><br><span class="line">     cheapexpr(n.Left, init) <span class="comment">// Evaluate n.Left for side-effects. See issue 19246.</span></span><br><span class="line">     value = zerobase</span><br><span class="line"> <span class="keyword">case</span> fromType.IsBoolean() || (fromType.Size() == <span class="number">1</span> &amp;&amp; fromType.IsInteger()):</span><br><span class="line">     <span class="comment">// n.Left is a bool/byte. Use staticbytes[n.Left].</span></span><br><span class="line">     n.Left = cheapexpr(n.Left, init)</span><br><span class="line">     value = nod(OINDEX, staticbytes, byteindex(n.Left)) <span class="comment">// 编译时使用</span></span><br><span class="line">     value.SetBounded(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="iface-分析"><a href="#iface-分析" class="headerlink" title="iface 分析"></a><code>iface</code> 分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mather <span class="keyword">interface</span> &#123;</span><br><span class="line">        Add(a, b <span class="keyword">int32</span>) <span class="keyword">int32</span></span><br><span class="line">        Sub(a, b <span class="keyword">int64</span>) <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span>&#123; id <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Sub</span><span class="params">(a, b <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123; <span class="keyword">return</span> a - b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">        m := Mather(adder)</span><br><span class="line">		m.Add(<span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line">		m.Sub(<span class="number">19</span>, <span class="number">4</span>)</span><br><span class="line">        i := *(*iface)(unsafe.Pointer(&amp;m))</span><br><span class="line">        fmt.Printf(<span class="string">"%+v\n"</span>, i)</span><br><span class="line">		fmt.Printf(<span class="string">"%+v\n"</span>, *(*Adder)(i.data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">        tab  *itab</span><br><span class="line">        data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">        inter *interfacetype</span><br><span class="line">        _type *_type</span><br><span class="line">        hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">        _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">        fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">        typ     _type</span><br><span class="line">        pkgpath name</span><br><span class="line">        mhdr    []imethod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See reflect/type.go for details.</span></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;</span><br><span class="line">        bytes *<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line">        name nameOff</span><br><span class="line">        ityp typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">        size       <span class="keyword">uintptr</span></span><br><span class="line">        ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">        hash       <span class="keyword">uint32</span></span><br><span class="line">        tflag      tflag</span><br><span class="line">        align      <span class="keyword">uint8</span></span><br><span class="line">        fieldalign <span class="keyword">uint8</span></span><br><span class="line">        kind       <span class="keyword">uint8</span></span><br><span class="line">        alg        *typeAlg</span><br><span class="line">        <span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">        <span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">        <span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">        gcdata    *<span class="keyword">byte</span></span><br><span class="line">        str       nameOff</span><br><span class="line">        ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tflag <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// function for hashing objects of this type</span></span><br><span class="line">        <span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">        hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">        // <span class="title">function</span> <span class="title">for</span> <span class="title">comparing</span> <span class="title">objects</span> <span class="title">of</span> <span class="title">this</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">        // <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function">        <span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">nameOff</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">typeOff</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure>
<p>对应的汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">377</span> args=<span class="number">0x0</span> locals=<span class="number">0xc8</span></span><br><span class="line">    <span class="number">0x002f</span> <span class="number">00047</span> (main.go:<span class="number">22</span>)   MOVL    <span class="number">$0</span>, <span class="string">""</span>.adder+<span class="number">68</span>(<span class="built_in">SP</span>) <span class="comment">; 初始化一个addr, 默认值都是空的</span></span><br><span class="line">    <span class="number">0x0037</span> <span class="number">00055</span> (main.go:<span class="number">22</span>)   MOVL    <span class="number">$6754</span>, <span class="string">""</span>.adder+<span class="number">68</span>(<span class="built_in">SP</span>) <span class="comment">; 对 Addr.id 字段进行赋值</span></span><br><span class="line">    <span class="number">0x003f</span> <span class="number">00063</span> (main.go:<span class="number">23</span>)   MOVL    <span class="number">$6754</span>, (<span class="built_in">SP</span>) <span class="comment">; 将id的值放到栈底，作为 convT32的参数</span></span><br><span class="line">    <span class="number">0x0046</span> <span class="number">00070</span> (main.go:<span class="number">23</span>)   <span class="keyword">CALL</span>    runtime.convT32(SB) <span class="comment">; 入参是 id, 输出的 值是转换后的unsafe.Pointer</span></span><br><span class="line">    <span class="number">0x004b</span> <span class="number">00075</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; 返回值从 8(SP) 的位置，复制到寄存器 AX</span></span><br><span class="line">    <span class="number">0x0050</span> <span class="number">00080</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_5+<span class="number">80</span>(<span class="built_in">SP</span>) <span class="comment">; 将返回值从 AX 复制到临时变量autotmp_5 的位置</span></span><br><span class="line">    <span class="number">0x0055</span> <span class="number">00085</span> (main.go:<span class="number">23</span>)   LEAQ    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather(SB), <span class="built_in">CX</span> <span class="comment">; 将 Adder 的 itab转换为 Mather 类型，并将地址放到 CX</span></span><br><span class="line">    <span class="number">0x005c</span> <span class="number">00092</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.m+<span class="number">104</span>(<span class="built_in">SP</span>) <span class="comment">; 将 CX 寄存器中的 itab 地址赋值给 m.tab</span></span><br><span class="line">    <span class="number">0x0061</span> <span class="number">00097</span> (main.go:<span class="number">23</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.m+<span class="number">112</span>(<span class="built_in">SP</span>) <span class="comment">; 将 AX 寄存器中的 unsafe.Pointer 的 表示的值，赋值给 m.data</span></span><br></pre></td></tr></table></figure></p>
<p>重点关注<code>main.go:22</code> 和<code>main.go:23</code>, 首先看一下<code>main.go:22</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的细节:</p>
<ol>
<li><code>struct</code> 的 赋值是先对其赋值为空，然后再一个字段一个字段赋值，字段在栈中的排列跟定义的顺序有关系，是紧密排列的，并且存在对齐的问题</li>
</ol>
<p>然后看如何把<code>Adder</code>类型转换为<code>Mather</code>接口类型的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := Mather(adder)</span><br></pre></td></tr></table></figure></p>
<p>具体赋值的 步骤前面汇编部分的注释已经说明了， 这里需要注意的几个细节:</p>
<ol>
<li><code>iface</code>类型与<code>eface</code>不通，有<code>tab</code>和<code>data</code> 两个字段，分别是<code>*itab</code>和<code>unsafe.Pointer</code>两个类型</li>
<li><code>go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), CX</code> 将 Adder 的 itab转换为 Mather 类型，并将地址放到 CX, <strong>具体如何实现的，还没有找到查看方法，需要继续研究</strong></li>
</ol>
<p><code>itab</code>类型也无法直接查看，这里通过<code>unsafe</code>进行转换，在通过<code>dlv</code>进行查看:</p>
<ol>
<li><p>转换代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := *(*iface)(unsafe.Pointer(&amp;m))</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 dlv 在此处打断点查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p i</span><br><span class="line">main.iface &#123;</span><br><span class="line">        tab: *main.itab &#123;</span><br><span class="line">                inter: *(*main.interfacetype)(0x4c0360),</span><br><span class="line">                _type: *(*main._type)(0x4c63e0),</span><br><span class="line">                hash: 1633631626,</span><br><span class="line">                _: [4]uint8 [0,0,0,0],</span><br><span class="line">                fun: [1]uintptr [4867136],&#125;,</span><br><span class="line">        data: unsafe.Pointer(0xc000080010),&#125;</span><br><span class="line"></span><br><span class="line">(dlv) p i.tab</span><br><span class="line">*main.itab &#123;</span><br><span class="line">        inter: *main.interfacetype &#123;</span><br><span class="line">                typ: (*main._type)(0x4c0360),</span><br><span class="line">                pkgpath: (*main.name)(0x4c0390),</span><br><span class="line">                mhdr: []main.imethod len: 2, cap: 2, [</span><br><span class="line">                        (*main.imethod)(0x4c03c0),</span><br><span class="line">                        (*main.imethod)(0x4c03c8),</span><br><span class="line">                ],&#125;,</span><br><span class="line">        _type: *main._type &#123;</span><br><span class="line">                size: 4,</span><br><span class="line">                ptrdata: 0,</span><br><span class="line">                hash: 1633631626,</span><br><span class="line">                tflag: 7,</span><br><span class="line">                align: 4,</span><br><span class="line">                fieldalign: 4,</span><br><span class="line">                kind: 153,</span><br><span class="line">                alg: *(*main.typeAlg)(0x57bde0),</span><br><span class="line">                gcdata: *1,</span><br><span class="line">                str: 14386,</span><br><span class="line">                ptrToThis: 105952,&#125;,</span><br><span class="line">        hash: 1633631626,</span><br><span class="line">        _: [4]uint8 [0,0,0,0],</span><br><span class="line">        fun: [1]uintptr [4867136],&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>关于<code>itab</code>类型是包含接口的静态类型信息、数据的动态类型信息、函数表的结构, 在源码中的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123;</span><br><span class="line">    inter *interfacetype //  本实例所实现的接口的类型信息,  用于定位到具体的 interface, 这个是在编译时确定的</span><br><span class="line">    _type *_type //  本实例的具体数据的类型信息, 参考前面 _type 类型的定义 </span><br><span class="line">    hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">    _     [4]byte</span><br><span class="line">    // fun 表示的 interface 里面的 method 的具体实现</span><br><span class="line">    // 这里放置和接口方法对应的具体数据类型的方法地址</span><br><span class="line">    // 实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时</span><br><span class="line">    // 会更新此表，或者直接拿缓存的itab</span><br><span class="line">    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// interfacetype 只是对于 _type 的一种包装，在其顶部空间还包装了额外的 interface 相关的元信息</span><br><span class="line">type interfacetype struct &#123;</span><br><span class="line">    typ     _type // 所实现的接口的类型</span><br><span class="line">    pkgpath name  // 所实现的接口的定义路径</span><br><span class="line">    mhdr    []imethod //   所实现的接口在定义时的函数声明列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里的 method 只是一种函数声明的抽象，比如  func Print() error</span><br><span class="line">type imethod struct &#123;</span><br><span class="line">    name nameOff</span><br><span class="line">    ityp typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的点:</p>
<ol>
<li><code>func</code>表示的 interface 里面的 method 的具体实现, 比如这里的两个方法<code>Sub</code>和<code>Add</code>， 但是<code>func</code>的长度为1， 该如何表示多个方法呢?<br>看一下函数调用:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.Add(<span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line">m.Sub(<span class="number">19</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对应的汇编:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0066</span> <span class="number">00102</span> (main.go:<span class="number">24</span>)   TESTB   <span class="built_in">AL</span>, (<span class="built_in">CX</span>)<span class="comment">; 求与 AL &amp; (CX), 检查 CX 是否为 nil, AL 是 AX 的低8位, AH 是 AX 的高8位</span></span><br><span class="line"><span class="number">0x0068</span> <span class="number">00104</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    go.itab.<span class="string">""</span>.Adder,<span class="string">""</span>.Mather+<span class="number">24</span>(SB), <span class="built_in">CX</span> <span class="comment">; Add函数的入口地址放到 CX</span></span><br><span class="line"><span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0073</span> <span class="number">00115</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="number">$8589934604</span>, <span class="built_in">AX</span> <span class="comment">; 将 12, 2两个参数赋值到 AX 中</span></span><br><span class="line"><span class="number">0x007d</span> <span class="number">00125</span> (main.go:<span class="number">24</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; 将 AX 中的参数赋值到 8(SP) 位置</span></span><br><span class="line"><span class="number">0x0082</span> <span class="number">00130</span> (main.go:<span class="number">24</span>)   <span class="keyword">CALL</span>    <span class="built_in">CX</span> <span class="comment">; 调用 m.Add</span></span><br><span class="line"><span class="number">0x0084</span> <span class="number">00132</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.m+<span class="number">104</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span> <span class="comment">; 前面看到这个位置是 m.tab 的值</span></span><br><span class="line"><span class="number">0x0089</span> <span class="number">00137</span> (main.go:<span class="number">25</span>)   TESTB   <span class="built_in">AL</span>, (<span class="built_in">AX</span>)<span class="comment">; 检查 AX 是否为 nil</span></span><br><span class="line"><span class="number">0x008b</span> <span class="number">00139</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">32</span>(<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; (AX)地址 + 32 偏移，指向 Sub</span></span><br><span class="line"><span class="number">0x008f</span> <span class="number">00143</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="string">""</span>.m+<span class="number">112</span>(<span class="built_in">SP</span>), <span class="built_in">CX</span> <span class="comment">; 这个位置是 m.data 的值</span></span><br><span class="line"><span class="number">0x0094</span> <span class="number">00148</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x0098</span> <span class="number">00152</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">$19</span>, <span class="number">8</span>(<span class="built_in">SP</span>) <span class="comment">; 把参数 19 放到 8(SP) 位置</span></span><br><span class="line"><span class="number">0x00a1</span> <span class="number">00161</span> (main.go:<span class="number">25</span>)   <span class="keyword">MOVQ</span>    <span class="number">$4</span>, <span class="number">16</span>(<span class="built_in">SP</span>) <span class="comment">; 把参数 4 放到 16(SP) 位置</span></span><br><span class="line"><span class="number">0x00aa</span> <span class="number">00170</span> (main.go:<span class="number">25</span>)   <span class="keyword">CALL</span>    <span class="built_in">AX</span> <span class="comment">; 调用 m.Sub</span></span><br></pre></td></tr></table></figure>
<p> 需要注意的细节:</p>
<ol>
<li><p><code>TESTB AL, (CX)</code>是把 <code>AL &amp; (CX)</code> 位与的值放到 (CX) 中, 参考: <a href="https://github.com/golang/go/issues/10432" target="_blank" rel="noopener">https://github.com/golang/go/issues/10432</a> &amp; <a href="https://github.com/golang/go/issues/27180" target="_blank" rel="noopener">https://github.com/golang/go/issues/27180</a>, 这个步骤其实是为了检查 CX 是否为 nil， 如果是 nil 就没法调用这个函数了</p>
</li>
<li><p><code>MOVQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather+24(SB), CX</code> 这个为什么是取到了<code>Add</code>的地址?<br>看一下<code>itab</code>的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  <span class="keyword">uint32</span> </span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当前机器是64位的，所以可以看出<code>func</code> 相对于<code>itab</code>起始地址的偏移量为:<br><code>8(*interfacetype) + 8(*_type) + 4(uint32) + 4(byte=uint8) = 24</code><br>所以 <code>MOVQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather+24(SB)</code> 其实就是<code>func</code>的第一个函数<code>Add</code>的地址</p>
</li>
<li><p>函数<code>Sub</code>的地址为什么是<code>32(AX)</code>?<br>可以从前面一句<code>MOVQ    &quot;&quot;.m+104(SP), AX</code> 得出: <code>AX</code>目前指向的是<code>m.tab</code>, 也就是<code>itab</code>类型的起始地址，<code>32(AX)</code>就是相对<code>AX</code>有32位的偏移，前面说了相对<code>itab</code> <code>24</code>位的偏移其实时<code>Add</code>函数，然后对于64位系统，函数地址占<code>8</code>位，所以<code>32(AX)</code>就是下一个函数<code>Sub</code>的地址。 </p>
</li>
<li><p>前面只有两个函数，我们如果调换一下接口定义中两个函数的位置，发现生成的汇编是一样的，也就是:<strong>函数顺序与定义的顺序无关</strong>, 如果增加几个函数就可以看出来，其实:<strong> 函数在<code>func</code> 中的顺序是按照函数名的字典顺序排列的</strong></p>
</li>
<li><p><code>MOVQ    $8589934604, AX</code> 为什么是参数赋值?<br>这个其实我们可以对常量<code>8589934604</code> 进行分析，首先把它转化为二进制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;obase=2;8589934604&apos; | bc</span><br><span class="line">1000000000000000000000000000001100</span><br></pre></td></tr></table></figure>
<p>得到的数据其实是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">| 0000001000000000000000000000000000001100 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">  \______/\______________________________/  </span><br><span class="line">   +---+             +----+                 </span><br><span class="line">   | 2 |             | 12 |                 </span><br><span class="line">   +---+             +----+</span><br></pre></td></tr></table></figure>
<p>其实就是<code>2</code>和<code>12</code>两个<code>8</code>字节的数据组合在一起放到了<code>AX</code>寄存器中, 正是<code>Add(12,2)</code>的两个参数。</p>
</li>
</ol>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><code>interface{}</code> 是一个抽象的类型，如果需要转换为具体的类型，则需要类型断言, 类型断言其实有两个:</p>
<ol>
<li>类型判断: 判断类型是否一致</li>
<li>类型转换: 类型一致取出具体的数据</li>
</ol>
<p>下面看一个例子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">uint32</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> eface <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertion</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="keyword">uint64</span>(<span class="number">42</span>)</span><br><span class="line">    eface = i</span><br><span class="line">    j = eface.(<span class="keyword">uint32</span>)</span><br><span class="line">    r, ok = eface.(<span class="keyword">int32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的汇编语言如下:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0066</span> <span class="number">00102</span> (eface.go:<span class="number">11</span>)  MOVL    <span class="number">$0</span>, <span class="string">""</span>..autotmp_1+<span class="number">36</span>(<span class="built_in">SP</span>) <span class="comment">; 初始化0值</span></span><br><span class="line"><span class="number">0x006e</span> <span class="number">00110</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="string">""</span>.eface+<span class="number">8</span>(SB), <span class="built_in">AX</span> <span class="comment">; 把 data 放到 AX 寄存器</span></span><br><span class="line"><span class="number">0x0075</span> <span class="number">00117</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="string">""</span>.eface(SB), <span class="built_in">CX</span> <span class="comment">; 把 _type 放到 CX 寄存器</span></span><br><span class="line"><span class="number">0x007c</span> <span class="number">00124</span> (eface.go:<span class="number">11</span>)  LEAQ    type.uint32(SB), <span class="built_in">DX</span> <span class="comment">; 把 uint32的_type 值放到 DX 寄存器</span></span><br><span class="line"><span class="number">0x0083</span> <span class="number">00131</span> (eface.go:<span class="number">11</span>)  CMPQ    <span class="built_in">CX</span>, <span class="built_in">DX</span><span class="comment">; 比较 eface._type == uint32 ?</span></span><br><span class="line"><span class="number">0x0086</span> <span class="number">00134</span> (eface.go:<span class="number">11</span>)  JEQ <span class="number">138</span> <span class="comment">; JEQ = jump if equal, 如果类型相等就跳转到 138行</span></span><br><span class="line"><span class="number">0x0088</span> <span class="number">00136</span> (eface.go:<span class="number">11</span>)  <span class="keyword">JMP</span> <span class="number">246</span> <span class="comment">;  类型不匹配, 跳转到 246 行, 出现 panic</span></span><br><span class="line"><span class="number">0x008a</span> <span class="number">00138</span> (eface.go:<span class="number">11</span>)  MOVL    (<span class="built_in">AX</span>), <span class="built_in">AX</span> <span class="comment">; JEQ 跳转的行 138, 把(AX)地址对应的值放到 AX 寄存器，也就是 eface.data</span></span><br><span class="line"><span class="number">0x008c</span> <span class="number">00140</span> (eface.go:<span class="number">11</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_1+<span class="number">36</span>(<span class="built_in">SP</span>) <span class="comment">; 临时变量赋值</span></span><br><span class="line"><span class="number">0x0090</span> <span class="number">00144</span> (eface.go:<span class="number">11</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.j(SB) <span class="comment">; 赋值给变量 j</span></span><br><span class="line"><span class="number">0x0096</span> <span class="number">00150</span> (eface.go:<span class="number">12</span>)  <span class="keyword">MOVQ</span>    <span class="string">""</span>.eface+<span class="number">8</span>(SB), <span class="built_in">AX</span> <span class="comment">;  把 data 放到 AX 寄存器</span></span><br><span class="line"><span class="number">0x009d</span> <span class="number">00157</span> (eface.go:<span class="number">12</span>)  LEAQ    type.int32(SB), <span class="built_in">CX</span> <span class="comment">; 把 int32 的_type 值放到 DX 寄存器</span></span><br><span class="line"><span class="number">0x00a4</span> <span class="number">00164</span> (eface.go:<span class="number">12</span>)  CMPQ    <span class="string">""</span>.eface(SB), <span class="built_in">CX</span> <span class="comment">; 比较 eface._type == int32 ?</span></span><br><span class="line"><span class="number">0x00ab</span> <span class="number">00171</span> (eface.go:<span class="number">12</span>)  JEQ <span class="number">175</span> <span class="comment">; 如果类型相等就跳转到 175 行</span></span><br><span class="line"><span class="number">0x00ad</span> <span class="number">00173</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">223</span> <span class="comment">; 跳转到 223 行，输出 panic</span></span><br><span class="line"><span class="number">0x00af</span> <span class="number">00175</span> (eface.go:<span class="number">12</span>)  MOVL    (<span class="built_in">AX</span>), <span class="built_in">AX</span><span class="comment">; 类型相等就把 data 放到 AX</span></span><br><span class="line"><span class="number">0x00b1</span> <span class="number">00177</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="number">$1</span>, <span class="built_in">CX</span> 把常量 <span class="number">1</span> 放到 <span class="built_in">CX</span></span><br><span class="line"><span class="number">0x00b6</span> <span class="number">00182</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">184</span> <span class="comment">; 调到 184 行</span></span><br><span class="line"><span class="number">0x00b8</span> <span class="number">00184</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x00bc</span> <span class="number">00188</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">CL</span>, <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>) <span class="comment">; CL 是 CX 的低 8 位</span></span><br><span class="line"><span class="number">0x00c0</span> <span class="number">00192</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x00c4</span> <span class="number">00196</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.r(SB) <span class="comment">; AX 是 data 的值， 放到 r 变量中</span></span><br><span class="line"><span class="number">0x00ca</span> <span class="number">00202</span> (eface.go:<span class="number">12</span>)  MOVBLZX <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; MOVBLZX 用 0 扩展，放到 autotmp_3 变量</span></span><br><span class="line"><span class="number">0x00cf</span> <span class="number">00207</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">AL</span>, <span class="string">""</span>.ok(SB)<span class="comment">; AL 低8位赋值给 ok ，因为ok 是 bool 类型的， 根据字节对齐，占 8 位</span></span><br><span class="line"><span class="number">0x00d5</span> <span class="number">00213</span> (eface.go:<span class="number">13</span>)  <span class="keyword">MOVQ</span>    <span class="number">56</span>(<span class="built_in">SP</span>), <span class="built_in">BP</span></span><br><span class="line"><span class="number">0x00da</span> <span class="number">00218</span> (eface.go:<span class="number">13</span>)  ADDQ    <span class="number">$64</span>, <span class="built_in">SP</span></span><br><span class="line"><span class="number">0x00de</span> <span class="number">00222</span> (eface.go:<span class="number">13</span>)  <span class="keyword">RET</span></span><br><span class="line"><span class="number">0x00df</span> <span class="number">00223</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">AX</span>, <span class="built_in">AX</span> <span class="comment">; eface.type != int32 情况下，执行本行, XOR是异或，所以 AX^AX , 结果为 0</span></span><br><span class="line"><span class="number">0x00e1</span> <span class="number">00225</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">CX</span>, <span class="built_in">CX</span><span class="comment">; 同上， CX 结果为 0</span></span><br><span class="line"><span class="number">0x00e3</span> <span class="number">00227</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">184</span> <span class="comment">; 跳转到 184 行执行，这里要注意的是 AX, CX 寄存器已经为0， 所有后面 ok 的值也位0了</span></span><br><span class="line"><span class="number">0x00e5</span> <span class="number">00229</span> (eface.go:<span class="number">10</span>)  LEAQ    <span class="string">""</span>.eface+<span class="number">8</span>(SB), <span class="built_in">DI</span></span><br><span class="line"><span class="number">0x00ec</span> <span class="number">00236</span> (eface.go:<span class="number">10</span>)  <span class="keyword">CALL</span>    runtime.gcWriteBarrier(SB)</span><br><span class="line"><span class="number">0x00f1</span> <span class="number">00241</span> (eface.go:<span class="number">10</span>)  <span class="keyword">JMP</span> <span class="number">102</span></span><br><span class="line"><span class="number">0x00f6</span> <span class="number">00246</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, (<span class="built_in">SP</span>) <span class="comment">; 一个返回值表达式类型不匹配时，执行到这里, CX 类型值放到(SP)作为第一个参数</span></span><br><span class="line"><span class="number">0x00fa</span> <span class="number">00250</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">DX</span>, <span class="number">8</span>(<span class="built_in">SP</span>)<span class="comment">; 想要的类型从 DX 放到 8(SP) 作为第二个参数</span></span><br><span class="line"><span class="number">0x00ff</span> <span class="number">00255</span> (eface.go:<span class="number">11</span>)  LEAQ    type.interface &#123;&#125;(SB), <span class="built_in">AX</span> <span class="comment">; interface 类型的地址放到 AX</span></span><br><span class="line"><span class="number">0x0106</span> <span class="number">00262</span> (eface.go:<span class="number">11</span>)  <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="number">16</span>(<span class="built_in">SP</span>)<span class="comment">; AX 值放到 16(SP) 作为第三个参数</span></span><br><span class="line"><span class="number">0x010b</span> <span class="number">00267</span> (eface.go:<span class="number">11</span>)  <span class="keyword">CALL</span>    runtime.panicdottypeE(SB)<span class="comment">; 执行函数调用，使用前面的三个参数，返回 panic</span></span><br></pre></td></tr></table></figure></p>
<p> 需要注意的点:</p>
<ol>
<li>当使用返回值为一个的表达式时，如果出现类型不匹配，会触发<code>panic</code></li>
<li><p>当使用两个返回值的表达式时,  <code>r</code>, <code>ok</code>的值随着<code>AX</code>, <code>CX</code>的值 改变:<br>分为两种情况:<br>当类型相等时: <code>AX</code> 值为<code>eface.data</code>, <code>CX</code> 的值为<code>1</code><br>赋值的过程如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00b8</span> <span class="number">00184</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x00bc</span> <span class="number">00188</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">CL</span>, <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>) <span class="comment">; CL 是 CX 的低 8 位, CX 是 1, 二进制是: 0000000000000001; CL 就是: 00000001</span></span><br><span class="line"><span class="number">0x00c0</span> <span class="number">00192</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x00c4</span> <span class="number">00196</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.r(SB) <span class="comment">; AX 是 data 的值， 放到 r 变量中</span></span><br><span class="line"><span class="number">0x00ca</span> <span class="number">00202</span> (eface.go:<span class="number">12</span>)  MOVBLZX <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; MOVBLZX 用 0 扩展，放到 autotmp_3 变量, autotmp_3 是 00000001, 扩展后是: 0000000000000001</span></span><br><span class="line"><span class="number">0x00cf</span> <span class="number">00207</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">AL</span>, <span class="string">""</span>.ok(SB)<span class="comment">; AL 低8位赋值给 ok ，因为ok 是 bool 类型的， 根据字节对齐，占 8 位, ok 值为: 00000001</span></span><br></pre></td></tr></table></figure>
<p>当类型不相等时: <code>AX</code>和<code>CX</code>的值都初始化位空</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00df</span> <span class="number">00223</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">AX</span>, <span class="built_in">AX</span> <span class="comment">; eface.type != int32 情况下，执行本行, XOR是异或，所以 AX^AX , 结果为 0</span></span><br><span class="line"><span class="number">0x00e1</span> <span class="number">00225</span> (eface.go:<span class="number">13</span>)  XORL    <span class="built_in">CX</span>, <span class="built_in">CX</span><span class="comment">; 同上， CX 结果为 0</span></span><br><span class="line"><span class="number">0x00e3</span> <span class="number">00227</span> (eface.go:<span class="number">12</span>)  <span class="keyword">JMP</span> <span class="number">184</span> <span class="comment">; 跳转到 184 行执行，这里要注意的是 AX, CX 寄存器已经为0， 所有后面 ok 的值也位0了</span></span><br></pre></td></tr></table></figure>
<p>赋值过程如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00b8</span> <span class="number">00184</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>)</span><br><span class="line"><span class="number">0x00bc</span> <span class="number">00188</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">CL</span>, <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>) <span class="comment">; CL 是 CX 的低 8 位, CX 是 0, 二进制是: 0000000000000000; CL 就是: 00000000</span></span><br><span class="line"><span class="number">0x00c0</span> <span class="number">00192</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="string">""</span>..autotmp_2+<span class="number">32</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></span><br><span class="line"><span class="number">0x00c4</span> <span class="number">00196</span> (eface.go:<span class="number">12</span>)  MOVL    <span class="built_in">AX</span>, <span class="string">""</span>.r(SB) <span class="comment">; AX 是 data 的值， 放到 r 变量中, AX 是空值，所以 r == nil</span></span><br><span class="line"><span class="number">0x00ca</span> <span class="number">00202</span> (eface.go:<span class="number">12</span>)  MOVBLZX <span class="string">""</span>..autotmp_3+<span class="number">31</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span><span class="comment">; MOVBLZX 用 0 扩展，放到 autotmp_3 变量, autotmp_3 是 00000000, 扩展后是: 0000000000000000</span></span><br><span class="line"><span class="number">0x00cf</span> <span class="number">00207</span> (eface.go:<span class="number">12</span>)  MOVB    <span class="built_in">AL</span>, <span class="string">""</span>.ok(SB)<span class="comment">; AL 低8位赋值给 ok ，因为ok 是 bool 类型的， 根据字节对齐，占 8 位, ok 值为: 00000000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献,"></a>参考文献,</h2><p><a href="https://yougg.github.io/2017/03/27/%E7%90%86%E8%A7%A3go%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B1interface%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">理解Go语言模型(1)：interface底层详解</a><br><a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">Go Data Structures: Interfaces</a><br><a href="https://www.ardanlabs.com/blog/2017/07/interface-semantics.html" target="_blank" rel="noopener">Interface Semantics</a><br><a href="https://github.com/two/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">go-internals chapter2 interfacs</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Go/">Go</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/12/go-converte-between-string-and-byte/"><span>go converte between string and byte slice</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/12/go-converte-between-string-and-byte/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-12T05:17:10.000Z">
          2019-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Go第一版代码<code>c</code>实现, 在<code>runtime/runtime.h</code>里:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">String</span>      <span class="title">String</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    byte*   str;</span><br><span class="line">    intgo   len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  String  runtime·emptystring;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>Go</code>中的<code>string</code>类型其实就是<code>String</code>这个类型。<br>之后<code>Go</code>实现了自举，从<code>runtime/string.go</code>中可以看到之前的影子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="todo-如何通过编译过程查找对应的类型定义"><a href="#todo-如何通过编译过程查找对应的类型定义" class="headerlink" title="todo: 如何通过编译过程查找对应的类型定义"></a>todo: 如何通过编译过程查找对应的类型定义</h3><h2 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h2><p><code>byte</code>的类型定义在 <code>builtin/builtin.go</code>中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uint8 is the set of all unsigned 8-bit integers.</span></span><br><span class="line"><span class="comment">// Range: 0 through 255.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">uint8</span> <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到其实<code>byte</code>是<code>uint8</code>的类型别名</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string-to-byte-slice"><a href="#string-to-byte-slice" class="headerlink" title="string to byte slice"></a>string to byte slice</h2><p>写一个<code>string</code>强制类型转换为<code>[]byte</code>的<code>demo</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">"strings"</span></span><br><span class="line">    <span class="keyword">var</span> b = []<span class="keyword">byte</span>(s)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过命令:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S -N -l main.go</span><br></pre></td></tr></table></figure></p>
<p>编译出汇编指令:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">317</span> args=<span class="number">0x0</span> locals=<span class="number">0xa8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (main.go:<span class="number">5</span>)    TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$168</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x002f</span> <span class="number">00047</span> (main.go:<span class="number">6</span>)    LEAQ    go.string.<span class="string">"strings"</span>(SB), <span class="built_in">AX</span></span><br><span class="line">    <span class="number">0x0036</span> <span class="number">00054</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.s+<span class="number">80</span>(<span class="built_in">SP</span>) # 把string内容放到这个位置</span><br><span class="line">    <span class="number">0x003b</span> <span class="number">00059</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="number">$7</span>, <span class="string">""</span>.s+<span class="number">88</span>(<span class="built_in">SP</span>) # 把string长度放到这个位置</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x005a</span> <span class="number">00090</span> (main.go:<span class="number">7</span>)    <span class="keyword">CALL</span>    runtime.stringtoslicebyte(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x008e</span> <span class="number">00142</span> (main.go:<span class="number">8</span>)    <span class="keyword">CALL</span>    runtime.convTslice(SB)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>上面可以看出当定义一个<code>string</code>时，其实会存储<code>string</code>的内容和长度, 对应前讲的<code>string</code>的结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct String</span><br><span class="line">&#123;</span><br><span class="line">    byte*   str;</span><br><span class="line">    intgo   len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后又调用了<code>runtime.stringtoslicebyte(SB)</code>, 在<code>runtime/string.go</code>中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123; <span class="comment">// 如果字符串的长度小于buf长度，直接使用buf</span></span><br><span class="line">        *buf = tmpBuf&#123;&#125;</span><br><span class="line">        b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = rawbyteslice(<span class="built_in">len</span>(s)) <span class="comment">// 否则调用这个进行内存申请</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(b, s) <span class="comment">// 内存 copy</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>buf</code>默认值是<code>32</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpStringBufSize = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tmpBuf [tmpStringBufSize]<span class="keyword">byte</span></span><br></pre></td></tr></table></figure></p>
<p>如果不满足长度，申请的内存大小为<code>len(s)</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawbyteslice</span><span class="params">(size <span class="keyword">int</span>)</span> <span class="params">(b []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">cap</span> := roundupsize(<span class="keyword">uintptr</span>(size))</span><br><span class="line">    p := mallocgc(<span class="built_in">cap</span>, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> != <span class="keyword">uintptr</span>(size) &#123;</span><br><span class="line">        memclrNoHeapPointers(add(p, <span class="keyword">uintptr</span>(size)), <span class="built_in">cap</span>-<span class="keyword">uintptr</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是类型的转换，把申请的内存变成一个slice结构，赋值给b的地址</span></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, <span class="keyword">int</span>(<span class="built_in">cap</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的过程重点有三个:</p>
<ol>
<li>当长度小于<code>32</code>时，直接使用临时内存地址</li>
<li>当长度大于<code>32</code>时，需要申请新的长度为<code>len(s)</code>的内存地址</li>
<li>需要进行内存的<code>copy</code></li>
</ol>
<h2 id="byte-slice-to-string"><a href="#byte-slice-to-string" class="headerlink" title="byte slice to string"></a>byte slice to string</h2><p>下面返回来，把一个<code>[]byte</code>转换为<code>string</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b = []<span class="keyword">byte</span>&#123;<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">string</span>(b)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的汇编代码是:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">371</span> args=<span class="number">0x0</span> locals=<span class="number">0xb8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (main.go:<span class="number">5</span>)    TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$184</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x005b</span> <span class="number">00091</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.b+<span class="number">128</span>(<span class="built_in">SP</span>) # 把slice内容放到这个位置</span><br><span class="line">    <span class="number">0x0063</span> <span class="number">00099</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="number">$3</span>, <span class="string">""</span>.b+<span class="number">136</span>(<span class="built_in">SP</span>) # 把slice len 放到这个位置</span><br><span class="line">    <span class="number">0x006f</span> <span class="number">00111</span> (main.go:<span class="number">6</span>)    <span class="keyword">MOVQ</span>    <span class="number">$3</span>, <span class="string">""</span>.b+<span class="number">144</span>(<span class="built_in">SP</span>) # 把slice cap 放到这个位置</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00a2</span> <span class="number">00162</span> (main.go:<span class="number">7</span>)    <span class="keyword">CALL</span>    runtime.slicebytetostring(SB) #调用这个函数进行转换</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00c4</span> <span class="number">00196</span> (main.go:<span class="number">8</span>)    <span class="keyword">CALL</span>    runtime.convTstring(SB)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>上面可以看出当定义一个<code>slice</code>时，其实会存储<code>slice</code>的内容和长度和容量, 对应之前讲的<code>slice</code>的结构:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后调用<code>runtime.slicebytetostring</code>函数, 在<code>runtime/string.go</code>中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buf is a fixed-size buffer for the result,</span></span><br><span class="line"><span class="comment">// it is not nil if the result does not escape.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, b []<span class="keyword">byte</span>)</span> <span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(b)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Turns out to be a relatively common case.</span></span><br><span class="line">        <span class="comment">// Consider that you want to parse out data between parens in "foo()bar",</span></span><br><span class="line">        <span class="comment">// you find the indices and convert the subslice to string.</span></span><br><span class="line">        <span class="comment">// 长度为0，直接返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为1，直接返回staticbytes[b[0]]这个提前设定好的地址内容</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// stringStruct结构的str字段指向对应的值得地址</span></span><br><span class="line">        stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="number">0</span>]])</span><br><span class="line">        <span class="comment">// stringStruct结构的len字段设置为1</span></span><br><span class="line">        stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">        p = unsafe.Pointer(buf)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = mallocgc(<span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stringStructOf(&amp;str).str = p</span><br><span class="line">    stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="built_in">len</span>(b)</span><br><span class="line">    memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/04/go-select/"><span>go select 原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/04/go-select/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-04T06:25:40.000Z">
          2019-07-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本篇主要介绍 <code>select</code> 的内部实现原理(基于go1.12), 通过源码和图形的方式展示 <code>select</code> 的内部结构及对<code>select</code> 进行操作的过程。</p>
</blockquote>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Go官方给出的<a href="https://tour.golang.org/concurrency/5" target="_blank" rel="noopener">例子</a>很简单:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出<code>Select</code>和<code>Switch</code>使用方法有点相似，不一样的地方在于:<strong><code>Select</code>的<code>case</code>条件必须是与<code>chan</code>相关的操作（从<code>chan</code>发送或者接收数据）</strong></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>关于<code>select</code>的编译过程可以从<code>$GOROOT/src/cmd/compile/internal/gc/select.go</code>中找到。</p>
<h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>为了研究代码的运行逻辑，我们可以借助针对<code>Go</code>开发的<code>debug</code>工具:<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">dlv</a>, 我们通过:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build  -gcflags=<span class="string">"all=-N -l"</span> <span class="variable">$GOROOT</span>/src/cmd/compile</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以使用对<code>compile</code>工具进行<code>debug</code>了, 通过下面的方式运行:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv <span class="built_in">exec</span> compile <span class="variable">$GOROOT</span>/src/cmd/compile/internal/gc/select.go</span><br></pre></td></tr></table></figure></p>
<p>然后分别给我们想要<code>debug</code>的地方打断点</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>我们对<code>typecheckselect</code>和<code>walkselect</code>函数打断点，可以知道运行顺序是<code>typecheckselect</code> -&gt; <code>walkselect</code>。<br>首先我们先来看<code>typecheckselect</code>函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckselect</span><span class="params">(sel *Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> def *Node</span><br><span class="line">    lno := setlineno(sel)</span><br><span class="line">    typecheckslice(sel.Ninit.Slice(), ctxStmt)</span><br><span class="line">    <span class="comment">// 遍历检查所有的case</span></span><br><span class="line">    <span class="keyword">for</span> _, ncase := <span class="keyword">range</span> sel.List.Slice() &#123;</span><br><span class="line">        <span class="comment">// 处理之前对每个case先进行检查是否是空的</span></span><br><span class="line">        <span class="keyword">if</span> ncase.Op != OXCASE &#123;</span><br><span class="line">            setlineno(ncase)</span><br><span class="line">            Fatalf(<span class="string">"typecheckselect %v"</span>, ncase.Op)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 后面是空条件，这种情况说明是default</span></span><br><span class="line">        <span class="keyword">if</span> ncase.List.Len() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// default</span></span><br><span class="line">            <span class="keyword">if</span> def != <span class="literal">nil</span> &#123;</span><br><span class="line">                yyerrorl(ncase.Pos, <span class="string">"multiple defaults in select (first at %v)"</span>, def.Line())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                def = ncase</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ncase.List.Len() &gt; <span class="number">1</span> &#123; <span class="comment">// case的值不支持多个表达式</span></span><br><span class="line">            yyerrorl(ncase.Pos, <span class="string">"select cases cannot be lists"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// case 只有一个表达式</span></span><br><span class="line">            ncase.List.SetFirst(typecheck(ncase.List.First(), ctxStmt))</span><br><span class="line">            n := ncase.List.First() <span class="comment">// 把case的第一个表达式赋值给 n</span></span><br><span class="line">            ncase.Left = n</span><br><span class="line">            ncase.List.Set(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">switch</span> n.Op &#123; <span class="comment">// 对 case 的具体操作进行检查</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 对于未知类型的case 进行下面的处理</span></span><br><span class="line">                pos := n.Pos</span><br><span class="line">                <span class="keyword">if</span> n.Op == ONAME &#123;</span><br><span class="line">                    <span class="comment">// We don't have the right position for ONAME nodes (see #15459 and</span></span><br><span class="line">                    <span class="comment">// others). Using ncase.Pos for now as it will provide the correct</span></span><br><span class="line">                    <span class="comment">// line number (assuming the expression follows the "case" keyword</span></span><br><span class="line">                    <span class="comment">// on the same line). This matches the approach before 1.10.</span></span><br><span class="line">                    pos = ncase.Pos</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  打印错误，只接受下面的几个类型</span></span><br><span class="line">                yyerrorl(pos, <span class="string">"select case must be receive, send or assign recv"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert x = &lt;-c into OSELRECV(x, &lt;-c).</span></span><br><span class="line">            <span class="comment">// remove implicit conversions; the eventual assignment</span></span><br><span class="line">            <span class="comment">// will reintroduce them.</span></span><br><span class="line">            <span class="comment">// 处理 case 为 x = &lt;-c 的表达式</span></span><br><span class="line">            <span class="keyword">case</span> OAS:</span><br><span class="line">                <span class="keyword">if</span> (n.Right.Op == OCONVNOP || n.Right.Op == OCONVIFACE) &amp;&amp; n.Right.Implicit() &#123;</span><br><span class="line">                    n.Right = n.Right.Left</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n.Right.Op != ORECV &#123;</span><br><span class="line">                    yyerrorl(n.Pos, <span class="string">"select assignment must have receive on right hand side"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n.Op = OSELRECV</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert x, ok = &lt;-c into OSELRECV2(x, &lt;-c) with ntest=ok</span></span><br><span class="line">            <span class="comment">// 处理 case 为 x, ok = &lt;-c 的表达式</span></span><br><span class="line">            <span class="keyword">case</span> OAS2RECV:</span><br><span class="line">                <span class="keyword">if</span> n.Rlist.First().Op != ORECV &#123;</span><br><span class="line">                    yyerrorl(n.Pos, <span class="string">"select assignment must have receive on right hand side"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n.Op = OSELRECV2</span><br><span class="line">                n.Left = n.List.First()</span><br><span class="line">                n.List.Set1(n.List.Second())</span><br><span class="line">                n.Right = n.Rlist.First()</span><br><span class="line">                n.Rlist.Set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert &lt;-c into OSELRECV(N, &lt;-c)</span></span><br><span class="line">            <span class="comment">// 处理 case 为 &lt;-c 的表达式</span></span><br><span class="line">            <span class="keyword">case</span> ORECV:</span><br><span class="line">                n = nodl(n.Pos, OSELRECV, <span class="literal">nil</span>, n)</span><br><span class="line"></span><br><span class="line">                n.SetTypecheck(<span class="number">1</span>)</span><br><span class="line">                ncase.Left = n</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OSEND: <span class="comment">// 无需要做特殊处理</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        typecheckslice(ncase.Nbody.Slice(), ctxStmt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lineno = lno</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再来看<code>walkselect</code>函数, 这个函数主要是对每个<code>case</code>进行处理，真正处理每个<code>case</code>的函数是<code>walkselectcases</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkselectcases</span><span class="params">(cases *Nodes)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line">    n := cases.Len()</span><br><span class="line">    sellineno := lineno</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optimization: zero-case select</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optimization: one-case select: single op.</span></span><br><span class="line">    <span class="comment">// TODO(rsc): Reenable optimization once order.go can handle it.</span></span><br><span class="line">    <span class="comment">// golang.org/issue/7672.</span></span><br><span class="line">    <span class="comment">// 处理只有一个 case 的情况</span></span><br><span class="line">    <span class="comment">// 处理结果是优化成: if xx &#123;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        cas := cases.First()</span><br><span class="line">        setlineno(cas)</span><br><span class="line">        l := cas.Ninit.Slice()</span><br><span class="line">        <span class="keyword">if</span> cas.Left != <span class="literal">nil</span> &#123; <span class="comment">// not default:</span></span><br><span class="line">            n := cas.Left</span><br><span class="line">            l = <span class="built_in">append</span>(l, n.Ninit.Slice()...)</span><br><span class="line">            n.Ninit.Set(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">var</span> ch *Node</span><br><span class="line">            <span class="keyword">switch</span> n.Op &#123; <span class="comment">// 根据操作符对齐进行词法分析，重新构造AST</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ok already</span></span><br><span class="line">            <span class="keyword">case</span> OSEND:</span><br><span class="line">                ch = n.Left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">                ch = n.Right.Left</span><br><span class="line">                <span class="keyword">if</span> n.Op == OSELRECV || n.List.Len() == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> n.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">                        n = n.Right</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        n.Op = OAS <span class="comment">// 转化为 Left = Right 表达式</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> n.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">                    nblank = typecheck(nblank, ctxExpr|ctxAssign)</span><br><span class="line">                    n.Left = nblank</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n.Op = OAS2 <span class="comment">//  转化为多赋值表达式:  List = Rlist (x, y, z = a, b, c)</span></span><br><span class="line">                n.List.Prepend(n.Left)</span><br><span class="line">                n.Rlist.Set1(n.Right)</span><br><span class="line">                n.Right = <span class="literal">nil</span></span><br><span class="line">                n.Left = <span class="literal">nil</span></span><br><span class="line">                n.SetTypecheck(<span class="number">0</span>)</span><br><span class="line">                n = typecheck(n, ctxStmt)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if ch == nil &#123; block() &#125;; n; // 转换为 if ch == nil &#123; block() &#125; 表达式</span></span><br><span class="line">            a := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>) <span class="comment">// 转化为: if Ninit; Left &#123; Nbody &#125; else &#123; Rlist &#125;</span></span><br><span class="line"></span><br><span class="line">            a.Left = nod(OEQ, ch, nodnil()) <span class="comment">// a.Left 转化为:  Left == Right, 既: ch == nil</span></span><br><span class="line">            <span class="keyword">var</span> ln Nodes</span><br><span class="line">            ln.Set(l)</span><br><span class="line">            a.Nbody.Set1(mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, &amp;ln)) <span class="comment">// Body 变为 block 调用</span></span><br><span class="line">            l = ln.Slice()</span><br><span class="line">            a = typecheck(a, ctxStmt)</span><br><span class="line">            l = <span class="built_in">append</span>(l, a, n)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l = <span class="built_in">append</span>(l, cas.Nbody.Slice()...)</span><br><span class="line">        l = <span class="built_in">append</span>(l, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert case value arguments to addresses.</span></span><br><span class="line">    <span class="comment">// this rewrite is used by both the general code and the next optimization.</span></span><br><span class="line">    <span class="comment">// 存在多个 case, 分别处理</span></span><br><span class="line">    <span class="keyword">for</span> _, cas := <span class="keyword">range</span> cases.Slice() &#123;</span><br><span class="line">        setlineno(cas)</span><br><span class="line">        n := cas.Left</span><br><span class="line">        <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">        <span class="keyword">case</span> OSEND:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optimization: two-case select but one is default: single non-blocking op.</span></span><br><span class="line">    <span class="comment">// 处理只有两个 case, 并且其中一个是 default 的情况</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &amp;&amp; (cases.First().Left == <span class="literal">nil</span> || cases.Second().Left == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cas *Node <span class="comment">// 非 default case</span></span><br><span class="line">        <span class="keyword">var</span> dflt *Node <span class="comment">// default case</span></span><br><span class="line">        <span class="keyword">if</span> cases.First().Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            cas = cases.Second() </span><br><span class="line">            dflt = cases.First()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dflt = cases.Second()</span><br><span class="line">            cas = cases.First()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n := cas.Left</span><br><span class="line">        setlineno(n)</span><br><span class="line">        r := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        r.Ninit.Set(cas.Ninit.Slice())</span><br><span class="line">        <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OSEND:</span><br><span class="line">            <span class="comment">// if selectnbsend(c, v) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">            ch := n.Left</span><br><span class="line">            r.Left = mkcall1(chanfn(<span class="string">"selectnbsend"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, ch, n.Right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OSELRECV:</span><br><span class="line">            <span class="comment">// if selectnbrecv(&amp;v, c) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">            ...</span><br><span class="line">            r.Left = mkcall1(chanfn(<span class="string">"selectnbrecv"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, elem, ch)</span><br><span class="line">        <span class="keyword">case</span> OSELRECV2:</span><br><span class="line">            <span class="comment">// if selectnbrecv2(&amp;v, &amp;received, c) &#123; body &#125; else &#123; default body &#125;   </span></span><br><span class="line">            ...</span><br><span class="line">            r.Left = mkcall1(chanfn(<span class="string">"selectnbrecv2"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, elem, receivedp, ch)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.Left = typecheck(r.Left, ctxExpr)</span><br><span class="line">        r.Nbody.Set(cas.Nbody.Slice())</span><br><span class="line">        r.Rlist.Set(<span class="built_in">append</span>(dflt.Ninit.Slice(), dflt.Nbody.Slice()...))</span><br><span class="line">        <span class="keyword">return</span> []*Node&#123;r, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> init []*Node</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate sel-struct</span></span><br><span class="line">    lineno = sellineno</span><br><span class="line">    selv := temp(types.NewArray(scasetype(), <span class="keyword">int64</span>(n)))</span><br><span class="line">    r := nod(OAS, selv, <span class="literal">nil</span>)</span><br><span class="line">    r = typecheck(r, ctxStmt)</span><br><span class="line">    init = <span class="built_in">append</span>(init, r)</span><br><span class="line"></span><br><span class="line">    order := temp(types.NewArray(types.Types[TUINT16], <span class="number">2</span>*<span class="keyword">int64</span>(n)))</span><br><span class="line">    r = nod(OAS, order, <span class="literal">nil</span>)</span><br><span class="line">    r = typecheck(r, ctxStmt)</span><br><span class="line">    init = <span class="built_in">append</span>(init, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register cases</span></span><br><span class="line">    <span class="keyword">for</span> i, cas := <span class="keyword">range</span> cases.Slice() &#123; <span class="comment">// 其它 case 的情况处理</span></span><br><span class="line">        setlineno(cas)</span><br><span class="line"></span><br><span class="line">        init = <span class="built_in">append</span>(init, cas.Ninit.Slice()...)</span><br><span class="line">        cas.Ninit.Set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep in sync with runtime/select.go.</span></span><br><span class="line">        <span class="keyword">const</span> (</span><br><span class="line">            caseNil = <span class="literal">iota</span></span><br><span class="line">            caseRecv</span><br><span class="line">            caseSend</span><br><span class="line">            caseDefault</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> c, elem *Node</span><br><span class="line">        <span class="keyword">var</span> kind <span class="keyword">int64</span> = caseDefault</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n := cas.Left; n != <span class="literal">nil</span> &#123;</span><br><span class="line">            init = <span class="built_in">append</span>(init, n.Ninit.Slice()...)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line">            <span class="keyword">case</span> OSEND:</span><br><span class="line">                kind = caseSend</span><br><span class="line">                c = n.Left</span><br><span class="line">                elem = n.Right</span><br><span class="line">            <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">                kind = caseRecv</span><br><span class="line">                c = n.Right.Left</span><br><span class="line">                elem = n.Left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setField := <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>, val *Node)</span></span> &#123;</span><br><span class="line">            r := nod(OAS, nodSym(ODOT, nod(OINDEX, selv, nodintconst(<span class="keyword">int64</span>(i))), lookup(f)), val)</span><br><span class="line">            r = typecheck(r, ctxStmt)</span><br><span class="line">            init = <span class="built_in">append</span>(init, r)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setField(<span class="string">"kind"</span>, nodintconst(kind))</span><br><span class="line">        <span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">            c = convnop(c, types.Types[TUNSAFEPTR])</span><br><span class="line">            setField(<span class="string">"c"</span>, c)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            elem = convnop(elem, types.Types[TUNSAFEPTR])</span><br><span class="line">            setField(<span class="string">"elem"</span>, elem)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(mdempsky): There should be a cleaner way to</span></span><br><span class="line">        <span class="comment">// handle this.</span></span><br><span class="line">        <span class="keyword">if</span> instrumenting &#123;</span><br><span class="line">            r = mkcall(<span class="string">"selectsetpc"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, bytePtrToIndex(selv, <span class="keyword">int64</span>(i)))</span><br><span class="line">            init = <span class="built_in">append</span>(init, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// run the select</span></span><br><span class="line">    lineno = sellineno</span><br><span class="line">    chosen := temp(types.Types[TINT])</span><br><span class="line">    recvOK := temp(types.Types[TBOOL])</span><br><span class="line">    r = nod(OAS2, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">    r.List.Set2(chosen, recvOK)</span><br><span class="line">    fn := syslook(<span class="string">"selectgo"</span>)</span><br><span class="line">    r.Rlist.Set1(mkcall1(fn, fn.Type.Results(), <span class="literal">nil</span>, bytePtrToIndex(selv, <span class="number">0</span>), bytePtrToIndex(order, <span class="number">0</span>), nodintconst(<span class="keyword">int64</span>(n))))</span><br><span class="line">    r = typecheck(r, ctxStmt)</span><br><span class="line">    init = <span class="built_in">append</span>(init, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// selv and order are no longer alive after selectgo.</span></span><br><span class="line">    init = <span class="built_in">append</span>(init, nod(OVARKILL, selv, <span class="literal">nil</span>))</span><br><span class="line">    init = <span class="built_in">append</span>(init, nod(OVARKILL, order, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch cases</span></span><br><span class="line">    <span class="keyword">for</span> i, cas := <span class="keyword">range</span> cases.Slice() &#123;</span><br><span class="line">        setlineno(cas)</span><br><span class="line"></span><br><span class="line">        cond := nod(OEQ, chosen, nodintconst(<span class="keyword">int64</span>(i)))</span><br><span class="line">        cond = typecheck(cond, ctxExpr)</span><br><span class="line">        cond = defaultlit(cond, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        r = nod(OIF, cond, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n := cas.Left; n != <span class="literal">nil</span> &amp;&amp; n.Op == OSELRECV2 &#123;</span><br><span class="line">            x := nod(OAS, n.List.First(), recvOK)</span><br><span class="line">            x = typecheck(x, ctxStmt)</span><br><span class="line">            r.Nbody.Append(x)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.Nbody.AppendNodes(&amp;cas.Nbody)</span><br><span class="line">        r.Nbody.Append(nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">        init = <span class="built_in">append</span>(init, r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> init</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对<code>select</code>不同<code>case</code>的情况编译的方式不用:</p>
<h4 id="没有case"><a href="#没有case" class="headerlink" title="没有case"></a>没有<code>case</code></h4><p>看一下相关代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接调用<code>block</code><br>由于没又对应的<code>chan</code>处理，所以当前<code>goroutine</code>进入休眠状态，无法被唤醒</p>
<h4 id="只有1个case"><a href="#只有1个case" class="headerlink" title="只有1个case"></a>只有<strong>1</strong>个<code>case</code></h4><p>对应源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">    cas := cases.First()</span><br><span class="line">    setlineno(cas)</span><br><span class="line">    l := cas.Ninit.Slice()</span><br><span class="line">    <span class="keyword">if</span> cas.Left != <span class="literal">nil</span> &#123; <span class="comment">// not default:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ok already</span></span><br><span class="line">        <span class="keyword">case</span> OSEND:</span><br><span class="line">            ch = n.Left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> OSELRECV, OSELRECV2:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if ch == nil &#123; block() &#125;; n;</span></span><br><span class="line">        a := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        a.Left = nod(OEQ, ch, nodnil())</span><br><span class="line">        <span class="keyword">var</span> ln Nodes</span><br><span class="line">        ln.Set(l)</span><br><span class="line">        a.Nbody.Set1(mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, &amp;ln))</span><br><span class="line">        l = ln.Slice()</span><br><span class="line">        a = typecheck(a, ctxStmt)</span><br><span class="line">        l = <span class="built_in">append</span>(l, a, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">append</span>(l, cas.Nbody.Slice()...) <span class="comment">// 指的是下面的具体case处理内容</span></span><br><span class="line">    l = <span class="built_in">append</span>(l, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实也分为两种方式，</p>
<h5 id="一种是这个case是default"><a href="#一种是这个case是default" class="headerlink" title="一种是这个case是default"></a>一种是这个<code>case</code>是<code>default</code></h5><p>直接把 <code>case</code> 对应的 <code>body</code> 放入 <code>AST</code> 中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转换为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"default"</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="另一种是这个case不是default"><a href="#另一种是这个case不是default" class="headerlink" title="另一种是这个case不是default:"></a>另一种是这个<code>case</code>不是<code>default</code>:</h5><p>转换一下 <code>case</code> 表达式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok &lt;-ch:</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转换为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<h4 id="有2个case-其中一个是default"><a href="#有2个case-其中一个是default" class="headerlink" title="有2个case, 其中一个是default"></a>有<strong>2</strong>个<code>case</code>, 其中一个是<code>default</code></h4><p>对于有两个, 但是其中一个为<code>default</code>的，具体处理代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optimization: two-case select but one is default: single non-blocking op.</span></span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">2</span> &amp;&amp; (cases.First().Left == <span class="literal">nil</span> || cases.Second().Left == <span class="literal">nil</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> cas *Node</span><br><span class="line">       <span class="keyword">var</span> dflt *Node</span><br><span class="line">       <span class="keyword">if</span> cases.First().Left == <span class="literal">nil</span> &#123;</span><br><span class="line">           cas = cases.Second()</span><br><span class="line">           dflt = cases.First()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dflt = cases.Second()</span><br><span class="line">           cas = cases.First()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       n := cas.Left</span><br><span class="line">       setlineno(n)</span><br><span class="line">       r := nod(OIF, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">       r.Ninit.Set(cas.Ninit.Slice())</span><br><span class="line">       <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           Fatalf(<span class="string">"select %v"</span>, n.Op)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> OSEND:</span><br><span class="line">           <span class="comment">// if selectnbsend(c, v) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">           ch := n.Left</span><br><span class="line">           r.Left = mkcall1(chanfn(<span class="string">"selectnbsend"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, ch, n.Right)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> OSELRECV:</span><br><span class="line">           <span class="comment">// if selectnbrecv(&amp;v, c) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">           ...</span><br><span class="line">           r.Left = mkcall1(chanfn(<span class="string">"selectnbrecv"</span>, <span class="number">2</span>, ch.Type), types.Types[TBOOL], &amp;r.Ninit, elem, ch)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> OSELRECV2:</span><br><span class="line">           <span class="comment">// if selectnbrecv2(&amp;v, &amp;received, c) &#123; body &#125; else &#123; default body &#125;</span></span><br><span class="line">           ...</span><br><span class="line">           r.Rlist.Set(<span class="built_in">append</span>(dflt.Ninit.Slice(), dflt.Nbody.Slice()...))</span><br><span class="line">           <span class="keyword">return</span> []*Node&#123;r, nod(OBREAK, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到真对每个<code>case</code>的具体操作可以转为不同的形式，具体的可以参考针对每个 <code>case</code> 所调用的函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  select &#123;</span></span><br><span class="line"><span class="comment">//  case c &lt;- v:</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  &#125; else &#123;</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  select &#123;</span></span><br><span class="line"><span class="comment">//  case v = &lt;-c:</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  if selectnbrecv(&amp;v, c) &#123;</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  &#125; else &#123;</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  select &#123;</span></span><br><span class="line"><span class="comment">//  case v, ok = &lt;-c:</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  if c != nil &amp;&amp; selectnbrecv2(&amp;v, &amp;ok, c) &#123;</span></span><br><span class="line"><span class="comment">//      ... foo</span></span><br><span class="line"><span class="comment">//  &#125; else &#123;</span></span><br><span class="line"><span class="comment">//      ... bar</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv2</span><span class="params">(elem unsafe.Pointer, received *<span class="keyword">bool</span>, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// TODO(khr): just return 2 values from this function, now that it is in Go.</span></span><br><span class="line">    selected, *received = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2个以上case-或两个case并且没有default"><a href="#2个以上case-或两个case并且没有default" class="headerlink" title="2个以上case, 或两个case并且没有default"></a><strong>2</strong>个以上<code>case</code>, 或两个<code>case</code>并且没有<code>default</code></h4><p>对于这种情况，主要是调用了 <code>selectgo</code>来处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn := syslook(<span class="string">"selectgo"</span>)</span><br><span class="line">r.Rlist.Set1(mkcall1(fn, fn.Type.Results(), <span class="literal">nil</span>, bytePtrToIndex(selv, <span class="number">0</span>), bytePtrToIndex(order, <span class="number">0</span>), nodintconst(<span class="keyword">int64</span>(n))))</span><br></pre></td></tr></table></figure></p>
<p>用图形来表示这时的<code>select</code>结构如下:<br><img src="/assets/img/go/select/2more_case.png" alt><br>详细内容参考下面的 <code>selectgo</code>的分析</p>
<h2 id="select-源码分析"><a href="#select-源码分析" class="headerlink" title="select 源码分析"></a>select 源码分析</h2><p>前面主要是介绍<code>select</code>的基本语法和词法分析过程，下面针对<code>select</code>的运行时代码进行分析</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>在分析源码之前，先写一个<code>demo</code>, 然后通过编译成汇编，看看内部是如何调用的, 还是使用官方给出的<code>demo</code>, 对其进行编译:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S select.go</span><br></pre></td></tr></table></figure></p>
<p>输出汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.fibonacci STEXT size=<span class="number">354</span> args=<span class="number">0x10</span> locals=<span class="number">0xc8</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (select2.go:<span class="number">5</span>) TEXT    <span class="string">""</span>.fibonacci(SB), ABIInternal, <span class="number">$200</span>-<span class="number">16</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00d4</span> <span class="number">00212</span> (select2.go:<span class="number">8</span>) <span class="keyword">CALL</span>    runtime.selectgo(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x00d4</span> <span class="number">00212</span> (select2.go:<span class="number">8</span>) <span class="keyword">CALL</span>    runtime.selectgo(SB)</span><br></pre></td></tr></table></figure></p>
<p>可以看出调用了<code>runtime.selectgo</code>函数，这个函数的实现在<code>runtime/select.go:155</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectgo implements the select statement.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// cas0 points to an array of type [ncases]scase, and order0 points to</span></span><br><span class="line"><span class="comment">// an array of type [2*ncases]uint16. Both reside on the goroutine's</span></span><br><span class="line"><span class="comment">// stack (regardless of any escaping in selectgo).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// selectgo returns the index of the chosen scase, which matches the</span></span><br><span class="line"><span class="comment">// ordinal position of its respective select&#123;recv,send,default&#125; call.</span></span><br><span class="line"><span class="comment">// Also, if the chosen scase was a receive operation, it reports whether</span></span><br><span class="line"><span class="comment">// a value was received.</span></span><br><span class="line"><span class="comment">// cas0 是指向类型为 [ncases]scase 的数组, 其实就是我们 select 写的 case 组成的数组</span></span><br><span class="line"><span class="comment">// order0 指向的是一个类型为 [2*ncases]uint16 的数组</span></span><br><span class="line"><span class="comment">// cas0 和 order0 都存在于 goroutine 的栈中(不考虑逃逸分析)</span></span><br><span class="line"><span class="comment">// selectgo 返回的是要执行的 case 的索引(index)</span></span><br><span class="line"><span class="comment">// 如果 case 是 recv 操作, 还没返回是否接收到了数据(第二个 bool 参数)</span></span><br><span class="line"><span class="comment">// ncases 表示的是 case 的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0)) <span class="comment">// 创建一个长度为[1&lt;&lt;16]的数组，并把cas0的地址赋值给cas1, 现在cas1表示了所有的case</span></span><br><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0)) <span class="comment">// 创建一个长度为[1&lt;&lt;17]的数组，指向order0</span></span><br><span class="line"></span><br><span class="line">	scases := cas1[:ncases:ncases] <span class="comment">// scases 包含了所有的case, 并且cap为case的个数</span></span><br><span class="line">	pollorder := order1[:ncases:ncases] <span class="comment">// 长度为case个数的数组，其实里面的内容是要放case的执行顺序</span></span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases] <span class="comment">// 指向order1的后面的存储空间, 内容是要存放根据chan的地址顺序排序的所有chan</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line">	<span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line">    <span class="comment">// 先对所有case进行处理，忽略case.c = nil, 也就是对应的chan已经被关闭或者其他情况导致的nil</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">		<span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">			*cas = scase&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line">	<span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line">	<span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line">	<span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line">	<span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line">	<span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line">	<span class="comment">// optimizing (and needing to test).</span></span><br><span class="line">    <span class="comment">// 编译器已经把对于只有0或者1个case+default的形式给优化成了简单的结构</span></span><br><span class="line">    <span class="comment">// 这个我们处理的是更多的select case的情况</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate permuted order</span></span><br><span class="line">    <span class="comment">// 对 case 进行随机排序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>)) <span class="comment">// 快速求随机数, 范围: [0, i]</span></span><br><span class="line">		pollorder[i] = pollorder[j] <span class="comment">// 第 i 个数据的值 = 第 j 个数据的值</span></span><br><span class="line">		pollorder[j] = <span class="keyword">uint16</span>(i) <span class="comment">// 第 j 个数的值赋值为 i</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line">	<span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line">    <span class="comment">// 对所有case 中的 hchan 按照地址进行堆排序</span></span><br><span class="line">    <span class="comment">// 排完序后是为了对齐进行加锁，防止重复加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hchan 地址构建大顶堆</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := i</span><br><span class="line">		<span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">		c := scases[pollorder[i]].c</span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">			k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">			lockorder[j] = lockorder[k]</span><br><span class="line">			j = k</span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = pollorder[i]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 进行堆排序</span></span><br><span class="line">	<span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		o := lockorder[i]</span><br><span class="line">		c := scases[o].c</span><br><span class="line">		lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">		j := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				k++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">				lockorder[j] = lockorder[k]</span><br><span class="line">				j = k</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = o</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">    <span class="comment">// 根据lockorder对scases的chan上锁，具体实现参考下面对sellock函数的介绍</span></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		gp     *g</span><br><span class="line">		sg     *sudog</span><br><span class="line">		c      *hchan</span><br><span class="line">		k      *scase</span><br><span class="line">		sglist *sudog</span><br><span class="line">		sgnext *sudog</span><br><span class="line">		qp     unsafe.Pointer</span><br><span class="line">		nextp  **sudog</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line">    <span class="comment">// 第一种情况，已经有满足的 case 条件</span></span><br><span class="line">	<span class="keyword">var</span> dfli <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> dfl *scase</span><br><span class="line">	<span class="keyword">var</span> casi <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> cas *scase</span><br><span class="line">	<span class="keyword">var</span> recvOK <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123; <span class="comment">// 根据之前的随机顺序访问</span></span><br><span class="line">		casi = <span class="keyword">int</span>(pollorder[i])</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseNil: <span class="comment">// 如果当前 case 是一个 nil 的 chan, 则不处理，继续寻找其他的 case</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseRecv: <span class="comment">// 如果是接收数据的 case</span></span><br><span class="line">			sg = c.sendq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123; <span class="comment">// sg != nil 这证明 buf已经满了，或者是一个不带buf的chan, 然后执行 recv函数，recv的过程可以参考 go channel 原理的介绍</span></span><br><span class="line">				<span class="keyword">goto</span> recv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123; <span class="comment">// 如果 qcount &gt; 0 这证明 buf 里是有数据的，所有从 buf 里取数据</span></span><br><span class="line">				<span class="keyword">goto</span> bufrecv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123; <span class="comment">// 对应的chan已经被关闭了</span></span><br><span class="line">				<span class="keyword">goto</span> rclose</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend: <span class="comment">// 如果是发送数据</span></span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123; <span class="comment">// 如果被关闭了，进入sclose， 最终会 panic</span></span><br><span class="line">				<span class="keyword">goto</span> sclose</span><br><span class="line">			&#125;</span><br><span class="line">			sg = c.recvq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123; <span class="comment">// recv队列不为空，则执行 send 函数, 参考 go channel 中 send 的处理</span></span><br><span class="line">				<span class="keyword">goto</span> send</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123; <span class="comment">// 证明 buf 还没满，直接发送到 buf 中</span></span><br><span class="line">				<span class="keyword">goto</span> bufsend</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseDefault: <span class="comment">// case 是 default case，这里其实时延迟赋值，如果运行了其他case, 就没必要赋值了</span></span><br><span class="line">			dfli = casi <span class="comment">// default 的下标</span></span><br><span class="line">			dfl = cas  <span class="comment">// 给 default 赋值</span></span><br><span class="line">            <span class="comment">// 继续寻找其他case</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走到这里证明没有准备好的chan case能够执行，下面会优先执行 default</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123; <span class="comment">// default 不为空</span></span><br><span class="line">		selunlock(scases, lockorder) <span class="comment">// 对已经上锁的进行解锁</span></span><br><span class="line">		casi = dfli</span><br><span class="line">		cas = dfl</span><br><span class="line">		<span class="keyword">goto</span> retc  <span class="comment">// 直接返回 default 的 index </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">    <span class="comment">// 走到这里所有的case都无法运行</span></span><br><span class="line">    <span class="comment">// 把所有的chan都进入阻塞状态</span></span><br><span class="line">    <span class="comment">// 具体细节可以参考 go  channel 的操作</span></span><br><span class="line">	gp = getg()</span><br><span class="line">	<span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		casi = <span class="keyword">int</span>(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.isSelect = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">		<span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">		sg.elem = cas.elem</span><br><span class="line">		sg.releasetime = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.c = c</span><br><span class="line">		<span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">		*nextp = sg</span><br><span class="line">		nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for someone to wake us up</span></span><br><span class="line">    <span class="comment">// 这里当前goroutine会进入阻塞，让出CPU, 等待chan可以发送或者接收数据时就被唤醒，这个可以参考chan的实现:</span></span><br><span class="line">    <span class="comment">// 当前goroutine进入recvq或sendq， 当任何一个chan被其他goroutine操作时，就会把当前goroutine唤醒</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>) <span class="comment">//阻塞，直到被唤醒</span></span><br><span class="line"></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	gp.selectDone = <span class="number">0</span></span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line">	<span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line">	<span class="comment">// record the successful case, if any.</span></span><br><span class="line">	<span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">	casi = <span class="number">-1</span></span><br><span class="line">	cas = <span class="literal">nil</span></span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	<span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line">	<span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">		sg1.isSelect = <span class="literal">false</span></span><br><span class="line">		sg1.elem = <span class="literal">nil</span></span><br><span class="line">		sg1.c = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		<span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			k.releasetime = sglist.releasetime</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">			<span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line">			casi = <span class="keyword">int</span>(casei)</span><br><span class="line">			cas = k <span class="comment">// 寻找当前被唤醒的case</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = k.c</span><br><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist) <span class="comment">// 出队, 但是不处理对应的 chan 值</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist) <span class="comment">// 出队, 但是不处理对应的 chan 值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">		releaseSudog(sglist) <span class="comment">// 释放当前 sglist</span></span><br><span class="line">		sglist = sgnext <span class="comment">// 继续处理下一个 sglist</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果没有被唤醒的case(在一些情况下, 如: close chan等)</span></span><br><span class="line">	<span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class="line">		<span class="comment">// when a channel involved in the select has been closed.</span></span><br><span class="line">		<span class="comment">// It is easiest to loop and re-run the operation;</span></span><br><span class="line">		<span class="comment">// we'll see that it's now closed.</span></span><br><span class="line">		<span class="comment">// Maybe some day we can signal the close explicitly,</span></span><br><span class="line">		<span class="comment">// but we'd have to distinguish close-on-reader from close-on-writer.</span></span><br><span class="line">		<span class="comment">// It's easiest not to duplicate the code and just recheck above.</span></span><br><span class="line">		<span class="comment">// We know that something closed, and things never un-close,</span></span><br><span class="line">		<span class="comment">// so we won't block again.</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">		recvOK = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line">	<span class="comment">// can receive from buffer</span></span><br><span class="line">    <span class="comment">// 处理从 buf recv 的情况</span></span><br><span class="line">    ...</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	<span class="comment">// can send to buffer</span></span><br><span class="line">    <span class="comment">// 处理从 buf send 的情况</span></span><br><span class="line">    ...</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">    <span class="comment">// 直接从 goroutine 中 recv</span></span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncrecv: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line">	<span class="comment">// read at end of closed channel</span></span><br><span class="line">    <span class="comment">// recv close chan 的情况</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line">    <span class="comment">// 直接从 goroutine 中 send</span></span><br><span class="line">    ...</span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncsend: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line">    <span class="comment">// 返回 index 和 recv 状态</span></span><br><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	<span class="comment">// send on closed channel</span></span><br><span class="line">    <span class="comment">// send close chan 的情况</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是整个<code>select</code>的选择过程。<br>其中 每个case <code>scase</code> 的数据结构如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select case descriptor.</span></span><br><span class="line"><span class="comment">// Known to compiler.</span></span><br><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's scasetype.</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">    c           *hchan         <span class="comment">// case 语句中使用到的 chan</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">    kind        <span class="keyword">uint16</span> <span class="comment">// case的类型，包括send, recv, default等</span></span><br><span class="line">    pc          <span class="keyword">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对每个<code>case</code>的<code>chan</code>上锁的过程如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 select 的 case.c 上锁，根据 lockorder 的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sellock</span><span class="params">(scases []scase, lockorder []<span class="keyword">uint16</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">        c0 := scases[o].c</span><br><span class="line">        <span class="keyword">if</span> c0 != <span class="literal">nil</span> &amp;&amp; c0 != c &#123; <span class="comment">// 这个判断如果不满足证明当前chan和前一个chan地址是一样的，只上一次锁就行了</span></span><br><span class="line">            c = c0</span><br><span class="line">            lock(&amp;c.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的过程也可以用一个流程图来表示:<br><img src="/assets/img/go/select/select_process.svg" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.gopl.io/" target="_blank" rel="noopener">The Go Programming Language</a><br><a href="https://draveness.me/golang/keyword/golang-select.html" target="_blank" rel="noopener">select 源码分析</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/27/go-channel/"><span>go channel 原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/27/go-channel/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-27T09:27:24.000Z">
          2019-06-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本篇主要介绍<code>chan</code>的内部实现原理(基于go1.12), 通过源码和图形的方式展示<code>chan</code>的内部结构及对<code>chan</code>进行操作的过程。</p>
</blockquote>
<h2 id="make-chan"><a href="#make-chan" class="headerlink" title="make chan"></a>make chan</h2><p>在进入源码分析之前，我们假设自己并不知道去哪里看其源码，我们先简单的创建一个<code>chan</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了分析其内部实现，我们可以通过<code>compile</code>工具对其编译生成伪汇编代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S chan.go</span><br></pre></td></tr></table></figure></p>
<p>生成的汇编代码重点的内容入下:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">71</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (chan1.go:<span class="number">3</span>)   TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$32</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0031</span> <span class="number">00049</span> (chan1.go:<span class="number">4</span>)   <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0045</span> <span class="number">00069</span> (chan1.go:<span class="number">3</span>)   <span class="keyword">JMP</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到执行<code>make</code>其实最终执行的是<code>runtime.makechan</code>这个函数，这个函数的实现在<code>runtime/chan.go</code>文件中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line">    ...</span><br><span class="line">    mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Queue or element size is zero.</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">        <span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Elements contain pointers.</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></p>
<p>可以看到最终会返回一个<code>*hchan</code>类型，这个就是<code>chan</code>的结构体:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 队列中有数据的个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 循环队列的大小z</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向循环队列的地址</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         </span><br><span class="line">    closed   <span class="keyword">uint32</span> <span class="comment">// chan的关闭状态</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// 队列中下一个要发送的数据的下标</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// 队列中下一个要接收的数据的下标</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 等待接受的G队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 等待发送的G队列</span></span><br><span class="line">    lock     mutex  <span class="comment">// 操作chan是需要加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完上面的<code>make</code>后，生成的<code>chan</code>如下:<br><img src="/assets/img/go/channel/makechan.png" alt></p>
<h2 id="send-chan"><a href="#send-chan" class="headerlink" title="send chan"></a>send chan</h2><p>为了了解我们往<code>chan</code>发送的时候都做了什么我可能先写一个demo:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看其汇编代码:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">97</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">    <span class="number">0x0000</span> <span class="number">00000</span> (chan2.go:<span class="number">3</span>)   TEXT    <span class="string">""</span>.main(SB), ABIInternal, <span class="number">$32</span>-<span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x0031</span> <span class="number">00049</span> (chan2.go:<span class="number">4</span>)   <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x004b</span> <span class="number">00075</span> (chan2.go:<span class="number">5</span>)   <span class="keyword">CALL</span>    runtime.chansend1(SB)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">0x005f</span> <span class="number">00095</span> (chan2.go:<span class="number">3</span>)   <span class="keyword">JMP</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出我们往<code>chan</code>发送数据其实执行的是<code>runtime.chansend1</code>函数，这个函数很简简单，只是调用了<code>runtime.chansend</code>函数,我们主要看一下<code>runtime.chansend</code>函数的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 往已经 closed 的 chan 发送数据会直接 panic</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果有接收队列，则进入send函数</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 没有接收队列，buf还没有满，则直接往里放数据</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123; <span class="comment">//如果sendx == dataqsize, 证明buf满了，</span></span><br><span class="line">            c.sendx = <span class="number">0</span> <span class="comment">// c.sendx=0保证了又从头开始，形成了一个循环队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个sudog结构, 把当前发送数据所在的g和要发送的数据都放到这里</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.sendq.enqueue(mysg) <span class="comment">// 把这个sudog结构体放到发送对队列中</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>) <span class="comment">//阻塞当前g,直到由于可以发送数据而被唤醒</span></span><br><span class="line">    <span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">    <span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">    <span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">    <span class="comment">// stack tracer.</span></span><br><span class="line">    KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们有一个图来表示其过程，图中主要分为下面几个步骤:</p>
<ol>
<li>往上面初始化好的<code>hchan</code>结构体发送第 1 个数据: 数据放到<code>buf[0]</code>的位置</li>
<li>往<code>hchan</code>结构体发送第 2 个数据: 数据放到<code>buf[1]</code>的位置</li>
<li>往<code>hchan</code>结构体发送第 3 个数据: 数据放到<code>buf[2]</code>的位置, 这时<code>buf</code><strong>满了</strong></li>
<li>往<code>buf</code>满了的<code>hchan</code>结构体发送第 4 个数据: <code>g1</code>会放到<code>sudog</code>结构体中，并放到<code>sendq</code>队列中，等待被唤醒</li>
<li>往<code>buf</code>满了的<code>hchan</code>结构体发送第 5 个数据: <code>g2</code>会放到<code>sudog</code>结构体中，并放到<code>sendq</code>队列中，等待被唤醒</li>
</ol>
<p><img src="/assets/img/go/channel/send.gif" alt></p>
<h2 id="recv-chan"><a href="#recv-chan" class="headerlink" title="recv chan"></a>recv chan</h2><p>同上面一样，我们先写一个<code>demo</code>看看<code>recv</code>调用的是哪个函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">94</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0031</span> <span class="number">00049</span> (chan3.go:<span class="number">4</span>)       <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0048</span> <span class="number">00072</span> (chan3.go:<span class="number">5</span>)       <span class="keyword">CALL</span>    runtime.chanrecv1(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x005c</span> <span class="number">00092</span> (chan3.go:<span class="number">3</span>)       <span class="keyword">JMP</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>同样<code>runtime.chanrecv1</code>也是简单调用了<code>runtime.chanrecv</code>函数，具体代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">        c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 如果chan已经被关闭，并且qcount==0, 则返回默认零值+false(如x, ok := &lt;- c, x是零值，ok=false)</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在接收的时候有发送队列存在，则执行recv函数</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">        <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">        <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">        <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在buf, 存在数据</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Receive directly from queue</span></span><br><span class="line">        qp := chanbuf(c, c.recvx) <span class="comment">//获取recvx位置的地址</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp) <span class="comment">// 把recvx位置的数据copy到接收的变量中</span></span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp) <span class="comment">// 清空原来recvx位置的数据</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123; <span class="comment">// 如果recvx == dataqsiz 证明已经到达最后一个，需要从头开始</span></span><br><span class="line">            c.recvx = <span class="number">0</span> <span class="comment">//从头开始，形成一个循环队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog() <span class="comment">// 获取一个sudog结构，把对应的g和接收数据的变量地址放到sudog中</span></span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.recvq.enqueue(mysg) <span class="comment">// 把sudog放入接收队列中</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>) <span class="comment">//阻塞当前g，直到被唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// someone woke us up</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closed := gp.param == <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面说到如果存在发送队列就会执行<code>recv</code>函数，下面看一下这个函数的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//对于nobuf的chan, 直接copy数据</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racesync(c, sg)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// copy data from sender</span></span><br><span class="line">            recvDirect(c.elemtype, sg, ep)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">        <span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">        <span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">        <span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">        qp := chanbuf(c, c.recvx) <span class="comment">// 获取接收数据的位置</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy data from queue to receiver</span></span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp) <span class="comment">//把recvx位置的数据copy到接收的变量中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy data from sender to queue</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, sg.elem) <span class="comment">// 把发送队列的数据copy到当前recvx的位置</span></span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为上面把发送队列的数据copy到了recvx, 为了保证下一个位置属按照顺序的，需要sendx = recvx</span></span><br><span class="line">        <span class="comment">// 这几步保证了chan是一个FIFO的过程</span></span><br><span class="line">        c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz </span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 把出队的g放到ready中，下次调度就可以运行了，不再阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们有一个图来表示接收数据的过程，图中主要分为下面几个步骤:</p>
<ol>
<li>初始的<code>hchan</code>是上面<code>send</code>之后的结构</li>
<li><code>g3</code>执行接收操作，首先会把发送队列中的第 1 个<code>g1</code>出队，然后把<code>buf[0]</code>的数据赋值到<code>g3</code>中，再把<code>g1</code>的数据赋值到<code>buf[0]</code>中</li>
<li><code>g3</code>执行接收操作，首先会把发送队列中的第 2 个<code>g2</code>出队，然后把<code>buf[1]</code>的数据赋值到<code>g3</code>中，再把<code>g2</code>的数据赋值到<code>buf[1]</code>中</li>
<li>这个时候没有发送队列了，所以可以直接把<code>buf[2]</code>中的书赋值到<code>g3</code>中</li>
<li>把下一个数据<code>buf[0]</code>中的书赋值到<code>g3</code>中</li>
<li>把最后一个数据<code>buf[1]</code>中的书赋值到<code>g3</code>中</li>
<li>已经没有数据可以赋值给<code>g3</code>了，所以<code>g3</code>被放入<code>sudog</code>结构体中，入队到了接收队列, 进入阻塞状态</li>
</ol>
<p><img src="/assets/img/go/channel/recv.gif" alt></p>
<h2 id="send-chan-again"><a href="#send-chan-again" class="headerlink" title="send chan again"></a>send chan again</h2><p>上面介绍<code>send</code>说到如果发送数据的时候有<code>recvq</code>队列就会调用<code>send</code>函数，这个函数的具体实现如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">            racesync(c, sg) <span class="comment">// no buf 直接同步</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Pretend we go through the buffer, even though</span></span><br><span class="line">            <span class="comment">// we copy directly. Note that we need to increment</span></span><br><span class="line">            <span class="comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">            qp := chanbuf(c, c.recvx) <span class="comment">// 获取recvx位置</span></span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">            c.recvx++</span><br><span class="line">            <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">                c.recvx = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep) <span class="comment">//直接把要发送的数据 copy 到 recvq 队列出队的 g 中</span></span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 把g放到ready队列中，下次有机会被调度，不再阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/go/channel/send-recv.gif" alt></p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>当我们<code>close</code>掉一个<code>chan</code>都发生了什么呢? 下面写一个<code>close</code>的<code>demo</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">85</span> args=<span class="number">0x0</span> locals=<span class="number">0x20</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x0031</span> <span class="number">00049</span> (chan4.go:<span class="number">4</span>)       <span class="keyword">CALL</span>    runtime.makechan(SB)</span><br><span class="line">        ...</span><br><span class="line">        <span class="number">0x003f</span> <span class="number">00063</span> (chan4.go:<span class="number">5</span>)       <span class="keyword">CALL</span>    runtime.closechan(SB)</span><br><span class="line">        <span class="number">0x0053</span> <span class="number">00083</span> (chan4.go:<span class="number">3</span>)       <span class="keyword">JMP</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以调用了<code>runtime.closechan</code>函数，对应的代码为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>)) <span class="comment">// 已经关闭的 chan 不能再关闭</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">        racerelease(c.raceaddr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.closed = <span class="number">1</span> <span class="comment">// 关闭状态设置为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line">    <span class="comment">// release all readers</span></span><br><span class="line">    <span class="comment">// 遍历所有recvq 队列, 从队列中去掉，并清空其内容，把所有g都放到glist结构中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">            sg.elem = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有 sendq 队列, 从队列中去掉，把所有g都放到glist结构中</span></span><br><span class="line">    <span class="comment">// release all writers (they will panic)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">            sg.releasetime = cputicks()</span><br><span class="line">        &#125;</span><br><span class="line">        gp := sg.g</span><br><span class="line">        gp.param = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquireg(gp, c.raceaddr())</span><br><span class="line">        &#125;</span><br><span class="line">        glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">    <span class="comment">// 把刚才所有放到 glist 中的 g 都改为ready 状态，使其不再阻塞</span></span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        gp.schedlink = <span class="number">0</span></span><br><span class="line">        goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们分别看一下:</p>
<ol>
<li><p>当存在<code>recvq</code>队列时:<br><img src="/assets/img/go/channel/close-recv.gif" alt></p>
</li>
<li><p>当存在<code>sendq</code>队列时:</p>
</li>
</ol>
<p><img src="/assets/img/go/channel/close-send.gif" alt></p>
<h2 id="no-buffer-chan"><a href="#no-buffer-chan" class="headerlink" title="no buffer chan"></a>no buffer chan</h2><p>前面讲的都是带<code>buffer</code>的<code>chan</code>, 还有一种是经常使用的不带<code>buffer</code>的<code>chan</code>，其实处理起来更简单，前面源码部分已经有涉及了，下面看一下操作过程:</p>
<ol>
<li><code>make</code>一个不带<code>buffer</code>的<code>chan</code></li>
<li><code>g1</code>向这个<code>chan</code>发送数据, 由于没有接收者而被阻塞，放到<code>sendq</code>中</li>
<li><code>g2</code>继续想这个<code>chan</code>发送数据，继续放到<code>sendq</code>中</li>
<li>来一个接收者<code>g3</code>, 这时把<code>g1</code>从<code>sendq</code>中出队，并把<code>elem</code>的值赋值给<code>g3</code>的<code>x</code></li>
<li><code>g3</code>继续接收,把<code>g2</code>从<code>sendq</code>中出队，并把<code>elem</code>的值赋值给<code>g3</code>的<code>x</code></li>
<li>没有发送队列存在，<code>g3</code>也进入了阻塞状态，放到了<code>recvq</code>队列中</li>
</ol>
<p>下面是其图形化展示:<br><img src="/assets/img/go/channel/no-buf-chan.gif" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/w9_ycAYD6SRhaxy-4BnvwA" target="_blank" rel="noopener">图解Go的channel底层原理</a><br>Go 1.12 runtime/chan.go<br><a href="https://www.youtube.com/watch?v=KBZlN0izeiY" target="_blank" rel="noopener">GopherCon 2017: Kavya Joshi - Understanding Channels</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/06/10/unit-test-in-go/"><span>Go 单元测试</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/06/10/unit-test-in-go/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-10T02:11:19.000Z">
          2019-06-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Go单元测试"><a href="#Go单元测试" class="headerlink" title="Go单元测试"></a>Go单元测试</h1><p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。<br>我们为何要进行单元测试呢？其实如果你不添加单元测试的话，别人调用你提供的函数是，其实就是帮你做测试，但是这种测试我们越早做越能发现问题.</p>
<h3 id="单元测试的粒度"><a href="#单元测试的粒度" class="headerlink" title="单元测试的粒度"></a>单元测试的粒度</h3><p>程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。在 Go 中程序单元指的是<code>Package</code>中的方法。<br>那么我们对于 Go 中改对那些函数写单元测试呢？这里的答案是: 包中可导出的函数。 因为这些函数是对外可见的，这些是我们包的入口。那么对于不可导出的函数我们是否需要些单元测试呢？答案是不用。有些人可能会有一位，如果我们不对不可导出的函数写单元测试，那么如何保证单元测试的覆盖率呢？因为有些不可导出函数的覆盖率达不到要求。这里要说的是: 如果有些不可导出函数单元测试覆盖率达不到，有两点可能性:</p>
<ul>
<li>这些逻辑是不需要的，你可以直接去掉</li>
<li>你的测试用例不够，你需要增加可导出函数的测试用例</li>
</ul>
<h3 id="单测的三个原则"><a href="#单测的三个原则" class="headerlink" title="单测的三个原则"></a>单测的三个原则</h3><p>还有一个问题是: 我该先开发功能在写单元测试，还是先写单元测试再开发功能？<br>其实关于TDD有三个定律:</p>
<ol>
<li>You are not allowed to write any production code unless it is to make a failing unit test pass.</li>
<li>You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.</li>
<li>You are not allowed to write any more production code than is sufficient to pass the one failing unit test.</li>
</ol>
<p>关于这三条定律，我发现每个人翻译的都不一样，我觉得比较符合我的理解的翻译是:</p>
<ol>
<li>除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</li>
<li>在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</li>
<li>只允许编写刚好能够使一个失败的 unit test 通过的产品代码</li>
</ol>
<p>如果违反了会怎么样呢？<br>违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p>
<p>还是针对上面的问题: 先写单元测试还是先写功能？<br>我的答案是: <strong>单元测试-&gt; 功能开发 -&gt; 单元测试 -&gt; 功能开发…</strong><br>它们应该是交替进行的，既: 先写小范围的单元测试，然后针对这些测试进行开发功能，等所有测试通过后继续增加测试<code>case</code>, 然后针对新增的<code>case</code>继续编写功能，直到功能满足了需求为止。</p>
<h3 id="测试行为-而非实现"><a href="#测试行为-而非实现" class="headerlink" title="测试行为, 而非实现"></a>测试行为, 而非实现</h3><p>Avoid Testing Implementation Details, Test Behaviours<br>当我们测试行为时，我们的意思是 : “我不在乎你是如何得出答案的，只要确保在这种情况下答案是正确的”<br>当我们测试实现时，我们的意思是 : “我不在乎答案是什么，只要确保它是按照你规定的方式工作的。”</p>
<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="单元测试编写"><a href="#单元测试编写" class="headerlink" title="单元测试编写"></a>单元测试编写</h3><p>下面给出一个完整的<code>Go</code>的单元测试的例子:<br><code>split.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">    i := strings.Index(s, sep)</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">        s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">        i = strings.Index(s, sep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>split_test.go</code>文件:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        got := Split(<span class="string">"a/b/c"</span>, <span class="string">"/"</span>)</span><br><span class="line">        want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, want, got)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Go</code>官方网站有关于单元测试的<a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">写法介绍</a>, 以上面的代码为例:</p>
<ol>
<li><p>一般我们需要单元测试文件和要测试的包的文件需要在同一个目录下，并且以<code>_test.go</code>结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/split/</span><br><span class="line">├── split.go</span><br><span class="line">└── split_test.go</span><br></pre></td></tr></table></figure>
</li>
<li><p>单元测试的函数名为<code>Test</code> + 要测试的函数名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要测试的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">// 单元测试函数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TestSplit</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单元测试函数的参数是固定的 (<a href="https://golang.org/pkg/testing/#T" target="_blank" rel="noopener">*testing.T</a>):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p><code>Go</code>语言的工具链中提供了很强大的<a href="https://golang.org/cmd/go/#hdr-Test_packages" target="_blank" rel="noopener">单元测试工具</a>:<code>go test</code>, 如果想要运行刚才的单元测试，我们只需要在<code>split</code>文件夹下执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure></p>
<p>就可以得出测试结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">PASS</span><br><span class="line">ok      split   0.008s</span><br></pre></td></tr></table></figure></p>
<h3 id="运行多个单元测试"><a href="#运行多个单元测试" class="headerlink" title="运行多个单元测试"></a>运行多个单元测试</h3><p>有是有我们需要同时运行多个单元测试, 如果这些单元测试在同一个包下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/xml/</span><br><span class="line">├── atom_test.go</span><br><span class="line">├── example_marshaling_test.go</span><br><span class="line">├── example_test.go</span><br><span class="line">├── example_text_marshaling_test.go</span><br><span class="line">├── marshal.go</span><br><span class="line">├── marshal_test.go</span><br><span class="line">├── read.go</span><br><span class="line">├── read_test.go</span><br><span class="line">├── typeinfo.go</span><br><span class="line">├── xml.go</span><br><span class="line">└── xml_test.go</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接运行: <code>go test</code><br>如果这些单元测试文件不在同一个包下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$GOROOT/src/encoding/</span><br><span class="line">├── ascii85</span><br><span class="line">│   ├── ascii85.go</span><br><span class="line">│   └── ascii85_test.go</span><br><span class="line">├── asn1</span><br><span class="line">│   ├── asn1.go</span><br><span class="line">│   ├── asn1_test.go</span><br><span class="line">│   ├── common.go</span><br><span class="line">│   ├── marshal.go</span><br><span class="line">│   └── marshal_test.go</span><br><span class="line">├── base32</span><br><span class="line">│   ├── base32.go</span><br><span class="line">│   ├── base32_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">├── base64</span><br><span class="line">│   ├── base64.go</span><br><span class="line">│   ├── base64_test.go</span><br><span class="line">│   └── example_test.go</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们需要在这些包的外面运行: <code>go test ./...</code></p>
<h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>如果我们想要查看单元测试的覆盖率，<code>Go</code> 工具链也是支持的, 详情可以参考官方的Blog: <a href="https://blog.golang.org/cover" target="_blank" rel="noopener">The cover story</a><br>如果要查看单元测试覆盖率，我们可以运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      split   0.013s</span><br></pre></td></tr></table></figure></p>
<p>但是上面的测试只给出了覆盖率的值，并没有看到详细的信息，如果我们需要查看覆盖率的详细信息，可以把测试覆盖率的内容输出到文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go test -coverprofile=coverage.out</span><br></pre></td></tr></table></figure></p>
<p>这样，测试覆盖率的详细信息就输出到了文件<code>coverage.out</code>中。<br>如过要查看每个函数的测试覆盖率，可以利用刚才的<code>coverage.out</code>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -func=coverage.out</span><br><span class="line">split/split.go:7:       Split           100.0%</span><br><span class="line">total:                  (statements)    100.0%</span><br></pre></td></tr></table></figure></p>
<p>如果要想可视化测试覆盖率，还可以生成<code>html</code>格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$go tool cover -html=coverage.out</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到每行的覆盖情况:<br><img src="https://blog.golang.org/cover/set.png" alt="覆盖率"><br>其中红色代表没有覆盖到，绿色代表覆盖到，灰色代表不计入测试覆盖率的范围</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="多个case"><a href="#多个case" class="headerlink" title="多个case"></a>多个case</h3><p>前面我们讲了如何进行基本的单元测试，但是现实中往往我们需要对同一个函数进行多个<code>case</code>的测试，那么其实有两种写法:</p>
<h4 id="针对每个case写一个测试函数"><a href="#针对每个case写一个测试函数" class="headerlink" title="针对每个case写一个测试函数:"></a><strong>针对每个<code>case</code>写一个测试函数:</strong></h4><p>对于比较复杂的函数，其函数的表现可能会收到不同环境因素的影响，他们的单元测试写法差别也比较大，比如<code>beego</code>中 <a href="https://github.com/astaxie/beego/blob/develop/logs/file_test.go" target="_blank" rel="noopener">logs/file</a> 的单元测试, 同样是测试<code>FileDailyRotate</code>函数，<code>TestFileDailyRotate_01</code>测试的是创建文件, <code>TestFileDailyRotate_02</code>测试的是当创建的文件存在时，给文件加后缀。</p>
<h4 id="同一个测试函数里有多个case"><a href="#同一个测试函数里有多个case" class="headerlink" title="同一个测试函数里有多个case:"></a><strong>同一个测试函数里有多个<code>case</code>:</strong></h4><p>一般比较简单的单元测试，只是根据输入的不同而产生不同的输出，则可以使用这种方式。比如前面说的<code>split</code>函数的多个<code>case</code>测试, 我们把<code>split_test.go</code>改为下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep   <span class="keyword">string</span></span><br><span class="line">        want  []<span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tests := []test&#123;</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := Split(tc.input, tc.sep)</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">            t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边界条件测试"><a href="#边界条件测试" class="headerlink" title="边界条件测试"></a>边界条件测试</h3><p>由长期的测试工作经验得知，大量的错误是发生在输入或输出的边界上。因此针对各种边界情况设计测试用例，可以查出更多的错误。上面的<code>case</code>中我们并没有对边界条件进行测试，下面我们加上一个边界条件的测试<code>case</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们的单元测试有一个<code>case</code>没有通过，但是这里有一点疑问:<strong>哪个测试<code>case</code>没过?</strong></p>
<h3 id="定位测试case"><a href="#定位测试case" class="headerlink" title="定位测试case"></a>定位测试case</h3><h4 id="通过编号定位"><a href="#通过编号定位" class="headerlink" title="通过编号定位"></a>通过编号定位</h4><p>我们可以给每个case一个编号:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"test %d: expected: %v , got %v"</span>, i+<span class="number">1</span>, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:25: test 2: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.016s</span><br></pre></td></tr></table></figure>
<p>这里可以定位出 <code>test 2</code> 有问题的，但是编号的问题是 : </p>
<ul>
<li>每个人定义的开始下标可能不同: 有的人是从<code>0</code>开始，有的人从<code>1</code>开始，照成理解不一致</li>
<li>随着case的增多，同样不好定位具体的<code>case</code>: 如果你要从<code>50</code>个<code>case</code>中定位第<code>27</code>个<code>case</code>, 还是比较费时的。</li>
</ul>
<h4 id="通过名字定位"><a href="#通过名字定位" class="headerlink" title="通过名字定位"></a>通过名字定位</h4><p>还有一种方式: 我们给每个<code>case</code>一个名字:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">                name  <span class="keyword">string</span></span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tests := []test&#123;</span><br><span class="line">                &#123;name: <span class="string">"simple"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"trailing sep"</span>, input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"wrong sep"</span>, input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                &#123;name: <span class="string">"no sep"</span>, input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, tc.name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:26: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.015s</span><br></pre></td></tr></table></figure>
<p>现在我们可以看到我们可以很好的通过<code>trailing sep</code>快速定位到了具体的<code>case</code></p>
<h3 id="随机测试case"><a href="#随机测试case" class="headerlink" title="随机测试case"></a>随机测试case</h3><p>上面的测试方式看上去很完美了，可以如果我们实现的时候没有注意，<code>case</code>之间可能会相互影响, 比如一个<code>case</code>在函数内部修改了一个全局变量，下一个<code>case</code>的执行就会受到这种影响。为了避免由于测试顺序带来的问题，我们一般都会让每个<code>case</code>之间的顺序是随机的，而不是按照特定的顺序，而<code>slice</code>本身有顺序的，所以不满足我们的条件，这时我们可以使用<code>map</code>, 同时还可以把<code>name</code>放到<code>map</code>的<code>key</code>中，简化我们的写法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := Split(tc.input, tc.sep)</span><br><span class="line">                <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                        t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$go test</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:23: trailing sep: expected: [a b c] , got [a b c ]</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    split   0.014s</span><br></pre></td></tr></table></figure></p>
<h3 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h3><p>看上去前面的测试更加完美了， <strong>但是……</strong><br>我们的测试<code>case</code>出现错误的时候，我们会调用:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Fatalf(<span class="string">"%s: expected: %v , got %v"</span>, name, tc.want, got)</span><br></pre></td></tr></table></figure></p>
<p>打印我们的错误信息，但是这个错误信息打印后整个测试过程就结束了，如果我们有很多个<code>case</code>需要测试，而前面的<code>case</code>失败后就无法进行后面的测试了，这时候我们如果针对这个出错的<code>case</code>修改后，我们会发现其他的<code>case</code>有报错了，我们反复的修改，但是我们并不知道自己到底有多少个<code>case</code>是有问题的，我们无法一次性把问题修复好，照成我们工作量变大，并且效率变低，那么我们该如何改进这个情况呢?<br>我们知道问题出在<code>t.Fatalf</code>，那么我们可不可以即打印出错误信息又不让程序中断呢？答案是: 可以！ 我们使用<code>f.Errorf</code>替换<code>f.Fatalf</code><br><strong>可是…..</strong><br>如果某个<code>case</code>出现了<code>panic</code>同样会导致整个程序中断，所以这种方式治标不治本。那么我们该如何改进呢? Go 1.7 开始支持了 <a href="https://golang.org/doc/go1.7#testing" target="_blank" rel="noopener">sub test</a>。 下面我们就按照<code>Sub Test</code>的写法进行修改:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"reflect"</span></span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">string</span></span><br><span class="line">                sep   <span class="keyword">string</span></span><br><span class="line">                want  []<span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"simple"</span>:       &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"wrong sep"</span>:    &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">                <span class="string">"no sep"</span>:       &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        got := Split(tc.input, tc.sep)</span><br><span class="line">                        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %v , got %v"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>t.Run</code>的源码我们看到:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">go</span> tRunner(t, f)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实会诊对每个<code>case</code>启动一个<code>goroutine</code>， 所以其中一个出现了<code>panic</code>不会影响其他的<code>case</code>执行。</p>
<p>上面这种形态就是目前我们进行单元测试的<strong>最佳实践</strong>了。</p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><h4 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h4><p>外部依赖是指我们的函数需要调用其他的函数，外部依赖有可能涉及到一些数据依赖，网络依赖等。关于单元测试中如何解决外部依赖的问题, 常用的方法是: <strong>Test Double(测试替身)</strong>, 而它也分很多种:</p>
<ul>
<li><strong>Dummy</strong> objects are passed around but never actually used. Usually they are just used to fill parameter lists.</li>
<li><strong>Fake</strong> objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).</li>
<li><strong>Stubs</strong> provide canned answers to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test.</li>
<li><strong>Spies</strong> are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.</li>
<li><strong>Mocks</strong> are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.</li>
</ul>
<p>看上去有点儿头大，分这么多类型而且他们的接线感觉也比较模糊，为了便于理解我们不对这些概念做过多的解读，我们后面把所有我们的工作都看做是<code>Mock</code></p>
<h4 id="编写可测试代码"><a href="#编写可测试代码" class="headerlink" title="编写可测试代码"></a>编写可测试代码</h4><h5 id="函数要短小"><a href="#函数要短小" class="headerlink" title="函数要短小"></a>函数要短小</h5><p><em>函数的第一规则是要短小。第二条规则是还要短小</em> ———— 《代码整洁之道》<br>至于如何才算短小，一般建议是不超过100行，也就是显示器一屏所显示的行数。<br>函数越短小那么单元测试的编写就越简单。</p>
<h5 id="函数功能要单一"><a href="#函数功能要单一" class="headerlink" title="函数功能要单一"></a>函数功能要单一</h5><p><em>函数应该做一件事。做好这件事。只做一件事。</em> ————–《代码整洁之道》<br>一个函数做的事情越少其逻辑越简单，难么对应的单元测试也就越简单。</p>
<h5 id="减少外部依赖"><a href="#减少外部依赖" class="headerlink" title="减少外部依赖"></a>减少外部依赖</h5><p>这里要明确的是我们要测试的是自己的函数而不是调用的函数，所以我们应该把中重点放到自己的函数上，至于外部依赖的函数越少越好，因为每个外部依赖都增加了我们单元测试的不确定性。</p>
<h5 id="依赖模块要方便-Mock"><a href="#依赖模块要方便-Mock" class="headerlink" title="依赖模块要方便 Mock"></a>依赖模块要方便 Mock</h5><p>为了专注我们自己模块的测试，对于外部的模块我们一般都会使用<code>Mock</code>的方法, 所以依赖模块如果好<code>Mock</code>的话测试起来就会方便很多，反之会很麻烦。</p>
<h5 id="方便依赖注入"><a href="#方便依赖注入" class="headerlink" title="方便依赖注入"></a>方便依赖注入</h5><p>一般我们<code>Mock</code>是通过依赖注入的方式，这种方式可以方便的更改依赖的对象的实现，而依赖注入的方式有好几种:</p>
<ul>
<li>通过变量赋值</li>
<li>通过参数传递</li>
<li>通过Set/Get方法</li>
</ul>
<h3 id="一个外部依赖的例子"><a href="#一个外部依赖的例子" class="headerlink" title="一个外部依赖的例子"></a>一个外部依赖的例子</h3><p>一个<code>User</code>包, 有一个通过<code>uid</code>获取分数<code>score</code>的方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">                Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">                Password: <span class="string">""</span>,</span><br><span class="line">                DB:       <span class="number">0</span>,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        _, err := client.Ping().Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">        <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个<code>Class</code>包，通过调用<code>user.Score</code>方法获取分数，根据分数给这个用户一个等级:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们要给<code>UserLevel</code>写单元测试，该怎么写呢？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">5</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">--- FAIL: TestUserLevel (0.02s)</span><br><span class="line">    --- FAIL: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">        class_test.go:24: expected: N, got E</span><br><span class="line">    --- FAIL: TestUserLevel/C_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: C, got E</span><br><span class="line">    --- FAIL: TestUserLevel/B_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: B, got E</span><br><span class="line">    --- FAIL: TestUserLevel/A_level (0.00s)</span><br><span class="line">        class_test.go:24: expected: A, got E</span><br><span class="line">    --- FAIL: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">        class_test.go:24: expected: W, got E</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    class   0.023s</span><br></pre></td></tr></table></figure></p>
<p>可以看到除了<code>Got Error</code>运行成功，其他的都失败了，因为我们本地并没有开启<code>redis</code>服务，所以是连不上的。如果我们要让这个测试用例通过，显然我们不能真的开启一个<code>redis</code>的服务，我们需要对<code>user.Score</code>进行<code>Mock</code></p>
<h4 id="Mock框架"><a href="#Mock框架" class="headerlink" title="Mock框架"></a>Mock框架</h4><p>go中<code>mock</code>的支持也有很多种:</p>
<ul>
<li><a href="https://github.com/golang/mock" target="_blank" rel="noopener">github.com/golang/mock</a></li>
<li><a href="https://github.com/bouk/monkey" target="_blank" rel="noopener">github.com/bouk/monkey</a></li>
<li><a href="https://github.com/smartystreets/goconvey" target="_blank" rel="noopener">github.com/smartystreets/goconvey</a></li>
<li><a href="https://github.com/stretchr/testify" target="_blank" rel="noopener">github.com/stretchr/testify</a></li>
<li><a href="https://github.com/prashantv/gostub" target="_blank" rel="noopener">github.com/prashantv/gostub</a></li>
</ul>
<p>每个框架都有自己的用法， 这里我那<code>github.com/bouk/monkey</code>来举例子, 改造一下我们的单元测试:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"bou.ke/monkey"</span></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        monkey.Patch(user.Score, mockScore)</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mockScore</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.014s</span><br></pre></td></tr></table></figure></p>
<h4 id="面相接口编程"><a href="#面相接口编程" class="headerlink" title="面相接口编程"></a>面相接口编程</h4><p>前面通过<code>Mock</code>框架我们可以在测试的时候替换原来的实现，这样就可以很方便的进行单元测试了,但是这种代码的实现方式其实并不符合面相对象设计的原则, 下面提出两个问题:</p>
<ol>
<li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?</li>
<li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？</li>
</ol>
<p>可见上面的方式不太灵活，面对复杂多变的需求无法很好的满足。这时就要求我们改用面相接口编程, 下面是我们使用面相接口编程的方式改进了上面的实现:<br><code>user</code>包增加了一个<code>User</code>接口，这个接口有一个函数<code>Score</code>, 然后定义了一个<code>defaultUser</code>, 并且实现了<code>Score</code>函数，最后定一个<code>New</code>函数向外输出这个<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class</code>包调用由原来的通过包直接调用改为了增加一个<code>u</code>变量, 然后调用<code>u.Score</code>来获取信息:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    score, err := u.Score(uid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class_test</code>不再依赖<code>mock</code>框架，而是实现了自己的<code>User</code>接口<code>mockUser</code>，替换了<code>user</code>包的<code>defaultUser</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">                input <span class="keyword">int</span></span><br><span class="line">                want  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">                <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">                <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">                <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">                <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">                <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u = mockUser&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">                got := UserLevel(tc.input)</span><br><span class="line">                t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> uid &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.005s</span><br></pre></td></tr></table></figure></p>
<p>下面再来看上面提出的两个问题:</p>
<ol>
<li>如果我们不依赖<code>Mock</code>框架该如何<code>mock</code>?<br>答: 根据上面的实现可以看到，我们没有借助任何框架同样完成了<code>Mock</code>的效果</li>
<li>如果有一天我们不从<code>redis</code>获取数据，而是要从<code>mysql</code>获取数据了，怎么改？直接改<code>Score</code>函数么？那么如果有一天又要从<code>redis</code>获取数据呢？或者有的调用者是从<code>redis</code>获取数据，有的是从<code>mysql</code>获取数据怎么办？<br>答: 由于面相接口编程，我们可以在user中增加一个实例实现从<code>mysql</code>获取数据的方法，调用者可以根据需求选择不同的实例，而且如果调用者对这个数据来源有自己的需求，甚至可以自己实现这个接口。</li>
</ol>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>上面的实现我们可以看到每次调用<code>var u =  user.New()</code>都会新建一个<code>defaultUser</code>对象，对于有些需要共享<code>defaultUser</code>状态的情况下，例如<code>defaultUser</code>中有一个常驻内存共享的数据, 我们在多个包调用的时候其实那得是不同的对象，为了共享这个数据我们把<code>user.New</code>改成下面的实现:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样每次返回的其实都是同一个<code>defaultUser</code>。</p>
<h4 id="更方便的调用"><a href="#更方便的调用" class="headerlink" title="更方便的调用"></a>更方便的调用</h4><p>上面我们看出，修改为面相接口编程后我们需要通过依赖注入传递对象，但是这样会对调用者照成麻烦，我们是否可以在优化一下呢?<br>我们在<code>user</code>中增加一个函数:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以通过<code>user.Score</code>调用<code>du.Score</code>函数了，所以<code>class.go</code>的实现可以改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLevel</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        score, err := user.Score(uid)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> score &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"N"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">60</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"W"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上去不错，但是我们如何进行依赖注入呢？不然单元测试使用的是默认实现，我们没办法做单元测试了。前面其实我们提过依赖注入的方式有一个<code>Get/Set</code>方式，我们可以再修改一下<code>user</code>包:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/go-redis/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">interface</span> &#123;</span><br><span class="line">    Score(<span class="keyword">int</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> definedUser != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> definedUser.Score(uid)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> du.Score(uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> definedUser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">    definedUser = u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> du = defaultUser&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> du</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> defaultUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(defaultUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">"localhost:6379"</span>,</span><br><span class="line">        Password: <span class="string">""</span>,</span><br><span class="line">        DB:       <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    _, err := client.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, err := client.Get(strconv.Itoa(uid)).Result()</span><br><span class="line">    <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strconv.Atoi(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>class</code>不用修改，<code>class_test</code>修改为:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserLevel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        input <span class="keyword">int</span></span><br><span class="line">        want  <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="string">"not found user"</span>: &#123;input: <span class="number">1</span>, want: <span class="string">"N"</span>&#125;,</span><br><span class="line">        <span class="string">"C level"</span>:        &#123;input: <span class="number">2</span>, want: <span class="string">"C"</span>&#125;,</span><br><span class="line">        <span class="string">"B level"</span>:        &#123;input: <span class="number">3</span>, want: <span class="string">"B"</span>&#125;,</span><br><span class="line">        <span class="string">"A level"</span>:        &#123;input: <span class="number">4</span>, want: <span class="string">"A"</span>&#125;,</span><br><span class="line">        <span class="string">"Got Error"</span>:      &#123;input: <span class="number">5</span>, want: <span class="string">"E"</span>&#125;,</span><br><span class="line">        <span class="string">"Wrong Score"</span>:    &#123;input: <span class="number">6</span>, want: <span class="string">"W"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user.SetUser(mockUser&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := UserLevel(tc.input)</span><br><span class="line">        t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> tc.want != got &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"expected: %s, got %s"</span>, tc.want, got)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mockUser <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mockUser)</span> <span class="title">Score</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> uid &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">70</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">95</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"something was error"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">130</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过<code>user.SetUser</code>方法用自己的实现替换了之前默认的实现，这样我们就可以方便的进行单元测试了。<br>运行单元测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v</span><br><span class="line">=== RUN   TestUserLevel</span><br><span class="line">=== RUN   TestUserLevel/Wrong_Score</span><br><span class="line">=== RUN   TestUserLevel/not_found_user</span><br><span class="line">=== RUN   TestUserLevel/C_level</span><br><span class="line">=== RUN   TestUserLevel/B_level</span><br><span class="line">=== RUN   TestUserLevel/A_level</span><br><span class="line">=== RUN   TestUserLevel/Got_Error</span><br><span class="line">--- PASS: TestUserLevel (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Wrong_Score (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/not_found_user (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/C_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/B_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/A_level (0.00s)</span><br><span class="line">    --- PASS: TestUserLevel/Got_Error (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      class   0.011s</span><br></pre></td></tr></table></figure></p>
<p>在大多数情况下，我们都是使用的默认实现，只有在我们必须要修改依赖的实现，或者单元测试时才会使用其他的实现，所以为了大多数的场景下调用简单，我们应该尽量使用这种方式来实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要回顾了一下关于单元测试的一些理论知识: </p>
<ul>
<li>测试的粒度应该是测试包中的可导出函数</li>
<li>测试的原则告诉我们应该是变测试变开发, 相互交替进行</li>
<li>测试的目的应该是测试行为，而不是测试具体的实现</li>
</ul>
<p>关于Go的单元测试可以分为三个阶段:</p>
<ul>
<li>初级阶段: 主要是认识Go的单元测试基本写法，以及如何利用Go的工具链运行单元测试及查看单元测试覆盖率的情况</li>
<li>进阶阶段: 主要是举一个单元测试的例子，通过不断改进这个单元测试的写法来告诉我们如何写出更好的单元测试</li>
<li>高级阶段: 介绍了如何写出可测试的函数，面对复杂的调用和多变得需求如何利用面相接口编程和依赖注入改进我们的程序的写法</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf" target="_blank" rel="noopener">Test-Driven Development By Example</a><br><a href="https://github.com/gopherchina/conference/blob/master/2019/1.4%20Testing%3B%20how%2C%20what%2C%20why%20-%20Dave%20.pdf" target="_blank" rel="noopener">Testing; how, what, why - Dave</a><br><a href="https://www.youtube.com/watch?v=EZ05e7EMOLM" target="_blank" rel="noopener">TDD, Where Did It All Go Wrong - Lan Cooper</a><br><a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" target="_blank" rel="noopener">The Three Laws of TDD.</a><br><a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">深度解读 - TDD（测试驱动开发）</a><br><a href="https://mp.weixin.qq.com/s/FnKkZD4DdPVX7PPH3dY8-w" target="_blank" rel="noopener">如何写出优雅的 Golang 代码</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">单元测试wiki</a><br><a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="noopener">How to Write Go Code - Testing</a><br><a href="https://teamgaslight.com/blog/testing-behavior-vs-testing-implementation" target="_blank" rel="noopener">Testing Behavior vs. Testing Implementation</a><br><a href="http://codebetter.com/iancooper/2011/10/06/avoid-testing-implementation-details-test-behaviours/" target="_blank" rel="noopener">Avoid Testing Implementation Details, Test Behaviours</a><br><a href="https://baike.baidu.com/item/%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">边界条件测试</a><br><a href="https://item.jd.com/10064006.html" target="_blank" rel="noopener">代码整洁之道</a><br><a href="https://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">Mocks Aren’t Stubs</a><br><a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">TestDouble</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>