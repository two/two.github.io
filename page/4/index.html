<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 4 | oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2014/11/07/gdb-manual/"><span>GDB使用手册</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/11/07/gdb-manual/" rel="bookmark">
        <time class="entry-date published" datetime="2014-11-06T16:00:00.000Z">
          2014-11-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<blockquote>
<p>在学习C语言和学习源代码的过程中为了了解代码的运行过程，必须要DEBUG。GDB是一个不错的选择，有着强大的功能和成熟的技术。本博客记录GDB的各种使用方法，以便进行不断的学习总结。</p>
</blockquote>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/C/">C</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/GDB-DEBUG/">GDB DEBUG</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/07/05/coreseek-manual/"><span>coreseek使用手册</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/07/05/coreseek-manual/" rel="bookmark">
        <time class="entry-date published" datetime="2014-07-04T16:00:00.000Z">
          2014-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="产生文本摘要和高亮"><a href="#产生文本摘要和高亮" class="headerlink" title="产生文本摘要和高亮"></a>产生文本摘要和高亮</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型:"></a>函数原型:</h3><p><code>function BuildExcerpts ( $docs, $index, $words, $opts=array() )</code></p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档:"></a>相关文档:</h3><p>(<a href="http://www.coreseek.cn/docs/coreseek_4.1-sphinx_2.0.1-beta.html#api-func-buildexcerpts" target="_blank" rel="noopener">官方文档</a>)<br>该函数用来产生文档片段（摘要）。连接到searchd，要求它从指定文档中产生片段（摘要），对命中词高亮，并返回结果。  </p>
<ul>
<li><code>$docs</code>为包含各文档内容的数组。必须把需要高亮的文本内容以数组的形式传入到函数中，最后输出的是标红后的文本摘要数组。</li>
<li><code>$index</code>为包含索引名字的字符串。给定索引的不同设置（例如字符集、形态学、词形等方面的设置）会被使用。</li>
<li><code>$words</code>为包含需要高亮的关键字的字符串。它们会按索引的设置被处理。例如，如果英语取词干（stemming）在索引中被设置为允许，那么即使关键词是“shoe”，“shoes”这个词也会被高亮。从版本0.9.9-rc1开始，关键字可以包含通配符，与查询支持的star-syntax类似。</li>
<li><p><code>$opts</code>为包含其他可选的高亮参数的hash表：</p>
<ul>
<li><code>&quot;before_match&quot;</code>:在匹配的关键字前面插入的字符串。从版本 1.10-beta开始，可以在该字符串中使用%PASSAGE_ID%宏。该宏会被替换为当前片段的递增值。递增值的起始值默认为1，但是可以通过</li>
<li><code>&quot;start_passage_id&quot;</code>设置覆盖。在多文档中调用时，%PASSAGE_ID%会在每篇文档中重新开始。默认为”<b>“。</b></li>
<li><code>&quot;after_match&quot;</code>:在匹配的关键字后面插入的字符串。从版本1.10-beta开始，可以在该字符串中使用%PASSAGE_ID%宏。默认为 ““。</li>
<li><code>&quot;chunk_separator&quot;</code>:在摘要块（段落）之间插入的字符串。默认为” … “.</li>
<li><code>&quot;limit&quot;</code>:摘要最多包含的符号（码点）数。整数，默认为256。</li>
<li><code>&quot;around&quot;</code>:每个关键词块左右选取的词的数目。整数，默认为 5.</li>
<li><code>&quot;exact_phrase&quot;</code>:是否仅高亮精确匹配的整个查询词组，而不是单独的关键词。布尔值，默认为false.</li>
<li><code>&quot;single_passage&quot;</code>:是否仅抽取最佳的一个区块。布尔值，默认为false.</li>
<li><code>&quot;use_boundaries&quot;</code>:是否跨越由phrase_boundary选项设置的词组边界符。布尔型，默认为false.</li>
<li><code>&quot;weight_order&quot;</code>:对于抽取出的段落，要么根据相关度排序（权重下降），要么根据出现在文档中的顺序（位置递增）。布尔型，默认是false.</li>
<li><code>&quot;query_mode&quot;</code>:版本1.10-beta新增。设置将<code>$words</code>当作 扩展查询语法的查询处理，还是当做普通的文本字符串处理（默认行为）。例如，在查询模式时，(“one two” | “three four”)仅高亮和包含每个片段中出现”one two” 或 “three four” 的地方及相邻的部分。而在默认模式时， 每个单独出现”one”, “two”, “three”, 或 “four”的地方都会高亮。布尔型，默认是false。</li>
<li><code>&quot;force_all_words&quot;</code>:版本1.10-beta新增. 忽略摘要的长度限制直至包含所有的词汇。布尔型，默认为false.</li>
<li><code>&quot;limit_passages&quot;</code>:版本1.10-beta新增. 限制摘要中可以包含的最大区块数。整数值，默认为 0 (不限制).</li>
<li><code>&quot;limit_words&quot;</code>:版本1.10-beta新增. 限制摘要中可以包含的最大词汇数。整数值，默认为 0 (不限制).</li>
<li><code>&quot;start_passage_id&quot;</code>:版本1.10-beta新增. 设置 %PASSAGE_ID% 宏的起始值 (在before_match, after_match 字符串中检查和应用). 整数值，默认为1.</li>
<li><code>&quot;load_files&quot;</code>:版本1.10-beta新增. 设置是否将$docs作为摘要抽取来源的数据（默认行为），或者将其当做文件名。从版本2.0.1-beta开始，如果该标志启用，每个请求将创建最多dist_threads个工作线程进行并发处理。布尔型，默认为false.</li>
<li><code>&quot;html_strip_mode&quot;</code>:版本1.10-beta新增. HTML标签剥离模式设置。默认为”index”，表示使用index的设置。可以使用的其他值为”none”和”strip”，用于强制跳过或者应用剥离，而不管索引如何设置的。还可以使用”retain”，表示保留HTMK标签并防止高亮时打断标签。”retain”模式仅用于需要高亮整篇文档，并且不能设置限制片段的大小。字符型，可用值为”none”，”strip”，”index”或者”retain”。</li>
<li><code>&quot;allow_empty&quot;</code>:版本1.10-beta新增. 允许无法产生摘要时将空字符串作为高亮结果返回 (没有关键字匹配或者不符合片段限制。). 默认情况下，原始文本的开头会被返回而不是空字符串。布尔型，默认为false.</li>
<li><p><code>&quot;passage_boundary&quot;</code>:版本2.0.1-beta新增. 确保区块不跨越句子，段落或者zone区域（仅当每个索引的设置启用时有效）。字符型，可用值为 “sentence”, “paragraph”, 或者 “zone”.”emit_zones”:版本2.0.1-beta新增. 在每个区块前使用区域对应的HTML标签来封闭区域。布尔型，魔默认为false。</p>
<p>摘要提取算法倾向于提取更好的片段（与关键词完全匹配），然后是不在摘要中但是包含了关键词的片段。 通常情况下，它会尝试高亮查询的最佳匹配，并且在限制条件下尽可能的高亮查询中的所有关键词。 如果文档没有匹配查询，默认情况下将根据限制条件返回文档的头部。从版本1.10-beta开始，可以通过设置allow_empty属性位true以返回空的片段来替代默认方式。<br>失败时返回false。成功时返回包含有片段（摘要）字符串的数组。</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//...略</span><br><span class="line">include(&quot;SphinxClient.php&quot;);</span><br><span class="line">class test&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected function make_words_highLight($source,$kw)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $cll = new SphinxClient ();</span><br><span class="line">        $opts = array</span><br><span class="line">            (</span><br><span class="line">                &quot;before_match&quot;      =&gt; &quot;&lt;span style=&apos;color:red&apos;&gt;&quot;,</span><br><span class="line">                &quot;after_match&quot;          =&gt; &quot;&lt;/span&gt;&quot;,</span><br><span class="line">                &quot;chunk_separator&quot;     =&gt; &quot; ... &quot;,</span><br><span class="line">                &quot;limit&quot;                =&gt; 10,</span><br><span class="line">                &quot;around&quot;               =&gt; 6,</span><br><span class="line">            );</span><br><span class="line">        $index = &quot;test1&quot;;</span><br><span class="line">        return $cll-&gt;BuildExcerpts($source,$index,$kw,$opts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //test</span><br><span class="line">    public function test()&#123;</span><br><span class="line">        $content = array(&quot;北京是中华人民共和国的首都&quot;,&quot;中国的首都是北京，2008奥运会就在这里举办的&quot;,&quot;京东老板刘强东&quot;);</span><br><span class="line">        $qsKey = &quot;北京 东&quot;;</span><br><span class="line">        $contentArr = $this-&gt;make_words_highLight($content,$qsKey);</span><br><span class="line">        print_r($contentArr);die;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$m = new test();</span><br><span class="line">$m-&gt;test();</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">//输出结果</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; &lt;span style=&apos;color:red&apos;&gt;北京&lt;/span&gt;是中华人民共和国 ... </span><br><span class="line">    [1] =&gt;  ... 首都是&lt;span style=&apos;color:red&apos;&gt;北京&lt;/span&gt;，2008 ... </span><br><span class="line">    [2] =&gt; 京东老板刘强&lt;span style=&apos;color:red&apos;&gt;东&lt;/span&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="mmseg-同义词-复合分词处理"><a href="#mmseg-同义词-复合分词处理" class="headerlink" title="mmseg 同义词/复合分词处理"></a>mmseg 同义词/复合分词处理</h2><h3 id="文档-官方文档"><a href="#文档-官方文档" class="headerlink" title="文档(官方文档)"></a>文档(<a href="http://www.coreseek.cn/opensource/mmseg/#coreseek_mmseg_complex" target="_blank" rel="noopener">官方文档</a>)</h3><p>mmseg 3.2.13版本开始，提供了类似复合分词的处理方式，供coreseek进行调用。<br>其基本使用状况为：</p>
<ul>
<li>词库包含：<code>南京西路、南京、西路</code>(注意，一定要加入生成uni.lib的词库中)</li>
<li>索引时：文本中的“南京西路”会被同时索引为以上三者查</li>
<li>查询时：输入南京西路，可以直接匹配南京西路，而不匹配南京或者西路；输入南京或者西路，也可以搜索到南京西路</li>
</ul>
<p>用法：</p>
<ol>
<li>处理<code>unigram.txt</code>(在<code>mmseg3/etc</code>目录下)将词库加入，利用命令<code>mmseg -u unigram.txt</code> 生成新的词库<code>unigram.txt.uni</code>,用新的词库替代老词库<code>mv unigram.txt.uni uni.lib</code>(ps:被替换的同义词必须加入词库中，例如想让一个没有的词<code>测试</code>映射同义词<code>南京西路</code>则需要<code>南京西路</code>在词库中,<code>测试</code>不需要加入).</li>
<li><p>生成同义词库文件mmseg-3.2.13源代码<code>/script/build_thesaurus.py unigram.txt &gt; thesaurus.txt</code>(默认的同义词库，可自己修改).<br><code>thesaurus.txt</code>文件的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">南京西路</span><br><span class="line">-南京,西路,</span><br><span class="line">张三丰</span><br><span class="line">-太极宗师,武当祖师,</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成同义词词典:<code>mmseg -t thesaurus.txt</code>. 将<code>thesaurus.lib</code>放到<code>uni.lib</code>同一目录</p>
</li>
<li>停止索引服务searchd，重新建立索引，然后启动searchd (ps : 如果只是加入了新的同义词映射，没有修改词表的话不需要重启服务，只需重建索引即可)</li>
<li>coreseek索引和搜索时，会自动进行复合分词处理。搜索<code>南京</code>，<code>西路</code>时都能将搜索<code>南京西路</code>的结果匹配到</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/coreseek/">coreseek</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/26/csapp-chapter8/"><span>csapp chapter8:异常控制流</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/26/csapp-chapter8/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-25T16:00:00.000Z">
          2014-05-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>程序运行的顺序是根据程序计数器（PC）的值而定的，PC从一个地址到另一个地址的过渡称为<em>控制转移(control transfer)</em>,这样的控制转移序列叫做处理器的<em>控制流(flow of control或 control flow)</em>。一般如果PC是按照顺序地址进行过渡的，控制流是一个平滑的序列，但是有些情况下PC是来回跳转的，这些突变称为<em>异常控制流(Exceptional Control Flow 简称EFC)</em>,EFC发生在计算机系统的各个层次。本章主要分析这种异常控制流。</p>
</blockquote>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常(exception)就是控制流中的突变,用来响应处理器状态中的某些变化。<br>下面通过一个图来理解异常.<br><img src="/assets/img/csapp/fig8.1.png" alt><br>可以看到程序在执行到<em> \(I_{curr}\) </em>时发生了一个异常，导致程序从原来该执行<em> \(I_{next}\)</em> ，变为了执行异常处理, 在执行完异常出理由程序后有下面三种可能：</p>
<ul>
<li>处理程序将控制返回给当前指令\(I_{curr}\), 即当事件发生时正在执行的命令。</li>
<li>处理程序将控制权返回给\(I_{next}\), 即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ul>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张<em>异常表</em>的跳转表,进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler))。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>系统为每个异常的类型都分配了一个唯一的非负整数的<em>异常号(exception number)</em>, 每个异常处理号都对应了一个异常处理程序，这些异常处理程序有些是处理器设计者分配的，有些事操作系统内核的设计者分配的，前者主要包括被零除，缺页，存储器访问违例、断点以及算术溢出，后者主要包括系统调用和来自外部I/O设备的信号。<br>在系统启动时，操作系统分配和初始化一张称为<em>异常表</em>的跳转表，如下：<br><img src="/assets/img/csapp/fig8.2.png" alt><br>这个图显示了如何利用根据异常号来找异常处理程序，并执行。  </p>
<p><strong>异常与过程调用的区别</strong>：</p>
<ul>
<li>异常调用时，在跳转处理器之前，处理器将返回地址压入栈中。返回地址是根据异常的类型而定的，可能是当前指令的地址，也可能是下一条指令的地址。过程调用一般入栈的是下一条指令的地址。</li>
<li>处理器把一些额外的处理器状态压到栈里，当处理程序返回时，重新开始被中断的程序会需要这些状态。</li>
<li>如果控制从一个用户程序转移到内核，那么所有的这些项目都被压入内核栈中，而不是压到用户栈中。</li>
<li>异常处理程序运行在内核模式下。这意味着它们对所有的系统资源具有完全的访问权限。</li>
</ul>
<p><strong>异常的类别</strong>:</p>
<ul>
<li><strong>中断</strong>:当前指令执行完后，会发现中断引脚的电压高了，就从系统总线读取处理程序。这种异常一般都是由外部的设备引起的，跟处理程序之间没有必然的联系，所以是异步的。下面的都是程序运行过程中自己有意或无意的引起的，所以事同步的行为。</li>
<li><strong>陷阱</strong>:是一个有意的异常，是执行一条指令引起的，引起异常的指令一般都是系统调用函数（如fork, single, exit, waitpid等），这些函数调用使程序从用户模式切换到了内核模式。</li>
<li><strong>故障</strong>:故障是由程序运行中的错误造成的，它能够被捕获并被故障处理程序修正。这种故障如缺页异常等。</li>
<li><strong>终止</strong>:这种异常一般是指不会恢复的致命错误。通常是一些硬件错误。</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自I/O设备的信号</td>
<td>异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/CSAPP/">CSAPP</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/21/csapp-chapter7/"><span>csapp chapter7:链接</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/21/csapp-chapter7/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-20T16:00:00.000Z">
          2014-05-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可以被加载（或拷贝）到存储器并执行。链接可以执行于编译时（compile time）,也就是在源代码被翻译成为机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到存储器并执行时；甚至执行于运行时(rum time),由应用程序来执行。</p>
</blockquote>
<p>链接器使得分离编译(separate compilation)成为可能。本章将讨论从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接。</p>
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>通过一个例子来说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># main.c</span><br><span class="line">void swap();</span><br><span class="line">int buf[2] = &#123;1, 2&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    swap();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># swap.c</span><br><span class="line">extern int buf[];</span><br><span class="line">int *bufp0 = &amp;uf[0];</span><br><span class="line">int *bufp1;</span><br><span class="line"></span><br><span class="line">void swap()</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    bufp1 = &amp;buf[1];</span><br><span class="line">    temp = *bufp0;</span><br><span class="line">    *bufp0 = *bufp1;</span><br><span class="line">    *bufp1 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大多数系统提供<em>编译驱动程序(compiler driver)</em>,它代表用户在需要时调用语言预处理器，编译器，汇编器和链接器。<br>运行<code>gcc main.c swap.c -o p</code>命令都发生了什么？</p>
<ol>
<li>预处理器先将<code>main.c</code>和<code>swap.c</code>翻译成一个ASCII码的中间文件<code>main.i</code>和<code>swap.i</code></li>
<li>C编译器将<code>main.i</code>和<code>swap.i</code>翻译成ASCII汇编语言文件<code>main.s</code>和<code>swap.s</code></li>
<li>汇编器将<code>main,s</code>和<code>swap.s</code>翻译成<em>可重定定位的目标文件</em><code>main.o</code>和<code>swap.o</code></li>
<li>连接器程序ld将<code>main.o</code>和<code>swap.o</code>以及一些必要的系统目标文件组合起来，创建<em>可执行目标文件</em>p</li>
</ol>
<p>生产了可执行文件，可以通过过<code>./p</code>来运行，这是由外壳调用操作系统一个叫做<em>加载器</em>的函数,它拷贝可执行文件<code>p</code>中的代码和数据到存储器，然后将控制转移到这个程序的开头。</p>
<p>本章主要讲的是第4步的内容。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>将一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。完成这种功能的是静态连接器，为了构造可执行文件，连接器必须完成两个主要任务：</p>
<ul>
<li><em>符号解析</em>(symbol resolution):目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li>
<li><em>重定位</em>(relocation):编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定为这些节。</li>
</ul>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件可以分为三种形式：</p>
<ul>
<li><em>可重定位目标文件</em>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li><em>可执行目标文件</em> 包含二进制代码和数据，其形式可以被直接拷贝到存储器链接并执行。</li>
<li><em>共享目标文件</em>：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器这并连接。</li>
</ul>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>一个典型的可重定位目标文件(ELF)的格式如下：<br><img src="/assets/img/csapp/fig7.3.png" alt>  </p>
<ul>
<li>ELF头：包含生成该文件的系统的字的大小和字节顺序，以及帮助连接器分析和解释的目标文件的信息。</li>
<li>.text: 已编译程序的机器代码</li>
<li>.rodata: 只读数据，比如printf语句中的格式串和开关语句的跳转表</li>
<li>.data: <em>已初始化的全局C变量</em>。局部C变量在运行时保存在栈中。</li>
<li>.bass: <em>未初始化的全局C变量</em>。它仅仅是一个占位符，不占用磁盘空间。</li>
<li>.symtab: 一个<em>符号表</em>。它存放在程序中定义和引用的函数和全局变量的信息。</li>
<li>.rel.text: 一个.text节中位置的列表，当连接器把这个目标文件和其他文件结合时，需要修改这些位置。</li>
<li>.rel.data: 被模块引用或定义的任何全局变量和重定位信息。</li>
<li>.debug: 一个调试符号表。</li>
<li>.line: 原始C源程序中的行号和.text节中机器指令之间的映射。</li>
<li>.strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，及节头部中的节名字。<br>其中，每个部分都称为节**</li>
</ul>
<h2 id="符号和符号表-symtab"><a href="#符号和符号表-symtab" class="headerlink" title="符号和符号表(.symtab)"></a>符号和符号表(.symtab)</h2><p>链接器的上下文中有三种不同的符号：</p>
<ul>
<li>由m定义并能被其他模块引用的全局符号。对应C语言中具有文件作用域并具有外部链接的变量</li>
<li>由其他模块定义并被模块m引用的全局符号。对应C语言中的变量与上面一样，并在本文件中用external声明</li>
<li>只被模块m定义和引用的本地符号。对应C语言中具有文件作用域但是具有内部链接的变量，如被static声明的全局变量。</li>
</ul>
<p>符号表包含一个数组，每个元素的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int name; //字符串表(strtab)中的字节偏移。</span><br><span class="line">    int value; //符号地址，是距定义目标的节的起始位置的偏移。对可执行文件来说是一个绝对运行时地址。</span><br><span class="line">    int size; //目标大小</span><br><span class="line">    int type:4, //是变量或者函数</span><br><span class="line">        binding:4; //表示是本地的还是全局的</span><br><span class="line">    char reserved; //保留的</span><br><span class="line">    char section; //表示符号和目标文件的某个节相关联,也就是这个符号在那个节中</span><br><span class="line">&#125; Elf_Symbol;</span><br></pre></td></tr></table></figure><br>看一下main.o的符号表中最后三个条目:</p>
<table>
<thead>
<tr>
<th>Num(name):</th>
<th>Value</th>
<th>Size</th>
<th>Type</th>
<th>Bind</th>
<th>Ot</th>
<th>Ndx(section)</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>8:</td>
<td>0(偏移为0)</td>
<td>8(8字节大小)</td>
<td>OBJECT(变量对象)</td>
<td>GLOBAL(全局的符号)</td>
<td>0</td>
<td>3(表示第三个节.data)</td>
<td>buf(符号名)</td>
</tr>
<tr>
<td>9:</td>
<td>0(偏移为0)</td>
<td>17(17字节大小)</td>
<td>FUNC(函数对象)</td>
<td>GLOBAL(全局的符号)</td>
<td>0</td>
<td>1(表示第一个节.text)</td>
<td>main(符号名)</td>
</tr>
<tr>
<td>10:</td>
<td>0</td>
<td>0</td>
<td>NOTYPE</td>
<td>GLOBAL</td>
<td>0</td>
<td>UND(表示外部符号引用)</td>
<td>swap(符号名)</td>
</tr>
</tbody>
</table>
<p>这个地方有点晕，因为前面说第一个是自己偏移，下面这个变成了name, 最有一个是符号名Name,但是上面结构中并没有说有这个字段, 表格中和结构中的字段写法不一样，实在是太难理解～<br>总而言之，符号表就是对每个符号的信息描述，这个符号表什么时候用呢？符号解析的时候。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接器对多个可重定位目标文件进行解析的时候，读取每个文件的符号表，然后根据符号表的信息，与这个符号在代码中的确定的定义联系起来，目的是为了把所有的符号都合并在一起，形成一个完整的符号表，再加上其他信息，就变成了可执行文件。</p>
<p>这个过程在这里详细介绍一下，因为这里设计的链接器最核心的部分：如何变成可执行文件。</p>
<h3 id="链接器如何解析多重定义的全局符号"><a href="#链接器如何解析多重定义的全局符号" class="headerlink" title="链接器如何解析多重定义的全局符号"></a>链接器如何解析多重定义的全局符号</h3><p>把符号分为强和弱。对于函数和已初始化的全局变量是<em>强符号</em>， 对于未初始化的变量是<em>弱符号</em>。unix链接器使用下面的规则来处理<em>多重定义</em>的符号：</p>
<ul>
<li>不允许有多个强符号</li>
<li>如果一个强符号和多个弱符号，那么选择强符号。</li>
<li>如果有多个弱符号，那么从这些弱符号中任意选择一个。</li>
</ul>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>一旦链接器完成了符号解析这一步，它就把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。链接器根据输入目标模块中的代码节和数据节的确切大小，就可以开始重定位了：</p>
<ul>
<li>重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节。然后链接器将<em>运行时存储器地址</em>赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li>
<li>重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器严重依赖称为<em>重定位条目</em>的可重定位目标模块中的数据结构。</li>
</ul>
<h3 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h3><p>由于汇编器生成目标模块时，并不知道数据和代码最终将存放在存储器中的什么位置，所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个<em>重定位条目</em>，告诉链接器将目标文件合成可执行文件时如何修改这个引用。<br>代码的重定位条目放在.rel.text中。已初始化的数据重定位条目放在.rel.data中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int offset; //偏移位置</span><br><span class="line">    in symbol:24, //指向引用的节</span><br><span class="line">        type:8; //重定位类型</span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><br>重定位类型有11种，没种的实现方式不一样，这里只介绍两种最基本的：</p>
<ul>
<li>R_386_PC32: 使用一个32位PC（程序计数器）相对地址的引用。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行值，得到<em>有效地址</em>。</li>
<li>R_386_32: 重定位一个使用32位绝地地址的引用。通过绝对寻址，CPU直接使用在指令种编码 的32位值作为有效地址，不需要进一步修改。</li>
</ul>
<p>通过反汇编可执行文件，我们可看到重定位后的.text节的内容。</p>
<h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><p>已经知道链接器将多个目标模块合并成一个可执行目标文件的。我们的C程序已经从ASCII码转化成了一个二进制文件，且这个二进制文件包含加载程序到存储器并运行它所需的所有信息。下图是一个典型的ELF可执行文件中的各类信息。<br><img src="/assets/img/csapp/fig7.11.png" alt><br>由于可执行文件是完全链接的(已被重定位)，所以它不再需要.rel节。我们发现还多了一个.init节，这个节定义了一个小函数，叫做_init,程序的初始化代码会调用它。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/CSAPP/">CSAPP</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/18/csapp-chapter6/"><span>csapp chapter6:存储器层次结构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/18/csapp-chapter6/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-17T16:00:00.000Z">
          2014-05-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。程序如何利用存储器的特性提高性能呢？这将是本章主要探讨的内容。</p>
</blockquote>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p>计算机的的成功很大程度上源自于存储技术的巨大进步。下面这幅图是存储器的层次结构：<br><img src="/assets/img/csapp/fig6.23.png" alt>  </p>
<p>从上到下，存储的速度越慢，容量越大。<br>关于存储器内部是实现方式这就不介绍了，重点介绍一下计算机存储器的运行方式。<br>存储器层次结构的中心思想，对于每个<em>k</em>层，位于<em>k</em>层的更快更小的存储设备作为位于<em>k+1</em>层的跟大更慢的存储设备的缓存。也就是说层次结构中的<em>k</em>层的数据都是来自<em>k+1</em>层的。数据在每层之间的传送是以块大小为传送单元的。不同层之间的块大小可以不一样。程序运行过程中，对存储器的运用分为两种情况：</p>
<ul>
<li>缓存命中: 当程序需要数据时，最先从最高的层开始查找，如果没有找到了所需的数据，就是缓存命中。</li>
<li>缓存不命中: 当所需的数据从当前层没有找到，就叫缓存不命中。这时候就会从下一层开始查找，直到找到所需的数据为止。当找到所需的数据后，数据会再次经过上面的层，把找到的数据保存到上面的层中，这时就要覆盖上面层的数据，如何覆盖，这涉及到替换策略，不再详述。</li>
</ul>
<p>通过上面存储器的使用方式，可以看出，要想提高程序的性能，就必须利用<em>时间局部性</em>和<em>空间局部性</em>。</p>
<ul>
<li>时间局部性: 如果一个数据被加载到了最上层，那么如果连续多次调用这个数据就不需要去其他层寻找，减少了数据寻找和写缓存的过程，大大提高到了利用效率。</li>
<li>空间局部性： 但一个数被加载的最上层时，由于数据时以块大小进行传递的，所以这个数据相邻的地址数据也会被传递，所以如果这时候访问相邻的数据话，很有可能就在这一层，而不需要去其他层寻找数据，也大大提高了利用率。 </li>
</ul>
<p>下面通过一个程序来说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int sum1(int a[M][N])</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, sum = 0;</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; M; i++)</span><br><span class="line">        for(j = 0; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum2(int a[M][N])</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, sum = 0;</span><br><span class="line"></span><br><span class="line">    for(j = 0; j &lt; M; j++)</span><br><span class="line">        for(i = 0; i &lt; N; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于sum1和sum2两个程序都时求一个二纬数组的和，唯一不同的是循环变量，也就是数组的下标顺序不一样。对于sum1，由于二纬数组是顺序存储的，而求和的时候也是按照递增的地址顺序求和的，这很好的利用了<em>空间局部性</em>这个原理，而sum2，同样是求和，但是二维数组的顺序并不是顺序访问的，又跳跃，所以每次访问的地址不是连续的，没有很好的利用<em>空间局部性</em>的原理，效率要低很多。<br>另一方面，两个程序的循环的过程中都使用了一个auto变量sum，每次循环都访问这个变量的值，这很好的利用了<em>时间局部性</em>原理。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/CSAPP/">CSAPP</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/13/coreseek-install-doc/"><span>中文搜索引擎coreseek的安装使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/13/coreseek-install-doc/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-12T16:00:00.000Z">
          2014-05-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>项目中原来使用的是solr,由于solr是java写的，团队中没有java的经验，并且原来维护的人离职了，所以改用<a href="http://sphinxsearch.com/" target="_blank" rel="noopener">sphinx search</a>来做项目的内部检索服务，由于中文的特殊性，我们选择了<a href="http://www.coreseek.cn/" target="_blank" rel="noopener">coreseek</a>这个基于sphinx的中文搜索引擎。但是好像这个好久没人维护了～一直停留在了4.1beta版本～</p>
</blockquote>
<h2 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h2><p>源码下载地址<a href="http://www.coreseek.cn/uploads/csft/4.0/coreseek-4.1-beta.tar.gz" target="_blank" rel="noopener">oreseek-3.1-beta.tar.gz</a>;<br>解压下载的文件,进入目录<code>cd coreseek-4.1-beta</code>;</p>
<h2 id="安装中文分词库mmseg"><a href="#安装中文分词库mmseg" class="headerlink" title="安装中文分词库mmseg"></a>安装中文分词库mmseg</h2><ul>
<li><code>cd mmseg-3.2.14/</code></li>
<li><code>./bootstrap</code></li>
<li><code>./configure --prefix=/usr/local/mmseg3</code></li>
<li><code>make &amp;&amp; make install</code></li>
</ul>
<p>如果你幸运的话，这时候会提示错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">css/SynonymsDict.cpp:94: 错误：在 &#123;&#125; 内将‘239’从‘int’转换为较窄的类型‘char’  </span><br><span class="line">css/SynonymsDict.cpp:94: 错误：在 &#123;&#125; 内将‘187’从‘int’转换为较窄的类型‘char’  </span><br><span class="line">css/SynonymsDict.cpp:94: 错误：在 &#123;&#125; 内将‘191’从‘int’转换为较窄的类型‘char’  </span><br></pre></td></tr></table></figure><br>可能是编译器的要求太严格导致的，只有更改源码了：<br>将rc/css/SynonymsDict.cpp文件94行的代码<code>char txtHead[3] = {239,187,191};</code>改为如下的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char txtHead[3] = &#123;&#125;; </span><br><span class="line">txtHead[0] = (char)239;</span><br><span class="line">txtHead[1] = (char)187;</span><br><span class="line">txtHead[2] = (char)191;</span><br></pre></td></tr></table></figure><br>再次运行<code>make &amp;&amp; make install</code>会发现又出现了错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">mmseg_main.cpp: In function ‘int segment(const char*, css::Segmenter*)’:</span><br><span class="line">mmseg_main.cpp:254: 错误：在 &#123;&#125; 内将‘239’从‘int’转换为较窄的类型‘char’</span><br><span class="line">mmseg_main.cpp:254: 错误：在 &#123;&#125; 内将‘187’从‘int’转换为较窄的类型‘char’</span><br><span class="line">mmseg_main.cpp:254: 错误：在 &#123;&#125; 内将‘191’从‘int’转换为较窄的类型‘char’</span><br></pre></td></tr></table></figure><br>同样的办法修改<code>src/mmseg_main.cpp</code>文件的254行<code>char txtHead[3] = {239,187,191};</code>为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char txtHead[3] = &#123;&#125;; </span><br><span class="line">txtHead[0] = (char)239;</span><br><span class="line">txtHead[1] = (char)187;</span><br><span class="line">txtHead[2] = (char)191;</span><br></pre></td></tr></table></figure><br>再次运行<code>make &amp;&amp; make install</code>，终于成功了～<br>到这里mmseg就算安装成功了</p>
<h2 id="安装coreseek"><a href="#安装coreseek" class="headerlink" title="安装coreseek"></a>安装coreseek</h2><ul>
<li><code>cd csft-4.1/</code></li>
<li><code>sh buildconf.sh</code></li>
<li><code>./configure --prefix=/usr/local/coreseek  --without-unixodbc   
--with-mmseg --with-mmseg-includes=/usr/local/mmseg3/include/mmseg/   
--with-mmseg-libs=/usr/local/mmseg3/lib/ --with-mysql</code></li>
<li><code>make &amp;&amp; make install</code></li>
</ul>
<h2 id="测试mmseg分词，coreseek搜索（需要预先设置好字符集为zh-CN-UTF-8，确保正确显示中文）"><a href="#测试mmseg分词，coreseek搜索（需要预先设置好字符集为zh-CN-UTF-8，确保正确显示中文）" class="headerlink" title="测试mmseg分词，coreseek搜索（需要预先设置好字符集为zh_CN.UTF-8，确保正确显示中文）"></a>测试mmseg分词，coreseek搜索（需要预先设置好字符集为zh_CN.UTF-8，确保正确显示中文）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd testpack</span><br><span class="line">$ cat var/test/test.xml    #此时应该正确显示中文</span><br><span class="line">$ /usr/local/mmseg3/bin/mmseg -d /usr/local/mmseg3/etc var/test/test.xml</span><br><span class="line">$ /usr/local/coreseek/bin/indexer -c etc/csft.conf --all</span><br><span class="line">$ /usr/local/coreseek/bin/search -c etc/csft.conf 网络搜索</span><br></pre></td></tr></table></figure>
<p>上面是官方文档给的，需要说明的是，csft.conf是由sphinx.conf.dist复制而来的，里面的关于mysql的配置，自己按照实际情况修改。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/05/10/stdarg-function/"><span>C语言：可变参数函数</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/05/10/stdarg-function/" rel="bookmark">
        <time class="entry-date published" datetime="2014-05-09T16:00:00.000Z">
          2014-05-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>函数一般的参数都是固定的，但是有些时候我们需要让函数的参数是可变的，为了满足这个需求，C语言提供了库函数stdarg.h来满足要求。</p>
</blockquote>
<h2 id="可变参数参数简介"><a href="#可变参数参数简介" class="headerlink" title="可变参数参数简介"></a>可变参数参数简介</h2><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>可变参数函数的使用要求比较严谨，必须按照下面的方法进行使用：</p>
<ol>
<li>在函数原型中使用省略号。</li>
<li>在函数定义中创建一个va_list类型的变量。</li>
<li>用宏将改变量初始化为一个参数列表。</li>
<li>用宏访问这个参数列表。</li>
<li>用宏完成清理工作。</li>
</ol>
<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f1(int n, ...); //合法</span><br><span class="line">int f2(int n, const char *s, ...);  //合法</span><br><span class="line">char f3(char c1, ..., char c2); //无效，省略号必须是最后一个参量</span><br><span class="line">doubel f3(); //无效，没有任何参量</span><br></pre></td></tr></table></figure>
<h2 id="程序举例"><a href="#程序举例" class="headerlink" title="程序举例"></a>程序举例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">double sum(int , ...);</span><br><span class="line">void printSth(int, const char *, ...);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    double s, t;</span><br><span class="line"></span><br><span class="line">    s = sum(3, 1.1, 2.5, 13.3);</span><br><span class="line">    t = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1);</span><br><span class="line">    u = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1);</span><br><span class="line">    printf(&quot;return value for &quot;</span><br><span class="line">            &quot;sum(3, 1.1, 2.5, 13.3):    %g\n&quot;,s);</span><br><span class="line">    printf(&quot;return value for &quot;</span><br><span class="line">            &quot;sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1)  %g\n&quot;, t); </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">double sum(int lim, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap; //声明用户存放参数的变量</span><br><span class="line">    double tot = 0;</span><br><span class="line">    int i;</span><br><span class="line">    va_start(ap, lim);  //把ap初始化为参数列表</span><br><span class="line">    for(i = 0; i &lt; lim; i++)</span><br><span class="line">        tot += va_arg(ap, double); //访问参数列表中的每一个项目</span><br><span class="line">    va_end(ap); //清理工作</span><br><span class="line">    return tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><ul>
<li>具有可变参数的函数<code>sum</code>的第一个参数是表示一共有多少个不确定的参数，在调用的时候传递。这个参数主要是高数<code>var_arg</code>能够取多少次传递的参数。</li>
<li>函数<a href="http://www.tutorialspoint.com/c_standard_library/c_macro_va_start.htm" target="_blank" rel="noopener"><code>va_start()</code></a>第一个参数是va_list类型的，第二个参数是这个函数确定的参数中最有一个参数，var_start()函数的作用就是把最有一个确定参数后面的所有不确定参数做一个参数列表存储到va_list类型的变量中。</li>
<li>函数<a href="http://www.tutorialspoint.com/c_standard_library/c_macro_va_arg.htm" target="_blank" rel="noopener"><code>va_arg</code></a>的目的是从未知参数列表中取出参数，每次调用取一个，按照参数顺序取。第一个参数是存储参数列表的变量，第二个参数标识要去的参数的类型，类型决定了要从内存栈中读取多少位。</li>
<li>函数<a href="http://www.tutorialspoint.com/c_standard_library/c_macro_va_end.htm" target="_blank" rel="noopener"><code>va_end</code></a>函数主要是做清理工作,主要是释放动态分配的用于存放参数的内存。</li>
</ul>
<h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><p>我在学了《C Primer Plus》这本书之后打算看看redis源码的时候发现redis的源码中，所有的系统log的记录都是通过这中函数来实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void redisLog(int level, const char *fmt, ...) &#123;</span><br><span class="line">    va_list ap;                </span><br><span class="line">    char msg[REDIS_MAX_LOGMSG_LEN]; </span><br><span class="line">    </span><br><span class="line">    if ((level&amp;0xff) &lt; server.verbosity) return;</span><br><span class="line">    </span><br><span class="line">    va_start(ap, fmt);         </span><br><span class="line">    vsnprintf(msg, sizeof(msg), fmt, ap);</span><br><span class="line">    va_end(ap);                </span><br><span class="line">    </span><br><span class="line">    redisLogRaw(level,msg);    </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/C/">C</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/03/22/linux-shell-programe1/"><span>linux shell 编程之语法学习</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/03/22/linux-shell-programe1/" rel="bookmark">
        <time class="entry-date published" datetime="2014-03-21T16:00:00.000Z">
          2014-03-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>shell语法跟一般类C的语法有些相识，但是却有很多独特的地方，如果不能够好好理解这些语法特性，难免在编写shell脚本的过程中会遇到很多令人难以察觉的，头疼的问题。细节决定成败，这篇博客就根据我自己的学习过程做一下总结吧。</p>
</blockquote>
<h2 id="独特的开头"><a href="#独特的开头" class="headerlink" title="独特的开头"></a>独特的开头</h2><p>一般的脚本语言都有一个基本表示自己是何方神圣的开头，比如php语言的<code>&lt;?php</code>, jsp语言的<code>&lt;%jsp</code>。shell也有自己独特的开头。比如<code>#! /bin/bash</code>, 不过跟其他语言表示自己的语言名称不一样，这里的开头表明shell要指明使用那个解释器。因为shell有很多标准，每个标准的解释器对shell的理解是不一样的，所有你写的shell脚本很可能是其他解释器不认识的内容，所以需要指明你自己使用哪个解释器。这里要注意的是如果写了<code>#! /bin/sh</code> 表明使用的是当前系统默认的解释器。</p>
<blockquote>
<p>ps小贴士：</p>
<blockquote>
</blockquote>
<ol>
<li><code>#!</code>一定要写在脚本第一行才能生效， 否则视为注释行, 不起任何作用</li>
<li>这一行是会被执行的，如果写其他命令如<code>#! /bin/more</code> 则会执行相应的命令</li>
</ol>
</blockquote>
<h2 id="执行shell脚本的方法"><a href="#执行shell脚本的方法" class="headerlink" title="执行shell脚本的方法"></a>执行shell脚本的方法</h2><p>shell执行的方式不同，其与运行的远离也不同，参考<a href="http://learn.akae.cn/media/ch31s02.html" target="_blank" rel="noopener">Shell如何执行命令</a>这篇文章，进行介绍一下：<br>首先有一个脚本<code>script.sh</code>,内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ! /bin/sh</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><br>执行这个脚本的方法有两种：</p>
<ul>
<li><code>$ ./script.sh</code></li>
<li><code>$ sh ./script.sh</code></li>
</ul>
<p>但其实第一种方法会转化为第二种方法，比如如果用第一种方法执行脚本，实际上会转化为：<code>/bin/sh ./script.sh</code>。接下来就调用shell子进程来执行脚本了，在脚本执行的所有都是针对子进程的，不会对父进程产生影响，这点可以参考博客中举的例子。</p>
<blockquote>
<p>ps小贴士：</p>
<blockquote>
</blockquote>
<ol>
<li>第一种方式执行脚本需要这个脚本具有可执行的权限, 第二种则不需要</li>
</ol>
</blockquote>
<h2 id="变量的表示"><a href="#变量的表示" class="headerlink" title="变量的表示"></a>变量的表示</h2><p>Bash变量像一般的脚本语言一样，不区分变量类型，本质上Bash变量都是字符串。  </p>
<h3 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h3><p>变量的名字就是变量保存值的地方，引用变量的值就叫<em>变量替换</em>。我们用<code>$+变量名称</code>来表示变量替换。下面几种情况变量不带<code>$</code>:</p>
<ul>
<li>变量被声明: <code>variable</code></li>
<li>变量被赋值: <code>variable=12</code></li>
<li>变量被unset: <code>unset variable</code></li>
<li>变量被export: <code>export variable=23</code></li>
</ul>
<p><em>弱引用（部分引用）：</em>双引号(“”)括起来的变量。这种引用变量替换不会被阻止。<br><em>强引用（全引用）：</em>单引号（’’）括起来的变量。替换被阻止，解释为字符串。</p>
<p>ps: $variable其实是${variable}的简写形式,但是有些时候简写形式不能够满足变量的更多特性（比如参数替换），这时候就要用全写形式了。</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值:"></a>变量赋值:</h3><p>变量赋值的方式也有多种：</p>
<ol>
<li>使用赋值操作:=(注意等号两边不能有空白，否则就是视为条件判断了)赋值.<code>a=12</code></li>
<li>使用let赋值.<code>let a=2</code></li>
<li>for循环中赋值(伪赋值).<code>for a in \</code>seq 100``</li>
</ol>
<h3 id="特殊的变量类型"><a href="#特殊的变量类型" class="headerlink" title="特殊的变量类型"></a>特殊的变量类型</h3><ul>
<li>位置参数： 命令行运行脚本可以传递参数，而脚本接受参数可以通过位置参数来获取。<ul>
<li>$0:代表脚本名称</li>
<li>$1:表示第一个传递的参数(依次类推, 但是$10开始需要需要用${10}来获取)</li>
<li>$#:表示参数的个数</li>
</ul>
</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="条件判断格式："><a href="#条件判断格式：" class="headerlink" title="条件判断格式："></a>条件判断格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#  1 一般的格式</span><br><span class="line">if 条件</span><br><span class="line">then</span><br><span class="line">     ...</span><br><span class="line">else</span><br><span class="line">     ... </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#  2 两条语句写到一行是，语句间要用分号隔开</span><br><span class="line">if 条件; then</span><br><span class="line">    ...</span><br><span class="line">else</span><br><span class="line">    ...</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#  3 多个条件判断</span><br><span class="line">if 条件</span><br><span class="line">then</span><br><span class="line">    ...</span><br><span class="line">elif 条件</span><br><span class="line">    ...</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#  4 嵌套条件判断</span><br><span class="line">if 条件</span><br><span class="line">then</span><br><span class="line">    if 条件</span><br><span class="line">    then</span><br><span class="line">        ...</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="条件格式："><a href="#条件格式：" class="headerlink" title="条件格式："></a>条件格式：</h3><ol>
<li><code>[ ... ]</code> : <code>[</code>是一个内建命令，其作用就是后面的表达式退出状态码为0则条件为真。</li>
<li><code>[[ ... ]]</code>: <code>[[</code>是一个关键字，其作用就是和上面相同，但是其表达式的解释不同。</li>
<li><code>(( ... ))</code>: 测试条件是一个算术表达式，表达式的结果为非零时条件为真。</li>
<li><code>一般命令</code>: 可跟一般的shell命令，命令的退出状态码为测试条件。</li>
</ol>
<blockquote>
<p>ps: <code>[]</code> 与<code>[[]]</code>的区别：<br>    <code>[</code>是一个内建命令, 其后面跟的是一般命令的参数和选项，比如<code>[ 1 -lt 2]</code>可以认为1和2是参数，-lt是一个选项。但是 <code>[ 1 &amp;&amp; 2 ]</code>则不正确，因为 &amp;&amp;不是一个有效的参数或者选项。<br>    <code>[[</code>是一个关键字，可以正确解释&amp;&amp;， 是一个更加通用的结构。</p>
</blockquote>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>循环的方式主要有以下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 1 基本结构</span><br><span class="line">for arg in [list]</span><br><span class="line">do</span><br><span class="line">commands...</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 2 使用$@(即位置参数)</span><br><span class="line">for arg</span><br><span class="line">do</span><br><span class="line">commands...</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 3 使用命令替换[list]</span><br><span class="line">for arg in `command`</span><br><span class="line">do</span><br><span class="line">commands...</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 4 使用C风格</span><br><span class="line">for ((a=1; a &lt;= LIMIT ; a++))</span><br><span class="line">do</span><br><span class="line">commands...</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 5 while</span><br><span class="line">while [condition] #与条件判断的condition一样</span><br><span class="line">do</span><br><span class="line">commands...</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 6 until 类似于C的do...while</span><br><span class="line">until [condition]</span><br><span class="line">do</span><br><span class="line">commands...</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 7 嵌套循环与控制</span><br><span class="line">for a in [list]</span><br><span class="line">do</span><br><span class="line">    for b in [list]</span><br><span class="line">    do</span><br><span class="line">        for c in [list]</span><br><span class="line">        do</span><br><span class="line">            break 2 #带层参数：退出从本层算，往外到第二层的循环</span><br><span class="line">        done</span><br><span class="line">        for d in [list]</span><br><span class="line">        do</span><br><span class="line">           continue #不带层参数：继续本层的循环</span><br><span class="line">        done</span><br><span class="line">        break  #不带层参数：退出本层循环</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># case </span><br><span class="line">case &quot;$variable&quot; in</span><br><span class="line">$condition1 ) command...;;</span><br><span class="line">$condition2 ) command...;;</span><br><span class="line">...</span><br><span class="line">$conditionn ) command...;;</span><br><span class="line">*) command ...;; #相当于default</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># select 介于for和case之间的一个if语句</span><br><span class="line">select variable [in list] #满足条件则执行下面的命令, 不写后面的则跟for一样，取$@</span><br><span class="line">do</span><br><span class="line">commands...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义的两种方式："><a href="#函数定义的两种方式：" class="headerlink" title="函数定义的两种方式："></a>函数定义的两种方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function function_name &#123;</span><br><span class="line">$1 #位置参数作为传递的参数</span><br><span class="line">$2</span><br><span class="line">command...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function_name &#123;</span><br><span class="line">command...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name $arg1 $arg2</span><br></pre></td></tr></table></figure>
<p>ps:</p>
<ol>
<li>函数调用之前必须先定义</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里一个shell的基本架构有了，但是shell学习才刚刚开始，以后陆续有文章就shell的某个点进行深入探讨～</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/SHELL/">SHELL</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/shell/">shell</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/03/22/linux-shell-command-line-control-key/"><span>linux命令行控制字符汇总</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/03/22/linux-shell-command-line-control-key/" rel="bookmark">
        <time class="entry-date published" datetime="2014-03-21T16:00:00.000Z">
          2014-03-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>我们经常在linux终端下输入命令行，就像我们使用vi等编辑器一样频繁，vi有很多快捷键提高我们的输入效率，命令行下有没有一些快捷键也能提高我们的输入效率呢？当然有～，下面就介绍一下这些快捷键，掌握了这些就可以让你在命令行下输入命令的效率有质的飞跃了～</p>
</blockquote>
<h2 id="linux命令行字符功能汇总"><a href="#linux命令行字符功能汇总" class="headerlink" title="linux命令行字符功能汇总"></a>linux命令行字符功能汇总</h2><table>
<thead>
<tr>
<th>命令</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ctl-A</td>
<td>回行首</td>
<td>使光标回到一行的行首</td>
</tr>
<tr>
<td>ctl-B</td>
<td>退格(非破坏性的)</td>
<td>向前移动光标</td>
</tr>
<tr>
<td>ctl-C</td>
<td>break</td>
<td>终止当前运行前台程序</td>
</tr>
<tr>
<td>ctl-D</td>
<td>删除字符/退出</td>
<td>删除光标所在的字符, 当无字符可删除时相当于logout</td>
</tr>
<tr>
<td>ctl-F</td>
<td>前行</td>
<td>光标向前移动</td>
</tr>
<tr>
<td>ctl-G</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ctl-H</td>
<td>退格(破坏性的)</td>
<td>向前移动光标的同时删除字符</td>
</tr>
<tr>
<td>ctl-I</td>
<td>水平制表</td>
<td>相当于tab键</td>
</tr>
<tr>
<td>ctl-J</td>
<td>重起一行</td>
<td>相当于回车键</td>
</tr>
<tr>
<td>ctl-K</td>
<td>垂直制表</td>
<td>删除光标所在处到行尾的所有字符</td>
</tr>
<tr>
<td>ctl-L</td>
<td>清屏</td>
<td>相当于clear命令</td>
</tr>
<tr>
<td>ctl-M</td>
<td>回车</td>
<td>相当于回车键</td>
</tr>
<tr>
<td>ctl-N</td>
<td>向下查找命令</td>
<td>对于输入过的命令，<br> 可以通过这个命令向下查找输入过的命令</td>
</tr>
<tr>
<td>ctl-O</td>
<td>回车</td>
<td>相当于回车键</td>
</tr>
<tr>
<td>ctl-P</td>
<td>向上查找命令</td>
<td>对于输入过的命令，<br> 可以通过这个命令向上查找输入过的命令</td>
</tr>
<tr>
<td>ctl-Q</td>
<td>恢复</td>
<td>在终端中恢复stdin</td>
</tr>
<tr>
<td>ctl-R</td>
<td>历史命令查找</td>
<td>输入ctl-R会提示查找历史命令，<br> 然后输入字符，会时时现实匹配到的命令，<br> 按回车就可以执行历史命令</td>
</tr>
<tr>
<td>ctl-S</td>
<td>挂起</td>
<td>在终端中冻结stdin, 于ctl+Q正好相反</td>
</tr>
<tr>
<td>ctl-T</td>
<td>交换</td>
<td>交换光标所在处的字符与光标前面的一个字符的位置</td>
</tr>
<tr>
<td>ctl-U</td>
<td>删除字符到行首</td>
<td>删除光标所在的字符到行首，于ctl+K正好方向相反</td>
</tr>
<tr>
<td>ctl-V</td>
<td>允许插入控制字符</td>
<td>如果想要输入控制字符，需要先输入ctr+V然后在输入控制字符</td>
</tr>
<tr>
<td>ctl-W</td>
<td>删除光标前字符到空格处</td>
<td>删除光标所在的字符到左边的空格处</td>
</tr>
<tr>
<td>ctl-X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ctl-Y</td>
<td>粘贴</td>
<td>把刚刚暂存区的字符粘贴到终端</td>
</tr>
<tr>
<td>ctl-Z</td>
<td>挂起</td>
<td>暂停前台作业</td>
</tr>
</tbody>
</table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/SHELL/">SHELL</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2014/02/13/csapp-chapter5/"><span>csapp chapter5:优化程序性能</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/02/13/csapp-chapter5/" rel="bookmark">
        <time class="entry-date published" datetime="2014-02-12T16:00:00.000Z">
          2014-02-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>编写高效程序需要几类活动：第一，我们必须选择一组合适的算法和数据结构。第二，我们必须编写出编译器能够优化以转化成高效可执行代码的源代码。本章重点讲的是第二个活动，利用我们对编译器的了解来写出让编译器编译出更高效的机器码的方法。</p>
</blockquote>
<h2 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>程序优化的第一步就是消除不必要的内容，让代码尽可能有效地执行它期望的工作。主要包括消除<strong>不必要</strong>的<em>函数调用</em>，<em>条件测试</em>和<em>存储器引用</em>。<br>编译器本身通过复杂精细算法对程序编译时进行了优化。编译器的优化有不同的级别，也是高程度的优化程序的执行效率就越高，但同时也可能增加程序的规模，也可能使标准的调试工具更难对程序进行调试。<br>编译器必须很小心的对程序只是用<em>安全</em>的优化，也就是说对于程序可能遇到的所有可能情况，在C语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。<br>通过一个例子来理解决定一种程序转换是否安全的难度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void twiddle1(int *xp, int *yp)</span><br><span class="line">&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void twiddle1(int *xp, int *yp)</span><br><span class="line">&#123;</span><br><span class="line">    *xp += 2* *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这两个过程似乎有相同的行为。而且twiddle2的效率更高一些，因为twiddle1需要6次存储器引用，而twiddle2只需要三次存储器引用。但是当xp与yp的值相同时，twiddle1中*xp的值时原来的4倍，twiddle2却是3倍。编译器并不知道它们会不会指向同一地址，所以不能进行从twiddle1到twiddle2的优化。<br>这种两个指针可能指向同一存储器位置的情况称为<em>存储器别名使用(memory aliasing)</em>。编译器对这种情况的优化能力是有限的，所以需要写程序的过程中进行优化。  </p>
<h2 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h2><p>引入度量标准<em>每元素的周期数(Cycles Per Element, CPE)</em>,作为一种表示程序性能并指导我们改进代码的方法。<br>处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<em>千兆赫兹(GHz)</em>。就是我们常说的CPU的运行频率。时钟周期就是时钟频率的倒数。</p>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>举例说明程序优化的效果,这里写出最后的运行函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void combine1(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">    long int i;</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    for (i=0; i &lt; vec_length(v); i++)&#123;</span><br><span class="line">        data_t val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>看一下优化钱和优化后的效果，就可以看到，CPE从平均29左右降到了12左右，效果的确很明显啊。</p>
<h2 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h2><p>上面过程在执行for循环的时候调用vec_length函数左右循环测试的条件，也就是说每次执行条件测试的时候都要执行这个函数调用过程，这明显地影响了程序的性能。注意到向量的长度并不会随程序运行发生改变，所以可以考虑只计算一次向量的长度，然后条件测试都用这个值，如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void combine2(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">    long int i;</span><br><span class="line">    long int lenght = vec_length(v);</span><br><span class="line">    *dest = IDENT;</span><br><span class="line"></span><br><span class="line">    for (i=0; i &lt; length; i++)&#123;</span><br><span class="line">        data_t val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>再看修改后的程序，CPE降到了8左右。<br>这个优化是一种常见的优化例子，称为<em>代码移动(code motion)</em>。这类优化包括识别要执行多次但是计算结果不会改变的计算。编译器会试着进行代码移动，但是对于会改变在哪里调用函数或调用多少次的变换，编译器通常都会非常小心。如果vec_length有某种副作用，那么combine1和combine2可能有不同的行为。为了改进代码，程序员必须经常帮助编译器显式地完成代码的移动。</p>
<h2 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h2><p>过程调用会带来相当大的开销，而且妨碍大多数形式的程序优化。<br>上面的combine2中，每次循环迭代都会调用get_vec_element来获取下一个向量元素，很明显会照成低效率。对其进行优化的思路就是减少过程的调用，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data_t *get_vec_start(vec_ptr v)</span><br><span class="line">&#123;</span><br><span class="line">    return v-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void combine3(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">    long int i;</span><br><span class="line">    long int lenght = vec_length(v);</span><br><span class="line">    data_t *data = get_vec_start(v);</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line"></span><br><span class="line">    for (i=0; i &lt; length; i++)&#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>得到的代码运行速度开得多，这是以损害一些程序的模块性为代价的。<br>实际情况是，得到的性能提高出乎意料的普通，这是因为5.11讲到的分支预测策略会预计函数的返回值，预测对的情况下直接执行，预测错误的话会有更多的处罚，如果分支预测策略比较好的话，预测正确的概率就高，所以带来的性能问题就越小。</p>
<h2 id="消除不必要的存储器引用"><a href="#消除不必要的存储器引用" class="headerlink" title="消除不必要的存储器引用"></a>消除不必要的存储器引用</h2><p>combine3过程中for循环对应的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L498:</span><br><span class="line">    movss   (%rbp), %xmm0           #从dest读取数据</span><br><span class="line">    mulss   (%rax, %rdx, 4), %xmm0  #数据相乘</span><br><span class="line">    movss   %xmm0, (%rbp)           #存储结果到dest</span><br><span class="line">    addq    $1, %rdx                #加1</span><br><span class="line">    cmpq    %rdx, %r12              #判断边界条件</span><br><span class="line">    jg      .L498                   # if &gt;, 循环</span><br></pre></td></tr></table></figure><br>上面的代码不断从(%rbp)处读取和操作数据，其实可以去掉这个中间寄存器以消除不必要的读写。可以直接利用%xmm0来保存积值。向下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L488:</span><br><span class="line">    mulss   (%rax, %rdx, 4), %xmm0  #数据相乘</span><br><span class="line">    addq    $1, %rdx                #加1</span><br><span class="line">    cmpq    %rdx, %rbp              #判断边界条件</span><br><span class="line">    jg      .L488                   # if &gt;, 循环</span><br></pre></td></tr></table></figure><br>对应C代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void combine4(vec_ptr v, data_t *dest)</span><br><span class="line">&#123;</span><br><span class="line">    long int i;</span><br><span class="line">    long int lenght = vec_length(v);</span><br><span class="line">    data_t *data = get_vec_start(v);</span><br><span class="line">    data_t acc = IDENT;</span><br><span class="line"></span><br><span class="line">    for (i=0; i &lt; length; i++)&#123;</span><br><span class="line">        acc  = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>编译器不会做出这样的优化还是因为前面提到的<em>存储器别名使用</em>带来的问题。例如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">combine3(v, get_vec_start(v)+2);</span><br><span class="line">combine4(v, get_vec_start(v)+2);</span><br></pre></td></tr></table></figure>
<p>执行这两个函数的时候结果就会出现不一致性。</p>
<h2 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>上面所说的都是从程序的调用角度考虑的，主要是减少不必要的指令执行，但是并没有运用目标机器的任何特性。随着试图进一步提高性能，我们必须考虑利用处理器<em>微体系结构</em>的变化，也就是处理器用来执行指令的底层系统设计。在实际的处理器中，是可以同时对多条指令求值的，这个现象称为<em>指令级并行</em>。现代处理器取得了不起的功绩之一就是：它们采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现一种简单地顺序执行的表象。<br>程序的最大性能在处理器中主要受到下面两个重要因素的影响：</p>
<ul>
<li>当一系列操作必须严格顺序执行时，就会遇到<em>延迟界限(latency bound)</em>。因为在下一条指令开始之前，这条指令必须结束。</li>
<li><em>吞吐量界限(throughput bound)</em>刻画了处理器功能但愿的原始计算能力。这个界限是程序性能的终极限制。</li>
</ul>
<p>下面通过一些例子说明如何利用现代处理器的流水线，指令级并行等特性提高程序性能：</p>
<ul>
<li><p>例子1， 下面代码是对一个数据组求和，根据下面的代码可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//combine 1</span><br><span class="line">for(i = 0; i&lt; limit; i++) </span><br><span class="line">&#123;</span><br><span class="line">    acc = acc * data[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是这段代码对应的在系统中运行的过程：<br><img src="/assets/img/csapp/fig5.13.png" alt><br>下面是过程的简化：<br><img src="/assets/img/csapp/fig5.14.png" alt><br>其中寄存器<code>xmm0</code>是变量<code>acc</code>对应。可见这段代码中，制约性能的瓶颈就是每次都要进行mul运算，更新acc的值，然后进入下一个循环周期。如何提高这样的程序性能呢？这个运算已经是最简洁的了，但是可不可以考虑减少循环的次数来优化呢？请看下面的这段代码.</p>
</li>
<li><p>例子2， 减少循环周期也可以这么做：<br>//combine 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0; i &lt; limit; i+=2) &#123;</span><br><span class="line">    acc = (acc * data[i]) * data[i+1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码看似把循环周期减少了一般，但其实性能并没有得到提高，通过他的计算过程可以看到：<br><img src="/assets/img/csapp/fig5.20.png" alt><br>虽然周期减少了一半，但是每个周期却进行了两次运算，而且每次运算都依赖上次计算的结果，也就是acc的值，所以性能并未得到改善。再看例子3。</p>
</li>
<li><p>例子3， 多变量提高并行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0; i &lt; limit; i+=2) </span><br><span class="line">&#123;</span><br><span class="line">    acc0 = acc0 * data[i];</span><br><span class="line">    acc1 = acc1 * data[i+1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码跟上一段代码的区别是增加了一个变量，也就是增加了对寄存器的使用，其过程如下：<br><img src="/assets/img/csapp/fig5.24.png" alt><br>可以看到同样是减少了周期，但是每个周期的运算使用了不同的计算器，每个计算都不依赖同一周期内的其他值，利用了计算器的并行性，从而提高了程序的性能。还有其它的方式。</p>
</li>
<li><p>例子4, 重新结合变换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0; i &lt; limit; i+=2) &#123;</span><br><span class="line">    acc = acc * (data[i] * data[i+1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码跟例子2很像，只不过改变了运算结合的顺序，程序的性能却得到了很大的提高，这是为什么呢？可以看到这个程序在计算机中计算的过程如下：<br><img src="/assets/img/csapp/fig5.29.png" alt><br>可以看到每个周期也是两个mul操作，为什么会快呢？这是因为第一个mul操作并不依赖寄存器的值，也就是说其实对于data数组之间的运算可以通过流水线并行计算，制约性能的只是acc所在的寄存器的计算，所以性能主要因素还是一个mul的操作。<br>从上面可以看到利用多个寄存器可以提高性能，那是不是利用的越多越好呢？答案是：NO.因为计算机的寄存器个数是有限的，如果需要的寄存器的个超过了寄存器的个数，那就只能把这些值放入到栈中，这样就会急剧降低程序的性能。</p>
</li>
</ul>
<h2 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h2><p>影响程序性能的限制因素有下面几个：</p>
<ul>
<li>寄存器溢出：就是上面最后一段介绍的寄存器不够用时的情况。</li>
<li>分支预测和预测错误处罚：这回提高程序的代价。</li>
<li>其它：如加载的性能，存储的性能等。</li>
</ul>
<h2 id="提高性能的技术"><a href="#提高性能的技术" class="headerlink" title="提高性能的技术"></a>提高性能的技术</h2><ol>
<li>高级设计: 为遇到的问题选择适当的算法和数据结构。</li>
<li>基本编码原则:<ul>
<li>消除连续的函数调用</li>
<li>消除不必要的存储器引用：引入临时变量来保持中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。</li>
</ul>
</li>
<li>低级优化<ul>
<li>展开循环，降低开销，并且使得进一步优化成为可能。</li>
<li>通过使用例如多个累积变量和重新结合技术，找到方法提高指令级并行。</li>
<li>用功能得风格重写条件操作，使得编译采用条件数据传送。</li>
</ul>
</li>
</ol>
<p>(本章完 2014-05-17 22:57:27)</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/CSAPP/">CSAPP</a>
    </span>
    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/3/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/5/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>