<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 2 | oohcode | $\bigodot\bigodot^H \rightarrow CODE$</title>

  
  <meta name="author" content="sean chen">
  

  

  
  <meta name="keywords" content="sean">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="oohcode">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="oohcode" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">oohcode</a>
    </h1>
    <p class="site-description">$\bigodot\bigodot^H \rightarrow CODE$</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/03/the-core-technology-of-high-traffic-website/"><span>亿级流量网站架构核心技术总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/03/the-core-technology-of-high-traffic-website/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-03T05:27:30.000Z">
          2017-08-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近读了《亿级流量网站架构核心技术——跟开涛学搭建高可用高并发系统》这本书，总体感觉这本书很实用，作者根据自己负责的项目经历以及业务的发展过程和业界的理论基础相结合讲解了如何搭建一个具有高并发和高可用特征的电商网站。作者是京东的架构师，进来随着京东业务的不断发展，6.18和双十一活动规模的不断扩大，作者都亲身经历了整个电商网站的发展过程，相对于单纯的理论，这本书更多的是能够在业务中快速应用的经验总结。下面就这两方面我把作者的思维导图搬过来，不断提醒自己要注意的整体思想，并能够深入浅出，根据思维导图的每一项都有一个自己更发散更深入的认识。</p>
</blockquote>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><img src="/assets/img/cthtw/High-availability.png" alt="高可用"></p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="/assets/img/cthtw/High-concurrency.png" alt="高并发"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/java/">java</a><a href="/tags/架构/">架构</a><a href="/tags/高并发/">高并发</a><a href="/tags/高可用/">高可用</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/12/golang-goroutines-1/"><span>golang channels 的串联,扇入扇出及控制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/12/golang-goroutines-1/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-12T02:06:03.000Z">
          2017-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。 一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。 channel之间可以进行串联，并联等组合，组成我们想要的运行方式。 不同goroutine之间需要同步，也需要控制，具体该如何处理这些情况，下面分别进行介绍。</p>
</blockquote>
<h2 id="channel基础"><a href="#channel基础" class="headerlink" title="channel基础"></a>channel基础</h2><p>使用内置的make函数，我们可以创建一个channel:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type 'chan int'</span></span><br></pre></td></tr></table></figure></p>
<p>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。<br>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。<br>一个channel有发送和接受两个主要操作，都是通信行为。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch     <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure></p>
<p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></table></figure></p>
<p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的Channels</h3><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。<br>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前。</p>
<p>对于不带缓存的Channels，我们使用的是有必须放到goroutine,因为如果直接调用<code>chanx &lt;- 1</code>时，会报错<code>fatal error: all goroutines are asleep - deadlock!</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chanx &lt;- <span class="number">1</span> <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p>
<p>由于主goroutine调用了 <code>chanx &lt;-1</code>, 但是由于是顺序往下执行，执行时还不存在监听<code>chanx</code>的方法存在，所以数据放入<code>chanx</code>后无法唤醒接收的方法，只能等待下去，所以就产生了deadlock。<br>可以修改为下面的形式，把<code>chanx &lt;- 1</code>放入到一个goroutine里，然后主goroutine监听了这个<code>chanx</code>，当往<code>chanx</code>放数据的时候就会有接收的方法被调用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;chanx &lt;- <span class="number">1</span>&#125;() <span class="comment">//right</span></span><br><span class="line">    &lt;-chanx</span><br></pre></td></tr></table></figure></p>
<p><strong>当使用<code>range</code>遍历<code>chan</code>时别忘了close</strong>, 下面当没有使用close时:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>output:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive]:</span><br></pre></td></tr></table></figure></p>
<p><code>range</code>会从<code>channel</code>中接收数据直到<code>channel</code>被<code>close</code>为止，正常情况下<code>close</code>并不是必须的，只有在接收者需要知道没有更多的数据进入的时候才需要，而<code>range</code>正是需要知道这个信息的。所以代码改成下面这样就没问题了:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanx := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            chanx &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(chanx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> chanx &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="带缓存的Channels"><a href="#带缓存的Channels" class="headerlink" title="带缓存的Channels"></a>带缓存的Channels</h3><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p>
<p><strong>队列元素为1的带缓存Channels与不带缓存的Channels是不同的</strong>，下面的例子可以看出:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan_nobuffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan_nobuffer &lt;- <span class="number">1</span> <span class="comment">//error 必须放到goroutine中</span></span><br><span class="line">    &lt;-chan_nobuffer</span><br><span class="line"></span><br><span class="line">    chan_buffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    chan_buffer &lt;- <span class="number">1</span> <span class="comment">//right</span></span><br><span class="line">    &lt;-chan_buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单方向的Channel"><a href="#单方向的Channel" class="headerlink" title="单方向的Channel"></a>单方向的Channel</h3><p>channel还有两种语法:<code>&lt;-chan int</code>和<code>chan&lt;- int</code>，其意思是单方向的channel, 当定义为<code>out chan&lt;- int</code>表示<code>out</code>只能被往里面放数据，不允许从out拿数据,否则程序会报错<code>receive from send-only type chan&lt;- int</code>,如果定义为<code>in &lt;-chan int</code>则<code>in</code>只能往外输出数据，不允许往<code>in</code>里面放数据，否则报错<code>send to receive-only type &lt;-chan int</code></p>
<h2 id="channel串联"><a href="#channel串联" class="headerlink" title="channel串联"></a>channel串联</h2><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。 这种串联的Channels就是所谓的管道（pipeline）。下图就是一个串联的channel示意:<br><img src="/assets/img/golang/goroutines_0712_1.png" alt="串联channel"><br>第一个goroutine Counter负责生成一个0,1,2,3,…形式的整数序列,然后把整数序列输入到一个channel中，通过这个channel传递个下一个goroutine Squarer, 负责将从channel接收到的数求平方，然后再把得出的结果通过channel传递给goroutine Printer, Printer负责将从channel接收的数据打印出来。<br>其程序实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> Counter(chan1)</span><br><span class="line">    <span class="keyword">go</span> Squarer(chan2, chan1)</span><br><span class="line">    Printer(chan2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中我们创建了两个chan, 然后调用了<code>Counter</code>和<code>Squarer</code>, 由于上面说:<strong>当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。</strong>所以我们对chan1和chan2的修改都是全局的。<br><code>Counter</code>往chan1中陆续放入了<code>0,1,2,3,...</code>等数列，然后同步的<code>Squarer</code>接收到数据对其平方并放入<code>chan2</code>,最后<code>Printer</code>从<code>chan2</code>中输出这些数据。<br>对于串联的Channel还有另外一种实现方法:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    out := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> out &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            out &lt;- n*n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>gen</code>函数用到了golang的<strong>可变参数</strong>这个特性，跟上面的<code>Counter</code>不一样的是，这个<code>gen</code>会把<code>chan</code>当做返回值返回，而不是作为参数传入。<code>sq</code>函数也跟<code>Squarer</code>函数不一样了:把上一个函数的chan最为参数，下一个输出的chan作为返回值。</p>
<h2 id="channel扇入扇出"><a href="#channel扇入扇出" class="headerlink" title="channel扇入扇出"></a>channel扇入扇出</h2><p><strong>扇出</strong>：同一个 channel 可以被多个函数读取数据，直到channel关闭。 这种机制允许将工作负载分发到一组worker，以便更好地并行使用 CPU 和 I/O。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    c1 := sq(c)</span><br><span class="line">    c2 := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c1 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"-------------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> c2 &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是几种输出样式，可以知道当调用两次<code>sq</code>时，其实是对chan的扇出操作，既一个channel被多个函数读取了。每次读取的顺序和个数都不能保证。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span> </span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">9</span></span><br><span class="line">#<span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">------------------</span><br><span class="line">#<span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong>扇入</strong>：多个 channel 的数据可以被同一个函数读取和处理，然后合并到一个 channel，直到所有 channel都关闭。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed, then calls wg.Done.</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            out &lt;- n <span class="comment">//对于每个chan其中的元素都放到out中 </span></span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done() <span class="comment">//减少一个goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs)) <span class="comment">//要执行的goroutine个数</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        <span class="keyword">go</span> output(c) <span class="comment">//对传入的多个channel执行output</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a goroutine to close out once all the output goroutines are</span></span><br><span class="line">    <span class="comment">// done.  This must start after the wg.Add call.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait() <span class="comment">//等待，直到所有goroutine都完成后</span></span><br><span class="line">        <span class="built_in">close</span>(out) <span class="comment">//所有的都放到out后关闭</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>merge</code>函数的参数也是变长的，类型是<code>chan</code>, 这个函数还用到了<code>sync</code>这个包，这里主要的作用就是对一组goroutines进行同步。首先把传入的cs都通过<code>output</code>调用放入<code>out</code>中，每处理完一个<code>c</code>就调用<code>wg.Done()</code>更新剩余的次数, <code>wg.Wait()</code>等到所有的channels把数据放到<code>out</code>中，然后关闭<code>out</code>。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := gen(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    out2 := sq(c)</span><br><span class="line">    out1 := sq(c)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> merge(out1, out2) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图就展示了扇入扇出的过程:<br><img src="/assets/img/golang/goroutines_0712_2.png" alt="串联channel"></p>
<h2 id="goroutines控制"><a href="#goroutines控制" class="headerlink" title="goroutines控制"></a>goroutines控制</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">The Go Blog - pipelines</a></li>
<li><a href="https://segmentfault.com/a/1190000006261218" target="_blank" rel="noopener">Go语言并发模型：像Unix Pipe那样使用channel</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-04.html" target="_blank" rel="noopener">Go语言圣经-channels</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch8/ch8-05.html" target="_blank" rel="noopener">Go语言圣经-并发的循环</a></li>
<li><a href="https://docs.hacknode.org/gopl-zh/ch5/ch5-07.html" target="_blank" rel="noopener">Go语言圣经-可变参数</a></li>
<li><a href="https://deepzz.com/post/golang-context-package-notes.html" target="_blank" rel="noopener">快速掌握 Golang context 包</a></li>
<li><a href="https://tour.golang.org/concurrency/4" target="_blank" rel="noopener">A Tour of Go - Range and Close</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goroutines/">goroutines</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/01/how-golang-webserver-work/"><span>golang的webserver是如何工作的</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/01/how-golang-webserver-work/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-01T01:29:38.000Z">
          2017-07-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>我们知道golang实现一个webserver非常简单，但是其内部是如何工作的呢，我们深入探究一下其原理。</p>
</blockquote>
<h2 id="实现一个webserver服务"><a href="#实现一个webserver服务" class="headerlink" title="实现一个webserver服务"></a>实现一个webserver服务</h2><p>下面我们就用golang内置的服务实现一个简单的webserver:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        r.ParseForm()       <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">        fmt.Println(r.Form) <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">        fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">        fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">        fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">                fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">                fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        http.HandleFunc(<span class="string">"/hello"</span>, sayhelloName)       <span class="comment">//设置访问的路由</span></span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过<code>go run main.go</code>来开启Server服务, 当我们访问<code>http://localhost:8090/</code>或<code>http://localhost:8090/hello</code>都会得到<code>Hello astaxie!</code>, 也就是都执行了<code>sayhelloName</code>函数。<br>下面让我们来分析一下服务的代码:<br>首先我们从<code>main</code>函数入口进入程序执行，首先执行了<code>http.HandleFunc(&quot;/&quot;, sayhelloName)</code>和<code>http.HandleFunc(&quot;/hello&quot;, sayhelloName)</code>两个方法，这两个方法其实就是设置路由及其对应的处理函数。<br>然后执行<code>http.ListenAndServe(&quot;:8090&quot;, nil)</code>这个函数开始监听8090端口并把用户的请求根据之前设置的路由规则交给特定的函数进行处理。<br>下面我将针对这两个函数进行深入的分析。</p>
<h2 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a>http.HandleFunc</h2><p>这个函数是<code>net/http</code>包中定义的, 第一个参数<code>pattern</code>是<code>string</code>类型，表示匹配的URL, 第二个参数<code>handler</code>这是个函数类型，表示一个处理函数。其定义在<code>net/http/server.go</code>中，第一如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数调用了下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HandelrFunc</code>定义如下, 声明为一个函数类型, <code>HandlerFunc(handler)</code>就是把<code>handler</code>强制类型转化为<code>HandlerFunc</code>类型<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>mux.Handle</code>的定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    &#125;</span><br><span class="line">    mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helpful behavior:</span></span><br><span class="line">    <span class="comment">// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span></span><br><span class="line">    <span class="comment">// It can be overridden by an explicit registration.</span></span><br><span class="line">    n := <span class="built_in">len</span>(pattern)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line">        <span class="comment">// If pattern contains a host name, strip it and use remaining</span></span><br><span class="line">        <span class="comment">// path for redirect.</span></span><br><span class="line">        path := pattern</span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line">            <span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">            path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">        &#125;</span><br><span class="line">        url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">        mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出这个函数会把<code>pattern</code>和<code>handler</code>的对应关系读存储到<code>mux.m</code>这个map里了，<code>mux</code>类型是<code>ServeMux</code>,其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">    hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过上面的处理后通过<code>http.HandleFunc</code>设置的<code>pattern</code>与<code>handler</code>的对应关系都被存储到了<code>DefaultServeMux</code>这个对象的<code>m</code>中。</p>
<h2 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a>http.ListenAndServe</h2><p>这个函数也是在<code>net/http/server.go</code>中定义的，其定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面函数最终对调用到下面这个函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn(srv, l)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srv.trackListener(l, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">defer</span> srv.trackListener(l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过一个for循环不停的接收请求<code>l.Accept()</code>来得到接收的请求，然后再通过<code>go c.serve(ctx)</code>进行请求的处理。这里用到了协程，也就是每个请求其实是由单独的协程进行处理的，这也是golang作为webserver高效的原因所在。<code>c.serve</code>函数中有一个<code>for</code>循环，会不断读取同一个请求的数据，直到出现问题或者正确读取完毕。读取完请求后会调用<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>这个函数来处理请求。这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    handler := sh.srv.Handler</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="当-handler-为-nil"><a href="#当-handler-为-nil" class="headerlink" title="当 handler 为 nil:"></a>当 handler 为 nil:</h3><p>可以看到当我们不在<code>ListenAndServe</code>中传递<code>handler</code>时，也就是<code>sh.srv.Handler = nil</code>时<code>hanlder=DefaultServeMux</code>，这个 <code>DefaultServeMux</code>正式我们前面通过<code>http.HandleFunc</code>来设置的。 下面调用了<code>hanlder.ServeHTTP</code>，这里也就是调用了<code>DefaultServeMux.ServeHTTP</code>, 这个函数定义如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数中的<code>mux.Handler</code>从请求<code>r</code>中找到请求的URL然后在去<code>mux.m</code>的map结构中找到对应的映射关系从而得出<code>h</code>这个处理函数名。<br>由于上面说过<code>h</code>是转换为类型<code>HandlerFunc</code>, 这个类型定义的<code>ServeHTTP</code>函数如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以调用<code>h.ServeHTTP(w,r)</code>就等于调用<code>h(w,r)</code>，也就是我们调用我们自己的写的处理函数。<br>这些都完成后会执行收尾工作，并把得到的结构返回给请求用户。</p>
<h3 id="当-handler-不为-nil"><a href="#当-handler-不为-nil" class="headerlink" title="当 handler 不为 nil:"></a>当 handler 不为 nil:</h3><p>这时调用<code>h.ServerHTTP(w,r)</code>其实就是调用自己传入的<code>handler</code>的<code>ServerHTTP</code>函数，例如web框架<code>revel</code>的源码<code>github.com/revel/cmd/harness/harness.go</code>中执行<code>revel run app</code>是就会执行下面的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the harness, which listens for requests and proxies them to the app</span></span><br><span class="line"><span class="comment">// server, which it runs and rebuilds as necessary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> paths []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> revel.Config.BoolDefault(<span class="string">"watch.gopath"</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">        gopaths := filepath.SplitList(build.Default.GOPATH)</span><br><span class="line">        paths = <span class="built_in">append</span>(paths, gopaths...)</span><br><span class="line">    &#125;</span><br><span class="line">    paths = <span class="built_in">append</span>(paths, revel.CodePaths...)</span><br><span class="line">    watcher = revel.NewWatcher()</span><br><span class="line">    watcher.Listen(h, paths...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        addr := fmt.Sprintf(<span class="string">"%s:%d"</span>, revel.HTTPAddr, revel.HTTPPort)</span><br><span class="line">        revel.INFO.Printf(<span class="string">"Listening on %s"</span>, addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        <span class="keyword">if</span> revel.HTTPSsl &#123;</span><br><span class="line">            err = http.ListenAndServeTLS(</span><br><span class="line">                addr,</span><br><span class="line">                revel.HTTPSslCert,</span><br><span class="line">                revel.HTTPSslKey,</span><br><span class="line">                h)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = http.ListenAndServe(addr, h)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            revel.ERROR.Fatalln(<span class="string">"Failed to start reverse proxy:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kill the app on signal.</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(ch, os.Interrupt, os.Kill)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    <span class="keyword">if</span> h.app != <span class="literal">nil</span> &#123;</span><br><span class="line">        h.app.Kill()</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这里也调用了`</span>http.ListenAndServe<span class="string">`但是第二个参数`</span>hanlder<span class="string">`传入了`</span>h<span class="string">`，所以最终会调用`</span>h.ServerHTTP<span class="string">`函数, 这个函数`</span>revel<span class="string">`中是这么实现的:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="comment">// ServeHTTP handles all requests.</span></span><br><span class="line"><span class="comment">// It checks for changes to app, rebuilds if necessary, and forwards the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Harness)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Reverse proxy the request.</span></span><br><span class="line">    <span class="comment">// (Need special code for websockets, courtesy of bradfitz)</span></span><br><span class="line">    <span class="keyword">if</span> strings.EqualFold(r.Header.Get(<span class="string">"Upgrade"</span>), <span class="string">"websocket"</span>) &#123;</span><br><span class="line">        proxyWebsocket(w, r, h.serverHost)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h.proxy.ServeHTTP(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/11/The-Design-and-Implementation-of-Redis-4/"><span>Redis设计与实现总结——独立功能的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/11/The-Design-and-Implementation-of-Redis-4/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-11T02:16:04.000Z">
          2017-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>通过执行<code>SUBSCRIBE</code>命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者(subscriber):每当其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息。<br>除了订阅频道之外，客户端还可以通过执行<code>PSUBSCRIBE</code>命令订阅一个或多个模式，从而成为这些模式的订阅者:每当有其他客户端祥某个频道发送消息时，消息不仅会被发送给这个频道所有订阅者，它还会被发送给所有与这个频道匹配的模式的订阅者。<br>Redis将所有频道的订阅管系都保存在服务器状态的<code>pubsub_channels</code>字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。每当执行订阅命令时服务器都会将客户端与被订阅的频道着<code>pubsub_channels</code>字典中进行关联。如果执行退订命令，那么就会从<code>pubsub_channels</code>中删除这个客户端。<br>模式的订阅则是保存在服务器<code>pubsub_patterns</code>这个属性中，其操作过程与上面相同。<br>发送消息是就会遍历频道的<code>pubsub_channels</code>和<code>pubsub_patterns</code>的客户端，将消息发送给订阅了这些频道和模式的客户端。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过<code>MULTI</code>,<code>EXEC</code>,<code>WATCH</code>等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性，按顺序地执行多个命令的机制，并且在事务执行期间(<strong>当接收到EXEC命令后才开始真正执行, 之前只是命令输入</strong>)，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。<br><code>MULTI</code>命令标识事务的开始，除了<code>EXEC</code>,<code>DISCARD</code>,<code>WATCH</code>,<code>MULTI</code>四个命令外的其他命令都会进入事务的队列中，当接收到<code>EXEC</code>命令时开始执行事务队列中的命令。<br><code>WATCH</code>命令是一个乐观锁(optimistic locking), 它可以在<code>EXEC</code>命令执行之前，监视任意数量的数据库键,并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的回复。 (注意<code>WATCH</code>命令执行的顺序是在<code>MULTI</code>之前)。<br><code>WATCH</code>命令执行的过程是:</p>
<ol>
<li>将监控的键保存到<code>watched_keys</code>字典中，字典的值是所有监视相应数据库键的客户端。</li>
<li>所有对数据库进行修改的命令都会对<code>watched_keys</code>进行检查，如果键被修改了，就会把客户端的<code>REDIS_DIRTY_CAS</code>标识打开。</li>
<li>当接收到<code>EXEC</code>执行命令时，如果判断客户端的<code>REDIS_DIRTY_CAS</code>被打开了，标识客户端提交的事务已经不再安全，服务器拒绝客户端提交的事务。 </li>
</ol>
<p>事务的ACID性质: Redis中，事务总是具有原子性(Atomicity), 一致性(Consistency)和隔离性(Isolation)，并且当Redis运行在某种特定持久化模式下时，事务也具有耐久性(Durability)</p>
<ul>
<li>事务的原子性指的是，数据库将事务中的多个操作当做一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。但是Redis的事务和传统的关系型数据库事务的最大区别在于,<strong>Redis不支持事务回滚机制(rollback)</strong>,即事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，知道将事务队列中的所有命令都执行完毕为止。</li>
<li>事务具有一致性指的是，如果数据库在执行事务之前一致的，那么事务在执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。<strong>一致</strong>指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。</li>
<li>事务的隔离性指的是，即时数据库中有多个事务并发地执行，各个事务之间也不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。因为Redis是使用单线程的方式执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此,Redis中的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</li>
<li>事务的耐久性指的是,当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质里面了，即使服务器在事务执行完毕后停机，，执行事务所得的结果也不会丢失。Redis有<code>RDB</code>和<code>AOF</code>两种持久化方案，但是要持久化方案要和性能进行兼顾。</li>
</ul>
<h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本,直接在服务器端原子地执行多个Redis命令。使用<code>EVAL</code>命令可以直接对输入的脚本进行求值，而<code>EVALSHA</code>命令则可以根据脚本的SHA1校验和来对脚本进行求值。<br>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境，并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成:</p>
<ol>
<li>创建一个基础的 Lua环境(通过调用<code>lua_open</code>函数)</li>
<li>载入函数库(基础库,表格库,字符串库等), 让Lua脚本可以使用这些函数库来进行数据操作。</li>
<li>创建全局表格Redis,这个表格包含了对Redis进行操作的函数，比如用于在 Lua脚本中执行Redis命令的redis.call函数</li>
<li>使用Redis自制的随机函数来替换Lua原有的代有副作用的随机函数,从而避免在脚本中引入副作用。(关于副作用，纯函数的概念参考:<a href="https://zh.wikipedia.org/zh-hk/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">wiki</a></li>
<li>创建排序辅助函数，Lua环境使用这个辅助函数来对一部分Redis命令的结果(比如集合)进行排序,从而消除这些命令的不确定性。</li>
<li>创建<code>redis.pcall</code>函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</li>
<li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本过程中，将额外的全局变量添加到Lua环境中。</li>
<li>将完成修改的Lua环境保存到服务器状态的Lua属性中，等待执行服务器传来的Lua脚本。</li>
</ol>
<p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与 Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的<code>lua_scripts</code>字典。</p>
<ul>
<li>伪客户端: 执行Redis命令必须有响应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。下图是Lua脚本执行Redis命令时的通信步骤:<br><img src="/assets/img/redis/redis_lua.png" alt="redis_lua命令执行步骤"></li>
<li><code>lua_scirpts</code>字典: 这个字典的键为某个Lua脚本的SHA1校验和，而字典的值则是SHA1校验和对应的Lua脚本。<br><code>EVAL</code>命令的执行过程可以分为以下三个步骤:</li>
</ul>
<ol>
<li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。</li>
<li>将客户端给定的脚本保存到<code>lua_scripts</code>字典中,等待将来进一步使用。</li>
<li>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</li>
</ol>
<p>Redis还有四个有关Lua脚本的命令:<code>SCRIPT FLUSH</code>, <code>SCRIPT EXISTS</code>, <code>SCRIPT LOAD</code>和<code>SCRIPT KILL</code>命令。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Redis的<code>SORT</code>命令可以对列表建，集合键或者有序集合键的值进行排序。<br>SORT命令的实现原理是(以<code>SORT numbers</code>为例):</p>
<ol>
<li>创建一个和要排序的对象numbers长度相同的数组，该数组的每个项都是一个<code>redis.h/redisSortObject</code>结构。</li>
<li>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间一对一关系</li>
<li>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面</li>
<li>根据数组项u.score属性的值，对数组进行数字值排序(快速排序算法)，排序后的数组项按u.score属性的值从小到大排列</li>
<li>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端。</li>
</ol>
<p>其他的排序方式，比如按照字母顺序排列，降序排列，通过外部键进行排序等原理都差不多，变化的是排列的顺序，排列的依据<code>u.score</code>不一样。<br>更多<code>SORT</code>命令的具体使用和参数可以参考文档:<a href="http://redisdoc.com/key/sort.html" target="_blank" rel="noopener">Redis SORT命令</a></p>
<h2 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h2><p>Redis提供了<code>SETBIT</code>,<code>GETBIT</code>, <code>BITCOUNT</code>, <code>BITOP</code>四个命令用于处理二进制位数组(bit array, 又称为”位数组”)<br>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。<br>具体使用方法参考官方文档。</p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。<br>服务器有两个和慢查询有关的选项:</p>
<ul>
<li><code>slowlog-log-slower-than</code>选项执行执行时间超过多少微秒的命令请求会被记录到日志上。(可以通过<code>CONFIG SET slowlog-log-slower-than N</code>设置)</li>
<li><code>slowlog-max-len</code>选项执行服务器最多保存多少条慢查询日志。(可以通过<code>CONFIG SET slowlog-max-len N</code>设置)</li>
</ul>
<p>使用<code>SLOWLOG GET</code>命令可以查看服务器所保存的慢查询日志, 使用<code>SLOWLOG LEN</code>可以查看当前日志的数量。</p>
<h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>通过执行<code>MONITOR</code>命令，客户端可以将自己变为一个监视器，实时地接收并打印服务器当前处理的命令请求的相关信息。当一个客户端使用<code>MONITOR</code>向服务器发送命令时，这个客户端的<code>REDIS_MONITOR</code>标识会被打开，并且客户端本身会被服务器添加到<code>monitors</code>链表的表尾。当服务器每次接收到请求时(处理命令之前), 都会调用<code>replicationFeedMonitors</code>函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/06/The-Design-and-Implementation-of-Redis-3/"><span>Redis设计与实现总结——多机数据库的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/06/The-Design-and-Implementation-of-Redis-3/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-06T11:19:41.000Z">
          2017-03-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在Redis中用户可以通过执行<code>SLAVEOF</code>命令或者设置<code>slaveof</code>选项，让一个服务器去复制(repliacte)另一个服务器，被复制的服务器称为主服务器(master),而对服务器进行复制的服务器被称为从服务器(salve)。<br>复制功能分为同步(sync)和命令传播(command propagate)两个操作:</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。(从服务器主动向主服务器请求数据)</li>
<li>命令传播操作用于在主服务器的数据库状态被修改，导致主从服务器数据库状态出现不一致时，让主服务器的数据库重新回到一致状态。</li>
</ul>
<p><img src="/assets/img/redis/redis_sync.png" alt="redis旧版复制"></p>
<ul>
<li>同步过程:<ul>
<li>主服务器接收到从服务器发来的SYNC命令,执行BGSAVE命令,创建RDB文件,并使用缓冲区记录接下来执行的所有写命令。</li>
<li>从服务器接收并载入主服务器发来的RDB文件。</li>
<li>主服务器接着发送缓冲区的写命令到从服务器。</li>
<li>从服务器接收命令。</li>
</ul>
</li>
<li>命令传播:<br>  每当主服务器执行写命令时，主服务器的数据库状态就可能被修改，并导致主从服务器不一致。为了再次回到一致状态，主服务器需要对从服务器执行命令传播操作: 主服务器会将自己执行的写命令发送给从服务器执行，当从服务器执行了相同的写命令后，主从服务器再次回到一致状态。</li>
</ul>
<p>从服务器初次复制主服务器或者从服务器当前要复制的主服务器和上一次不一样时，RDB文件会完整的传输。在处于命令传播阶段的主从服务器因为网络原因而中断了复制，再次连接上时会重头开始复制。但是第二种情况的效率非常低，很多已经复制过的数据需要再次进行复制。这就是旧版复制功能的缺陷。<br>新版复制功能为了解决重复复制的问题，提出了一个<code>PSYNC</code>命令代替之前的<code>SYNC</code>命令。完整的复制与上面的第一种情况初次复制是一样的，部分重同步则用于处理断线后的情况: 断线再连接后，主服务器只发送断线期间的写命令到从服务器。<br>部分重同步的实现是通过<code>复制偏移量</code>:</p>
<ul>
<li>主服务器每次向从服务器转播N个字节的数据时，就将自己的复制偏移量的值+N</li>
<li>从服务器每次收到主服务器传播来的N个字节数据时，就将自己的复制偏移量的值+N</li>
</ul>
<p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态:</p>
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>
<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li>
</ul>
<p>复制积压缓冲区是一个由主服务器维护的固定长度，先进先出队列，默认大小为1MB。当主从断开连接，再次连接时,从服务器会通过<code>PSYNC</code>将自己的复制偏移量<code>offset</code>发送给主服务器:</p>
<ul>
<li>如果<code>offset</code>偏移量之后的数据存在于复制积压缓冲区，那么主服务器将对从服务器执行部分重同步操作。</li>
<li>如果<code>offset</code>偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器会对从服务器执行完整重同步操作。</li>
</ul>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率，祥主服务器发送命令<code>REPLICONF ACK &lt;replication_offset&gt;</code>, 其中<code>replication_offset</code>是当前从服务器的复制偏移量, 这个<code>心跳检测</code>的作用如下:</p>
<ul>
<li><strong>检测主从服务器的网络状态</strong>:如果主服务器超过一秒钟没收到从服务器发送的<code>REPLICONF ACK</code>命令，那么主服务器就知道主从服务器之间的连接出现问题了。</li>
<li><strong>辅助实现min-slaves选项</strong>:Redis的<code>min-slaves-to-write</code>和<code>min-slaves-max-log</code>两个选项可以防止主服务器在不安全的情况下执行写命令。</li>
<li><strong>检测命令丢失</strong>:如果因为网络故障，主服务器传播给从服务器的写命令半路丢失，那么从服务器发送的偏移量就会小于主服务器的偏移量，这时候主服务器会从复制积压缓冲区中重新把命令发送给从服务器。(2.8版本之前没有这个功能，所以会出现丢失的情况)</li>
</ul>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel(哨岗，哨兵)是Redsi的高可用性(high availability)解决方案:由一个或多个Sentinel实例(instance)组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。另外Sentinel还会继续监视已下线的服务器，并在它重新上时，将它设置为新的主服务器的从服务器(降级)。<br>启动Sentinel可以使用命令: <code>redis-sentinel /path/to/your/sentinel.conf</code> 或 <code>redis-server /path/to/your/sentinel.conf --sentinel</code>, 启动时需要执行一下步骤:</p>
<ul>
<li>初始化服务器: Sentinel本质上是一个运行在特殊模式下的Redis服务器，启动初始换与原来有所不同。</li>
<li>将普通Redis服务器使用的代码替换成Sentinel专用代码:初始换Sentinel可以执行的命令，替换之前的默认命令。</li>
<li>初始化Sentinel状态:初始化<code>sentinel.c/sentinelState</code>结构，这个结构保存了服务器中所有Sentinel相关的状态。</li>
<li>根据跟定的配置文件，初始化Sentinel的监视主服务器列表:Sentinel状态中的<code>masters</code>字典记录了所有被Sentinel监视的主服务器的相关信息，其中字典的键是被监视主服务器的名字；而字典的值则是被监视主服务器对应的<code>sentinel.c/sentinelRedisInstance</code>结构。</li>
<li>创建连向主服务器的网络连接: 最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息。对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接:<ul>
<li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li>
<li>另一个是订阅连接，这个链接专门用于订阅主服务器的<code>__sentinel__:hello</code>频道。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么有两个连接?<br>在Redis目前的发布与订阅功能中，被发送的信息不回保存在Redis服务器里，如果发送信息时，接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。<strong>为了不丢失任何信息，必须专门用一个订阅连接来接收该频道的信息</strong>(原理?)。另外除了订阅频道，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接。</p>
</blockquote>
<h3 id="Sentinel网络拓扑"><a href="#Sentinel网络拓扑" class="headerlink" title="Sentinel网络拓扑"></a>Sentinel网络拓扑</h3><p>Sentinel与主服务器，从服务器及其他Sentinel之间都是彼此连接的:</p>
<ul>
<li>首先Sentinel默认<code>每10秒一次</code>向主服务器发送INFO命令，Sentinel可以得到主服务器信息以及主服务器的从服务器信息;</li>
<li>Sentinel会更新自己的主服务器和从服务器信息，还会创建连接到从服务器的命令连接和订阅连接。</li>
<li>Sentinel还会默认<code>每2秒一次</code>通过命令连接向所有被监视的主服务器和从服务器发送命令，这条命令会向服务器的<code>__sentinel__:hello</code>频道发送一条信息</li>
<li>由于Sentinel订阅了主服务器和从服务器的消息，所以所有订阅的Sentinel都会收到上面的信息，接收消息的Sentinel就会感知到发消息的Sentinel存在，并记录到<code>sentinels</code>属性中(可以实现自动发现功能)</li>
</ul>
<h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><h4 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h4><p>默认情况下Sentinel会以<code>每秒一次</code>的频率向所有与它创建了命令连接的实例(包括主服务器，从服务器，其他Sentinel等)发送PING命令, 并通过实例返回的PING命令回复判断是否在线。由于每个Sentinel设置的下线时间标准可能不一样，所以会出现不同的Sentinel认为服务器的状态不一致，所以这种情况称为主观下线状态。</p>
<h4 id="检测客观下线状态"><a href="#检测客观下线状态" class="headerlink" title="检测客观下线状态"></a>检测客观下线状态</h4><p>当Sentinel从其他Sentinel那里接收的足够数量的已下线判断之后，Sentinel就会认为将主服务器判定为客观下线状态，并对主服务器执行故障转移操作。</p>
<h4 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h4><p>当主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头的Sentinel，并由领头Sentinel对下线服务器执行故障转移。<br>选举策略是每个检测到主服务器下线的Sentinel都向其他Sentinel发送想要成为领头的命令，收到命令的Sentinel会将发送命令的Sentinel设置为局部领头，如果一个Sentinel被半数以上的Sentinel设置为局部领头，它就胜出，否则会进行再次选举。</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>选举出领头Sentinel后，领头Sentinel将对已下线的主服务器执行故障转移操作:</p>
<ul>
<li>在已下线服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器: 选择优先级高，复制偏移量大的从服务器，使用命令<code>SLAVE of one</code>使其变为主服务器。</li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器: 领头Sentinel向其他从服务器发送<code>SLAVEOF</code>命令。</li>
<li>将已下线的主服务器设置为心的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。</p>
<h3 id="节点与槽"><a href="#节点与槽" class="headerlink" title="节点与槽"></a>节点与槽</h3><p>Redis集群通常由多个节点(node)组成，开始每个节点都是图例的，它们都处于一个只包含自己的集群中，当要组建一个真正可工作的集群，我们必须将节点连接起来，构成一个包含多个节点的集群。使用<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>命令来完成。另外Redis服务器启动时也可以根据<code>cluster-enabled</code>配置选项来判断是否开启集群模式。节点信息保存在<code>cluster.h/clusterNode</code>结构中，<code>clusterNode</code>结构保存了一个节点的当前状态，比如节点的创建时间，节点的名等;<code>clusterNode</code>的<code>link</code>属性是一个<code>clusterLink</code>结构，该结构保存了连接节点所需的有关信息,比如套接字描述符，输入缓冲区和输出缓冲区; 每个节点都保存着一个<code>clusterState</code>结构，这个结构记录了当前节点的视角下，集群目前所处的状态，例如机器是在线还是下线，集群包含多少节点等。<br>Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为<code>16384</code>(=2048*8)个槽(slot),数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。当数据库中的16384个槽有节点在处理时，集群处于一个上线状态(ok);相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态(fail)。<br>槽指派信息记录在<code>clusterNode.slots[16384/8]</code>属性中, <code>numslots</code>记录了节点负责处理的槽的数量。Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位来判断节点是否负责处理槽i:</p>
<ul>
<li>如果slots数组在索引i上的二进制位值为1，那么表示节点负责处理槽i。</li>
<li>如果slots数组在索引i上的二进制位值为0, 那么表示节点不负责处理槽i。</li>
</ul>
<p>节点会把自己处理的槽信息发送给其他集群中的其他节点，因此集群中的每个节点都会知道数据库中16384个槽分别被指派给了集群中哪些节点。<br><code>clusterState</code>结构中的<code>slots[16384]</code>数组则更上面的正好反过来，它记录了每个槽是由哪个节点在管理的。之所以会有这两种结构是为了在查找节点管理了哪些槽和槽由哪个节点管理的复杂度都降低了。</p>
<h3 id="集群中的执行命令"><a href="#集群中的执行命令" class="headerlink" title="集群中的执行命令"></a>集群中的执行命令</h3><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽(使用crc16(key)&amp;16383算法得出槽位置)，并检查这个槽是否指派给了自己(clusterState.slots[i]是否为自己):</p>
<ul>
<li>如果键所在的槽正好指派给了当前节点，那么节点直接执行这个命令。</li>
<li>如果键所在的槽没有指派给了当前节点，那么节点回向客户端返回一个MOVED错误，指引客户端转向(redirect)至正确的节点，并再次发送之前想要执行的命令。</li>
</ul>
<p>节点与单机服务器在数据库方面的区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制。<br>节点还会使用<code>clusterState</code>结构中的<code>slots_to_keys</code>跳跃表来保存槽和键之间的关系，主要目的是方便节点对属于某个或某些槽的所有数据库键进行批量操作。</p>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目的节点)，并且相关槽所属的键值对也会从源节点移动到目的节点。这个过程可以在线进行，在重新分片过程中，集群不需要下线，并且源节点和目的节点都可以继续处理命令请求。<br>Redis的重新分片操作是由Redis的集群管理软件<code>redis-trib</code>负责执行的。迁移过程如下:<br><img src="/assets/img/redis/redis_trib.png" alt="redis-trib"><br>在执行第四步迁移的过程中，如果客户端向源节点发送一个与数据库键有关的命令，那么:</p>
<ul>
<li>源节点先在自己数据库里查找指定的键，如果找到就直接执行客户端发送的命令.</li>
<li>如果没找到，那么这个键可能已经被迁移到了目标节点，源节点向客户端返回一个ASK错误，指引客户端转向正在导入槽的目的节点，并再次发送之前想要执行的命令。<br>当客户端接收到ASK错误并转向正在执行导入槽节点时，客户端会先向节点发送一个<code>ASKING</code>命令，然后才重新发送想要执行的命令。ASKING命令会打开发送客户端的<code>REDIS_ASKING</code>标识。<br>一般情况下如果客户端向节点发送一个关于槽i的命令，如果节点没有这个槽，那么就会返回<code>MOVED</code>，但是如果节点的<code>clusterState.importing_slots_from[i]</code>显示节点正在导入槽i,并且发送命令的客户端带有<code>REDIS_ASKING</code>（通过<code>ASKING</code>命令打开)标识，那么节点将执行这个关于槽i的命令一次</li>
</ul>
<p>关于ASK错误与MOVED错误的区别:</p>
<ul>
<li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点，客户端收到关于槽i的MOVED错误后，每次遇到槽i请求是，都可以直接将命令发送至MOVED错误所指向的节点。</li>
<li>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施, 不会影响后面命令的发送。</li>
</ul>
<h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分为主节点(master)和从节点(slave),其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。设置从节点的命令:<code>CLUSTER REPLICATE &lt;node_id&gt;</code><br>集群中的每个节点都会定期地祥集群中其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记位疑似下线(probable fail, PFAIL)。如果一个集群里，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线(FAIL), 将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点X标记为下线。<br>当一个从节点发现自己正在复制的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，下面是故障转移执行的步骤:</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中:选举过程和Sentinel差不多。</li>
<li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条PONG消息，可以让集群中其他节点立即知道这个节点从从节点变为了主节点，并且这个主节点已经接管了原本由已下线主节点负责处理的槽。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面主要讲了Redis在多机数据库下的功能特性，其中复制是实现数据备份，数据可靠性的保证。Sentinel实现高可用性的保证。在3.0版本之前的分布式方案都是自己实现的，然后利用Sentinel进行监控。后来Redis自己实现了集群方案，可以用其默认的集群方案来代替之前的自己实现方案。他们之间是相辅相成的，根据自己的需要进行选择。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.zhihu.com/question/21419897" target="_blank" rel="noopener">Redis集群方案应该怎么做?</a></li>
<li><a href="http://rdc.hundsun.com/portal/article/669.html" target="_blank" rel="noopener">如何部署高可用的Redis集群架构</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/05/The-Design-and-Implementation-of-Redis-2/"><span>Redis设计与实现总结——单机数据库的实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/05/The-Design-and-Implementation-of-Redis-2/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-05T11:02:37.000Z">
          2017-03-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>一个Redis Server可以有多个Redis数据库，这点类似于MySQL, 从Redis Server的源代码中可以看到,<code>redisDb</code>是Server数据库的指针，指向一个数据库组成的数组，而数据库的数量则由<code>dbnum</code>属性来表示。客户端可以通过<code>SELECT</code>命令选择当前要操作的数据库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库数组指针</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;                      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据库的定义在<code>redis.h/redisDb</code>中，定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以解除阻塞的键</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库号码</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>dict</code>: 是一个字典，保存了数据库中的所有键值对，我们将这个字典称为键空间(key space)。</li>
<li><code>expires</code>: 也是一个字典，保存的是键值与这个键值过期时间的键值对。</li>
</ul>
<p>一个简化的结构图如下:<br><img src="/assets/img/redis/redis_db.png" alt="db结构"><br>设置生存时间和过期时间时，最终都是计算出最后生存时间，然后把这个值存入<code>expires</code>字典中。过期字典中找不到证明没有设置过期时间。过期删除策略Redis主要是使用惰性删除策略与定期删除两种策略。所谓惰性删除策略就是当用户获取键时，先判断其是否过期，如果过期则删除键，返回失败，如果没过期则正常返回。定期删除策略是Redis会周期行的从过期字典中随机出一部分键值，如果过期则删除键，否则保留。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB(redis database)持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中(RDB文件默认的文件名为<code>dump.rdb</code>)。RDB持久化功能锁生成的RDB文件是一个经过压缩的二进制文件，通过该文件还可以还原生成RDB文件时的数据库状态。<br>有两个Redis命令可以用于生成RDB文件，一个是<code>SAVE</code>, 另一个是<code>BGSAVE</code>。<code>SAVE</code>会阻塞Redis服务进程，知道RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何请求。<code>BGSAVE</code>命令会派生出一个子进程,然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求。<br>RDB文件是在服务器启动时自动执行的，只要Redis服务器启动时检测到RDB文件存在，它就会自动载入RDB文件。但是如果服务器开启了AOF持久化功能，就会优先使用AOF文件。因为AOF文件的更新频率通常比RDB文件高，所以数据是最新的可能性高。<br>用户可以通过save选项设置多个保存条件，但只要其中任意一条被满足，服务器就会执行<code>BGSAVE</code>命令。例如配置为下面三个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p>
<p>只要满足900s内至少一次修改，或300s内至少10次修改，或60s内10000次修改就会自动执行<code>BGSAVE</code>命令。<br>服务器维护一个<code>dirty</code>计数器，用于记录距离上次成功执行<code>SAVE</code>或<code>BGSAVE</code>命令之后，服务器对数据库状态进行了多少次修改(包括写入，删除，更新等操作)。<br>服务器还维护一个<code>lastsave</code>属性，记录服务器上一次成功执行<code>SAVE</code>或<code>BGSAVE</code>命令的时间。<br>RDB文件结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----+----------+---------+---+---------+</span><br><span class="line">|     |          |         |   |         |</span><br><span class="line">|REDIS|db_version|databases|EOF|check_sum|</span><br><span class="line">|     |          |         |   |         |</span><br><span class="line">+-----+----------+---------+---+---------+</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>REDIS</code>: RDB文件开头是REDIS部分，这个部分长度为5字节,保存着”REDIS”五个字符。通过五个字符，快速检测是否为RDB文件。</li>
<li><code>db_version</code>: 长度为4字节，它的值是一个字符串表示的整数，记录了RDB文件的版本号。</li>
<li><code>databases</code>: 包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li>
<li><code>EOF</code>: 长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕。</li>
<li><code>check_sum</code>: 8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对前面四部分的内容计算得出的。服务器载入RDB文件时，会将载入数据所计算出的校验和与<code>check_sum</code>所记录的检验和进行对比，以此来检查RDB文件是否出错或者有损坏的情况。<br>可以使用<code>od -c dump.rdb</code>或<code>od -cx dump.rdb</code>命令来对RDB文件内容进行分析。</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF(Append Only File)持久化功能是通过保存Redis服务器所执行的写命令来记录数据库状态的。AOF持久化功能的实现可以分为命令追加(append), 文件写入，文件同步(sync)三个步骤:</p>
<ul>
<li>命令追加: 服务器执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。</li>
<li>AOF文件的写入与同步: 服务器的每次时间循环结束之前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里。<br><code>flushAppendOnlyFile</code>函数的行为由服务器配置的<code>appendfsync</code>选项的值来决定:</li>
</ul>
<table>
<thead>
<tr>
<th>appendfsync选项的值</th>
<th>flushAppendOnlyFile函数的行为</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>将aof_buf缓冲区中的所有内容写入并同步到AOF文件</td>
<td>性能最低，但是安全性最高，发生故障停机最多丢失一个循环事件所产生的在缓冲区中的命令</td>
</tr>
<tr>
<td>everysec(默认值)</td>
<td>将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1s,那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的</td>
<td>性能足够快，并且出现故障停机，最多丢失一秒钟的命令数据</td>
</tr>
<tr>
<td>no</td>
<td>将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统决定</td>
<td>性能最好，写入AOF速度最快，但是单次同步时间最长，出现故障丢失的命令最多</td>
</tr>
</tbody>
</table>
<p>由于AOF文件记录了重建数据库所需的所有写命令，所以服务器只要读入并执行一遍AOF文件里么保持的写命令，就可以还原服务器关闭之前的状态。<br>由于AOF持久化是通过保存被执行的写命令来记录数据库状态的，随着时间的推移，写命令越来越多，这时候就需要<code>AOF重写</code>来减轻文件体积的膨胀。<br><code>AOF重写</code>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录的这个键值对的多条命令。但是在重写列表，哈希表，集合，有序集合等多个元素的键时，如果元素的数量超过了<code>redis/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>常量的值，会通过多条命令来记录键的值。<br>一个问题是在AOF重写期间，服务器还需要处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。为了解决这个问题，Redis服务器设置了一个<code>AOF重写缓冲区</code>，这个缓冲区在服务器创建子进程进行重写是开始使用,当Redis服务器执行完一个写命令后，它会同事将这个命令发送给AOF缓冲区和<code>AOF重写缓冲区</code>。当AOF重写工作完成后，向父进程发送信号，父进程就会将<code>AOF重写缓冲区</code>中的所有内容写到新的AOF文件中，对新的AOF文件进行改名，原子地 （atomic)覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>文件事件(file event): Redis服务器通过套接字与客户端(或其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。<br>下图是Redis自己实现的文件事件处理器的四个组成部分:<br><img src="/assets/img/redis/redis_fileevent.png" alt="db结构"></p>
<ul>
<li>文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答(accept),读取(read),写入(write)，关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，着保持了Redis内部单线程设计的简单性。<br>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总会将所有产生事件的套接字都放在一个队列里，然后通过这个队列，以有序(sequentially),同步(synchronously)，每次一个套接字的方式向文件事件分派器传送套接字。<br>Redis的I/O多路复用程序的所有功能都是通过包装常见的<code>select</code>,<code>epoll</code>,<code>evport</code>和<code>kqueue</code>这些I/O多路复用函数库来实现的，编译时会自动选择性能高最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现。</p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件(time event): Redis服务器中的一些操作(如<code>serverCron</code>函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。<br>Redis的时间事件分为两类:</p>
<ul>
<li>定时事件: 让程序在指定的时间之后执行一次。</li>
<li>周期性事件: 让一端程序每隔指定的时间就执行一次。</li>
</ul>
<p>一个时间事件主要由以下三个属性:</p>
<ul>
<li>id: 服务器为时间事件创建的全局唯一ID(标识号)。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li>
<li>when: 毫秒精度的UNIX时间戳，记录了时间事件的到达(arrive)时间。</li>
<li>timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用响应的处理器来处理事件。</li>
</ul>
<p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p>
<ul>
<li>如果事件处理器返回<code>ae.h/AE_NOMORE</code>，那么这个事件为定时事件:该事件在达到一次之后就会被删除，之后不再到达。</li>
<li>如果事件处理器返回一个非<code>AE_NOMORE</code>的整数值，那么这个事件为周期性时间:当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间后再次到达，并以这种方式一直更新运行下去。</li>
</ul>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责,下面是这个函数的伪代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    // 获取到达时间离当前最接近的时间事件</span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    </span><br><span class="line">    // 计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    </span><br><span class="line">    // 如果事件已到达，那么remaind_ms的值就可能为负数，将它设定为<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    // 根据remaind_ms的值，创建timeval结构</span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    </span><br><span class="line">    // 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class="line">    // 如果remaind_ms的值为<span class="number">0</span>，那么aeApiPoll调用之后马上返回，不阻塞</span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">   </span><br><span class="line">    // 处理所有已产生的文件事件 </span><br><span class="line">    processFileEvents()</span><br><span class="line">    </span><br><span class="line">    // 处理所有已到达的时间事件</span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure></p>
<p>事件的调度和执行规则:</p>
<ol>
<li>aeApiPoll函数的最大阻塞时间由到达时间最接近的当前时间的时间事件决定，这个方法既可以避免服务器对时间事件并行频繁的轮询，可以确保aeApiPoll函数不会阻塞时间过长。</li>
<li>因为文件事件是随机出现的，如果处理完文件事件后时间事件仍未到达，继续等待并处理下一个文件事件。</li>
<li>对文件事件和时间事件的处理都是同步，有序，原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占。因此耗时的事件会影响整个服务的性能。</li>
<li>因为时间事件是在文件事件之后执行，并且事件之间不会抢占，所以时间事件的实际处理时间通常回避时间事件设定的到达时间稍微晚一些。</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>通过使用I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。<br>关于<code>redisClient</code>的定义可以从<code>redis.h</code>中看到，客户端有很多属性。这些属性可以分为两类:</p>
<ul>
<li>比较通用的属性，这些属性很少特定功能相关，无论客户端执行的是什么工作，它都需要这些属性。</li>
<li>和特定功能相关的属性。下重点介绍这些。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>fd(fake client)</code>: 伪客户端的fd属性的值为<code>-1</code>,伪客户端处理的命令请求来自于AOF文件或者lua脚本; 普通客户端fd属性值是大于-1的整数，使用套接字与服务器通信，所以fd用来记录客户端套接字的描述符。</li>
<li><code>name</code>: 默认情况下一个连接到服务器的客户端是没有名字的，但是可以使用<code>CLIENT setnaem</code>命令设置一个名字，可以通过<code>CLIENT list</code>查看。</li>
<li><code>flags</code>: 一部分标志记录了客户端的角色(如REDIS_MASTER代表主服务器, REDIS_SLAVE代表从服务器), 另一部分标志记录了客户端目前所处的状态(REDIS_MONITOR正在执行monitor, REDIS_MULTI标志客户端正在执行事务)。</li>
<li><code>querybuf</code>: 用于保存客户端发送的命令请求。输入缓冲区的大小会根据输入内容动态调整，但是最大不能超过1GB,否则服务器将关闭这个客户端。</li>
<li><code>argv</code>和<code>argc</code>: 服务器将客户端发送的名保存到<code>querybuf</code>后，对命令内容进行分析，得出命令参数及命令的参数个数分别保存到<code>argv</code>和<code>argc</code>中。</li>
<li><code>authenticated</code>: 记录客户端是否通过了身份验证，未通过用0表示，通过用1表示。</li>
<li><code>ctime</code>: 记录创建客户端的时间。</li>
<li><code>lastinteraction</code>: 记录客户端与服务器最后一次进行互动的时间。</li>
<li><code>obuf_soft_limit_reached_time</code>: 记录输出缓冲区第一次到达软性显示的时间。</li>
</ul>
<p>执行命令所得的命令回复会被保存到客户端状态的输出缓冲区里，每个客户端都有两个输出缓冲区可用</p>
<ul>
<li><code>buf</code>和<code>bufpos</code>: 固定的换缓冲区，用于保存那些长度比较小的回复，如:OK, 简短的字符串值，整数值或错误回复等。<code>buf</code>是缓冲区，<code>bufpos</code>记录<code>buf</code>数组目前已经使用的字节数量。</li>
<li><code>reply</code>: 可变大小的缓冲区是一个链表,用于保存比较大的回复，比如一个非常长的字符串值，列表等。</li>
</ul>
<h3 id="创建与关闭"><a href="#创建与关闭" class="headerlink" title="创建与关闭"></a>创建与关闭</h3><ul>
<li><strong>创建不同客户端</strong>: 如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端connect函数连接到服务器时，服务器就会调用连接事件处理器为客户端创建响应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</li>
<li><strong>关闭客户端</strong>: 一个普通客户端被关闭的原因有很多:<ul>
<li>客户端进程退出或被杀死</li>
<li>客户端向服务器发送了带有不符合协议格式的命令请求</li>
<li>客户端成了CLIENT KILL命令的目标</li>
<li>用户为服务器设置了timeout配置选项，客户端空转时间超过timeout选项设置的值</li>
<li>客户端发送的命令请求大小超过了输入缓冲区的限制大小(1GB)</li>
<li>发送给客户端的命令回复超过输出缓冲区的限制大小。按理说输出缓冲区是没有大小限制的，但是为了防止过多占用服务器资源，采用硬性限制和软性限制两种方案限制大小。</li>
</ul>
</li>
<li><strong>Lua脚本的伪客户端</strong>: 服务器在初始化时负责创建Lua脚本中包含的Redis命令的伪客户端，在服务器运行的整个周期中都会存在。</li>
<li><strong>AOF文件的伪客户端</strong>: 服务器载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成后关闭。</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>前面讲了，客户端发送的请求会被放到输入缓冲区，然后服务器对命令进行解析，转换成协议格式，服务器将通过调用命令执行器来完成余下的步骤:</p>
<ul>
<li><strong>查找命令</strong><br>根据上面说的<code>argv[0]</code>参数中对应的命令在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的<code>cmd</code>属性里。<br>命令表是一个字典，字典的键是一个个命令名字，比如”set”,”get”,”del”等;而字典的值则是一个个<code>redisCommand</code>结构，每个<code>redisCommand</code>结构记录了一个Redis命令的实现信息。</li>
</ul>
<p><code>redisCommand</code>结构的主要属性:</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>char *</td>
<td>命令的名字，比如”set”</td>
</tr>
<tr>
<td>proc</td>
<td>redisCommandProc *</td>
<td>函数指针，指向命令的实现函数</td>
</tr>
<tr>
<td>arity</td>
<td>int</td>
<td>命令参数的个数，用于检查命令请求的格式是否正确</td>
</tr>
<tr>
<td>sflags</td>
<td>char *</td>
<td>字符串形式的标识值，这个值记录了命令的属性<br>例如:<br>w:表示写入命令<br>r:只读命令<br>m:可能会占用大量内存的命令<br>a:这是一个管理命令</td>
</tr>
<tr>
<td>flags</td>
<td>int</td>
<td>对sflags标识进行分析得出的二进制标识，由程序自动生成</td>
</tr>
<tr>
<td>calls</td>
<td>long long</td>
<td>服务器总共执行了多少次这个命令</td>
</tr>
<tr>
<td>milliseconds</td>
<td>long long</td>
<td>服务器执行这个民两个所耗费的总时长</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>执行预备操作</strong><br>到目前为止，服务器已经将执行命令所需的命令实现函数,参数等都收集齐了，真正执行命令之前还需要一些预备操作：</p>
<ul>
<li>检查客户端状态的cmd指针是否执行NULL</li>
<li>检查命令请求所给定的参数个数是否正确</li>
<li>检查客户端是否已经通过了身份验证</li>
<li>如果服务器打开了<code>maxmemory</code>功能，需要检查服务器的内存占用情况，在有需要的时候进行内存回收</li>
<li>其他检查和限制执行的操作等</li>
</ul>
</li>
<li><p><strong>调用命令的实现函数</strong><br>当服务器决定要执行命令是<code>client-&gt;cmd-&gt;proc(client);</code>, 执行函数后会把回复保存到客户端的输出缓冲区，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将回复返回给客户端。</p>
</li>
<li><strong>执行后续工作</strong><br>在执行完实现函数后，服务器还需要执行一些后续工作:<ul>
<li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会坚持是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li>
<li>根据刚刚执行命令所耗费的时长，更被执行命令redisCommand结构的milliseconds属性，并将calls计数器加一</li>
<li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里。</li>
<li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器</li>
<li>根据刚刚执行命令所耗费的时长，更被执行命令redisCommand结构的milliseconds属性，并将calls计数器加一</li>
<li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里。</li>
<li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li>
</ul>
</li>
</ul>
<p>回复发送完毕后，回复处理器会清空客户端状态的输出缓冲区，未处理下一个命令请求做好准备。当客户端接收到协议格式的命令回复后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p>
<h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的<code>serverCron</code>函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。<code>serverCron</code>的函数主要功能如下面所列:</p>
<ul>
<li><strong>更新服务器时间缓存</strong>: 为了减少获取服务器时间而进行系统调用的次数，服务器状态中的<code>unixtime</code>和<code>mstime</code>属性被用作当前时间的缓存，serverCron函数默认每100ms的频率更新这两个字段。对于设置键值过期时间，慢查询日志这种需要高精度时间的功能来说，服务器还是会再次执行系统调用。</li>
<li><strong>更新LRU时钟</strong>: 服务器状态中的lruclock属性保存了服务器的LRU时钟;每个Redis对象都会有一个lru属性，保存了对象最后一次被访问的时间。这个值也是用serverCron来更新。</li>
<li><strong>更新服务器每秒执行命令次数</strong>: <code>serverCron</code>函数中的<code>trackOperationsPerSecond</code>函数会以每100ms一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。可以通过<code>INFO stats</code>查看。</li>
<li><strong>更新服务器内存峰值记录</strong>:<code>serverCron</code>每次都会查看服务器当前使用的内存数量，并与<code>stat_peak_memory</code>保持的值进行比较，如果当前的数据比较大就更新这个值。<code>INFO memory</code>命令可以查看具体的数据。</li>
<li><strong>处理SIGTERM信号</strong>:服务器启动时，Redis会为服务器进程的<code>SIGTERM</code>信号关联处理器<code>sigtermHandler</code>函数，这个信号处理器负责在服务器接到<code>SIGTERM</code>信号时，打开服务器状态的<code>shutdown_asap</code>标识。如果不拦截这个信号，可能会造成比如RDB持久化操作时关闭服务器。</li>
<li><strong>管理客户端资源</strong>:<code>serverCron</code>函数每次执行都会调用<code>clientsCron</code>函数，<code>clientsCron</code>函数会对一定数量的客户端进行以下两个检查:<ul>
<li>如果客户端与服务器之间的连接已经超时,那么程序释放这个客户端。</li>
<li>如果客户端在上一次执行命令请求后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</li>
</ul>
</li>
<li><strong>管理数据库资源</strong>: 每次调用<code>databasesCron</code>函数，对服务器中一部分数据库进行检查，删除其中的过期键，并在需要时，对字典进行收缩操作。</li>
<li><strong>执行被延迟的BGREWRITEAOF</strong></li>
<li><strong>检查持久化操作的运行状态</strong></li>
<li><strong>将AOF缓冲区的内容写入到AOF文件</strong></li>
<li><strong>关闭异步客户端</strong></li>
<li><strong>增加cronloops计数器的值</strong>:<code>cronloops</code>记录了<code>serverCron</code>函数执行的次数。</li>
</ul>
<h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程。过程如下:</p>
<ul>
<li><strong>初始化服务器状态结构</strong>:包括设置服务器的运行ID,设置服务器的默认运行频率，设置服务器的默认配置文件路径，设置服务器默认端口号，设置服务器默认持久化条件等。</li>
<li><strong>载入配置选项</strong>: 可以通过给定配置函数或指定配置文件来修改服务器的默认配置。</li>
<li><strong>初始化服务器数据结构</strong>:包括初始化<code>server.clients</code>链表，初始化执Lua脚本的执行环境<code>server.lua</code>等;还进行了创建共享对象，打开服务器的监听端口等操作。</li>
<li><strong>还原数据库状态</strong>: 完成初始化后，服务器需要载入<code>RDB</code>文件或者<code>AOF</code>文件，并根据文件记录的内容来还原服务器的数据库状态。</li>
<li><strong>执行事件循环</strong>: 初始完成后，开始执行服务器的事件循环(loop)。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/04/The-Design-and-Implementation-of-Redis-1/"><span>Redis设计与实现总结——数据结构与对象</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/04/The-Design-and-Implementation-of-Redis-1/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-04T03:44:38.000Z">
          2017-03-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="简单的动态字符串"><a href="#简单的动态字符串" class="headerlink" title="简单的动态字符串"></a>简单的动态字符串</h3><p>Redis自己构建的一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将SDS用做Redis的默认字符串表示。<br>SDS的定义在<code>sds.h/sdshdr</code>结构中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录buf数组中已使用的字节的数量</span></span><br><span class="line"><span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/redis/redis_sds.png" alt="SDS结构"><br>C字符串和SDS之间的区别:</p>
<table>
<thead>
<tr>
<th>C字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取字符串长度的复杂度为O(N)</td>
<td>获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td>API是不安全的，可能会造成缓冲区溢出</td>
<td>API是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td>修改字符串长度N次必然需要执行N次内存重分配</td>
<td>修改字符串长度N次最多需要执行N次内存重分配</td>
</tr>
<tr>
<td>只能保持文本数据</td>
<td>可以保持文本或者二进制数据</td>
</tr>
<tr>
<td>可以使用所有&lt;string.h&gt;库中的函数</td>
<td>可以使用一部分&lt;string.h&gt;库中的函数</td>
</tr>
</tbody>
</table>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在redis链表键，发布与订阅，慢查询，监视器等功能都用到了。<br>链表结构分为链表和链表节点，每个链表由多个链表的节点组合而成。每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是一个双端链表。表头节点和表尾节点都指向NULL, 是一个无环链表。保存链表值的类型是void, 可以保持不同类型的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表定义adlist/list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表所浩瀚的节点数量 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点定义adlist.h/listNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/redis/redis_list.png" alt="list结构"></p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典又称为符号表(symbol table), 关联数组(associative array)或映射(map),是一种用于保存键值对(key-value pair)的抽象数据结构。字典中的每一个键都是独一无二的。字典在Redis中应用相当广泛，比如Redis的数据库就是使用字典作为底层实现的，对数据库的CRUD也是建立在字典的操作上。字典还是哈希键的底层实现之一。<br><img src="/assets/img/redis/redis_dict.png" alt="dict结构"><br>字典的结构如上图所示，字典是由多个结构连接而成，首先是字典结构<code>dict.h/dict</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型特定函数, 保存了一簇用于操作特定类型键值对的函数,</span></span><br><span class="line">    <span class="comment">// Redis会为用途不同的字典设置不同的类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据, 保存了需要传给那些类型特定的函数的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表, 注意这里hash表定义两个，其中一个是实际中使用的，</span></span><br><span class="line">    <span class="comment">// 另一个是在扩展或收缩的时候使用的，类似于GC复制算法的原理</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引, 记录rehash目前的进度</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>字典所使用的哈希表<code>dict.h/dictht</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemark;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p>
<p>哈希表节点:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值 </span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向下个哈希表节点,形成链表</span></span><br><span class="line">    <span class="comment">// 使用next指针解决哈希冲突的问题</span></span><br><span class="line">    <span class="comment">// 哈希算法为MurmurHash2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>
<p>随着操作的不断执行，哈希表保存的键值对会逐渐的增多或减少，为了让哈希负载因子(load factor)维持在一个合理的范围之内，当哈希表保持的键值对对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或收缩。<br>为了避免rehash对服务器性能造成影响，服务器不是一次性将<code>ht[0]</code>里面的所有键值对全部<code>rehash</code>到<code>ht[1]</code>，而是分多次，渐进式地将<code>ht[0]</code>里面的键值对慢慢地<code>rehash</code>到<code>ht[1]</code>。</p>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构, 它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(longN)，最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。更多介绍参考<a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">wiki</a>。<br>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。跳跃表的另一个应用就是作为集群节点中的内部数据结构。除了这两个地方，其它地方没有用到。<br>跳跃表有<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个结构定义，其中<code>zskiplistNode</code>结构用于表示跳跃表节点，而<code>zskiplist</code>结构则用于保存跳跃表节点信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/redis/redis_skiplist.png" alt="skiplist结构"></p>
<ul>
<li>层: 每个层带有两个属性，前进指针和跨度。前进指针用于访问表尾方向的其节点，而跨度则记录了前进指针所指向节点和当前节点的距离。上图中连线数字上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问就会沿着层的前进指针进行。每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law, 越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。</li>
<li>前进指针: 每个层都有一个指向表尾方向的前进指针(level[i].forward属性), 用于从表头向表尾方向的访问节点。</li>
<li>后退指针: 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值: 各个节点中的1.0，2.0和3.0是节点所保存的分值。在跳跃表中，节点各自所保存的分值从小到大排列。 跳跃表中的节点按照分值进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li>
<li>成员对象: 各个节点中的o1, o2和o3是节点所保存的成员对象。</li>
</ul>
<p>具体的操作过程参考<a href="http://blog.csdn.net/ict2014/article/details/17394259" target="_blank" rel="noopener">http://blog.csdn.net/ict2014/article/details/17394259</a></p>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合键的底层实现。<br>每个<code>intset.h/intset</code>结构表示一个整数集合:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tyepdef <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式, 决定contents的类型</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保持元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/redis/redis_intset.png" alt="intset结构"><br><code>contents</code>数组是整数集合的底层实现: 整数集合的每个元素都是<code>contents</code>数组的一个数组项(item), 各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。虽然<code>contetns</code>声明为<code>int8_t</code>类型的数组,但实际上<code>contents</code>并不保存任何<code>int8_t</code>类型的值，<code>contents</code>数组的真正类型取决于<code>encoding</code>属性的值。<br>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行<code>升级(upgrade)</code>, 然后才能将新元素添加到整数集合里面。整数集合不支持<code>降级操作</code>, 一旦对数组进行了升级，编码就会一致保持升级后的状态。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表(ziplist)是列表建和哈希键的底层实现之一。当一个列表建只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表建的底层实现。<br>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。一个压缩列表可以包含任意多个节点(entry),每个节点可以保持一个字节数组或一个整数值。<br><img src="/assets/img/redis/redis_ziplist.png" alt="ziplist结构"><br>压缩列表各个组成部分的详细说明:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录整个压缩列表占用的内存字节数:在对压缩列表进行内存重分配,或者计算zlend的位置时使用</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节:通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2字节</td>
<td>记录了压缩列表包含的节点数量，当节点数小于UINT16_MAX时取这个值，大于时需要遍历列表才能得出</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的节点，节点的长度由节点保存的内容决定</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1字节</td>
<td>特殊值<code>0xFF(十进制255)</code>，用于标记压缩列表的末端</td>
</tr>
</tbody>
</table>
<p>压缩列表的节点构成:</p>
<ul>
<li><code>previous_entry_length</code>: 以字节为单位，记录了压缩列表中前一个节点的长度。只要我们拥有了一个指向某个节点的起始地址的指针，那么通过这个指针及这个节点的<code>previous_entry_length</code>属性，程序就可以一直向前一个节点回溯，最终达到压缩列表的表头节点。</li>
<li><code>encoding</code>: 记录了节点的<code>content</code>属性所保存数据的类型及长度。</li>
<li><code>content</code>: 负责保存节点的值，节点值可以使一个字节数组或整数，值的类型和长度由节点的<code>encoding</code>属性决定。</li>
</ul>
<p><code>连锁更新</code>问题是指当插入新节点或删除节点后，<code>previous_entry_length</code>属性所记录的长度不能够满足改变后的节点的记录，需要扩容以便记录，最差的情况是后面的每个节点都会改变位置。最差的复杂度为O(N^2)。但是这种情况很少见，一般复杂度为O(N)。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>前面介绍了Redis的主要数据结构，但是Redis并没有直接使用这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个<code>对象系统</code>, 这个系统包含字符串对象，列表对象，哈希对象，集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们面前所介绍的数据结构。我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率，而这些对用户是透明的。<br>Redis的对象系统还实现了基于引用计数技术的内存回收机制(GC), 当程序不再是由某个对象的时候，这个对象所占用的内存就会被自动释放；另外Redis还通过引用计数法实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。<br>每当我们在Redis数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键(键对象),另一个对象用作键值对的值(值对象)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>TYPE</code>命令可以看到对象的类型，对象的类型及type属性的值对应关系如下表:</p>
<table>
<thead>
<tr>
<th>type类型常量</th>
<th>对象的名称</th>
<th>TYPE命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
<td>“string”</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
<td>“list”</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
<td>“hash”</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
<td>“set”</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
<td>“zset”</td>
</tr>
</tbody>
</table>
<p>每种TYPE对象的底层编码都是由上面说的数据结构组成的，使用<code>OBJECT ENCODING</code>命令可以查看一个数据库键的值对象的编码，具体的对应关系如下表:</p>
<table>
<thead>
<tr>
<th>对象所使用的底层数据结构</th>
<th>编码常量</th>
<th>OBJECT ENCODING命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>REDIS_ENCODING_INT</td>
<td>“int”</td>
</tr>
<tr>
<td>embstr编码的简单动态字符串(SDS)</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>“embstr”</td>
</tr>
<tr>
<td>简单动态字符串</td>
<td>REDIS_ENCODING_RAW</td>
<td>“raw”</td>
</tr>
<tr>
<td>字典</td>
<td>REDIS_ENCODING_HT</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>双端链表</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>压缩列表</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>整数集合</td>
<td>REDIS_ENCODING_INTSET</td>
<td>“intset”</td>
</tr>
<tr>
<td>跳跃表和字典</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>“skiplist”</td>
</tr>
</tbody>
</table>
<p>每种类型对象可以使用哪些数据结构，下面做了一个总结:</p>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>“int”</th>
<th>“embstr”</th>
<th>“raw”</th>
</tr>
</thead>
<tbody>
<tr>
<td>“string”</td>
<td>如果字符串对象保存的是整数值，并且其可以用long类型来表示</td>
<td>如果字符串对象保持的是一个字符串值，并且其长度小于39字节</td>
<td>如果字符串对象保持的是一个字符串值，并且其长度大于39字节</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>“linkedlist”</th>
<th>“ziplist”</th>
</tr>
</thead>
<tbody>
<tr>
<td>“list”</td>
<td>不满足ziplist的条件的情况</td>
<td>同时满足:<br>1. 所有字符串元素的长度都小于64字节;<br>2. 元素数量小于512个</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>“hashtable”</th>
<th>“ziplist”</th>
</tr>
</thead>
<tbody>
<tr>
<td>“hash”</td>
<td>不满足ziplist的条件的情况</td>
<td>同时满足:<br>1. 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节;<br>2. 哈希对象保存的键值对数量小于512个</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>“intset”</th>
<th>“hashtable”</th>
</tr>
</thead>
<tbody>
<tr>
<td>“set”</td>
<td>同时满足:<br>1. 集合对象保存的所有元素都是整数值；<br>2. 集合对象保存的元素数量不超过512个</td>
<td>不满足”intset”的条件的情况</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>“ziplist”</th>
<th>“skiplist”</th>
</tr>
</thead>
<tbody>
<tr>
<td>“zset”</td>
<td>同时满足:<br>1. 有序集合保持的元素数量小于128个；<br>2. 有序集合保持的所有元素成员的长度都小于64字节</td>
<td>不满足”ziplist”的条件的情况</td>
</tr>
</tbody>
</table>
<p><code>redisObject</code>有一个<code>lru</code>属性,这个属性记录了对象最后一次被命令程序访问的时间,<code>OBJECT IDLETIME</code>命令可以打印出给定键的空转时长(当前时间-lru时间), 另外当开启<code>maxmemory</code>选项，并且服务器用于内存回收的算法为<code>volatile-lru</code>或者<code>allkeys-lru</code>，那么当服务器占用的内存数超过了<code>maxmemory</code>选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/02/03/gc-advanced/"><span>垃圾回收进阶算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/02/03/gc-advanced/" rel="bookmark">
        <time class="entry-date published" datetime="2017-02-03T07:25:21.000Z">
          2017-02-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>了解GC的基本算法后，还需要了解各种改进的GC算法，这些算法是在之前的基础上进行扩展和组合的。主要包括<code>GC标记-压缩算法</code>, <code>保守式GC</code>, <code>分代垃圾回收</code>， <code>增量式垃圾回收</code>和<code>RC Immix算法</code>等。</p>
</blockquote>
<h2 id="GC标记-压缩算法"><a href="#GC标记-压缩算法" class="headerlink" title="GC标记-压缩算法"></a>GC标记-压缩算法</h2><p>GC标记-压缩算法(Mark Compact GC)是将GC标记-清除算法与GC复制算法相结合的产物。 GC标记-压缩算法由标记阶段和压缩阶段构成。标记阶段和GC标记-清除算法提到的标记阶段一样。接下来需要搜索数次的堆来进行压缩。压缩阶段通过数次搜索堆来重新装填活动对象。</p>
<h3 id="Lisp2算法"><a href="#Lisp2算法" class="headerlink" title="Lisp2算法"></a>Lisp2算法</h3><p>标记阶段的代码就不重复了，这里主要看压缩阶段的代码，下面可以看出压缩阶段主要分为三个步骤:</p>
<ol>
<li>第一步是<code>set_forwarding_ptr</code>, 主要是按顺序遍历堆内的活动对象，每个活动对象的<code>forwarding</code>指针指向的是以后这个活动对象需要移动到的位置。</li>
<li>第二步是<code>adjust_ptr</code>, 遍历整个活动对象，复制他们之间的引用关系, 这个步骤只更新指针。</li>
<li>第三步<code>move_obj</code>, 遍历整个堆，对活动对象进行移动。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">compaction_phase() &#123;</span><br><span class="line">    set_forwarding_ptr()</span><br><span class="line">    adjust_ptr()</span><br><span class="line">    move_obj()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set_forwarding_ptr() &#123;</span><br><span class="line">    scan = new_address = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 对被标记的对象，forwarding指针指向应该移动到的位置</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            scan.forwarding = new_address</span><br><span class="line">            new_address += scan.size</span><br><span class="line">        <span class="comment"># 遍历整个堆</span></span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="comment"># 移动根指针</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = (*r).forwarding</span><br><span class="line">    </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="comment"># 每个活动对象，原来指向子节点的指针改为指向直接点的forwarding指向的地址</span></span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move_obj() &#123;</span><br><span class="line">    scan = $free = $head_start</span><br><span class="line">    <span class="comment"># 遍历堆</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end) </span><br><span class="line">        <span class="keyword">if</span>(scan.mark == TRUE)</span><br><span class="line">            new_address = scan.forwarding</span><br><span class="line">            <span class="comment"># 移动当前对象到对象forwarding指针指向的地址</span></span><br><span class="line">            copy_data(new_address, scan, scan.size)</span><br><span class="line">            <span class="comment"># 移动完活动对象后清空指针和标记，防止再次移动</span></span><br><span class="line">            new_address.forwarding = NULL</span><br><span class="line">            new_address.mark = FALSE</span><br><span class="line">            <span class="comment"># $free最终是压缩后可分配空间的开始</span></span><br><span class="line">            $free += new_address.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的步骤可以用下面的图形化的例子来描述:<br>首先假设原始状态如下:<br><img src="/assets/img/gc/gc_mc_list2_1.png" alt="原始状态"><br>先对其进行标记:<br><img src="/assets/img/gc/gc_mc_list2_2.png" alt="标记后"><br>设定forwarding指针:<br><img src="/assets/img/gc/gc_mc_list2_3.png" alt="设定forwarding指针"><br>更新指针:<br><img src="/assets/img/gc/gc_mc_list2_4.png" alt="更新指针"><br>移动对象:<br><img src="/assets/img/gc/gc_mc_list2_5.png" alt="移动对象"><br>上面可以看出，整个过程只是把活动对象往一边移动，活动对象之间的顺序不变。</p>
<ul>
<li>优点: 这个算法相对其他算法而言，堆利用率高，而且所有活动对象压缩到一端，不存在碎片化，能够充分的利用堆。</li>
<li>缺点: 整个压缩过程需要3遍对堆的搜索，也就是执行该算法所花费的时间与堆大小成正比，吞吐量要劣于其他算法。</li>
</ul>
<h3 id="Two-Finger算法"><a href="#Two-Finger算法" class="headerlink" title="Two-Finger算法"></a>Two-Finger算法</h3><p>Two-Finger算法由两个步骤构成:</p>
<ol>
<li>移动对象</li>
<li>更新指针</li>
</ol>
<p>我们知道Lisp2算法是把所有对象向右滑动，不改变活动对象的顺序，而Two-Finger算法则是真正的移动对象，把后面的活动对象移动到前面的空间。为了防止对象相互覆盖，必须要将<code>所有对象整理成大小一致</code>, 这个该算法的一个前提条件。另外Lisp2算法需要单独设置forwarding指针，但是Two-Finger算法可以利用对象的域来设定forwarding指针，不要单独占空间。<br>两个步骤对象的伪代码如下, 要说明的是<code>move_obj</code>函数有两个指针:$free, 从头往后找，找空闲的空间； live，从后往前找，找活动对象。这两个指针就是Two-Finger的名称由来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">move_obj() &#123;</span><br><span class="line">    <span class="comment">#从头开始找空闲空间</span></span><br><span class="line">    $free = $heap_start</span><br><span class="line">    <span class="comment">#从尾开始找活动对象</span></span><br><span class="line">    live = $heap_end - OBJ_SIZE</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">        <span class="comment">#free, 是活动对像就略过,继续往后找</span></span><br><span class="line">        <span class="keyword">while</span>($free.mark == TRUE)</span><br><span class="line">            $free += OBJ_SIZE</span><br><span class="line">        <span class="comment">#live, 是活动对象就略过，继续往前找</span></span><br><span class="line">        <span class="keyword">while</span>(live.mark == FALSE)</span><br><span class="line">            live -= OBJ_SIZE</span><br><span class="line">        <span class="comment"># free 指针 比 live小，证明还没有结束，否则证明查找结束了</span></span><br><span class="line">        <span class="keyword">if</span>($free &lt; live)</span><br><span class="line">            <span class="comment">#把live指向的对象复制到free地址</span></span><br><span class="line">            copy_data($free, live, OBJ_SIZE)</span><br><span class="line">            <span class="comment">#live指向的对象的forwarding指针指向新地址，为下一步更新指针做准备</span></span><br><span class="line">            live.forwarding = $free</span><br><span class="line">            <span class="comment">#移动过的对象标记位FALSE</span></span><br><span class="line">            live.mark = FALSE</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="comment">#*r&gt;=$free的条件是对于被移动过的对象执行指针更新，没有移动过的对象保持原样</span></span><br><span class="line">        <span class="keyword">if</span>(*r &gt;= $free)</span><br><span class="line">            *r = (*r).forwarding</span><br><span class="line">        </span><br><span class="line">    scan = $head_start</span><br><span class="line">    <span class="comment">#scan &lt; $free 是因为对于大于scan的节点已经失效，只对当前活动对象更新</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        <span class="comment">#更新过的标记一下</span></span><br><span class="line">        scan.mark = FLASE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            <span class="comment">#*child &gt;= $free 的条件是对于被移动过的对象执行指针更新，</span></span><br><span class="line">            <span class="comment"># 没有移动过的对象保持原样</span></span><br><span class="line">            <span class="keyword">if</span>(*child &gt;= $free)</span><br><span class="line">                *child = (*child).forwarding</span><br><span class="line">        scan += OBJ_SIZE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点: 不需要额外的内存存储forwarding指针，内存使用效率比Lisp2高，只搜索两次堆，吞吐量也更好.</li>
<li>缺点: 压缩后对象的顺序发生了很大变化，不利于缓存的使用。而且每个对象大小必须一致，限制比较多。</li>
</ul>
<h3 id="表格算法"><a href="#表格算法" class="headerlink" title="表格算法"></a>表格算法</h3><p>表格算法是综合了Lisp2和Two-Finger两种算法优点的算法。其主要步骤也是有两部分:</p>
<ol>
<li>移动对象(群)以及构筑间隙表格(break table)</li>
<li>更新指针</li>
</ol>
<p>前面两个每次都是移动一个活动对象，而在表格算法种每次移动的是一个群连续的活动对象，更新指针所有的信息也不再是forwarding指针，而是是有个一个叫间隙表格的方法。间隙表是由两个值组成的，其中每个表格代表的是一个活动对象群的入口，左值代表活动对象群的首地址，右值代表活动对象群所相邻的前面的空间占分块的总大小。<br>第一步过程可以用伪代码来表示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">movie_obj()&#123;</span><br><span class="line">    <span class="comment">#从头开始遍历</span></span><br><span class="line">    scan = $free = $heap_start</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $head_end)</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == FLASE)</span><br><span class="line">            <span class="comment"># size 记录相邻的非活动对象的大小</span></span><br><span class="line">            size += scan.size</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 记录活动对象的首地址</span></span><br><span class="line">        live = scan</span><br><span class="line">        <span class="keyword">while</span>(scan.mark == TRUE)</span><br><span class="line">            scan += scan.size</span><br><span class="line">        <span class="comment"># 上面两个while后，找到了第一个连续的非活动空间和第一个连续的活动空间</span></span><br><span class="line">        <span class="comment"># 移动活动对象群，并构筑间隙表格</span></span><br><span class="line">        slide_objs_and_make_bt(scan, $free, live, size)</span><br><span class="line">        <span class="comment"># 移动后记录下一个空闲空间地址</span></span><br><span class="line">        $free += (scan -live)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>slide_objs_and_make_bt</code>函数是一个比较复杂的过程，它主要由两部分组成:</p>
<ol>
<li>移动对象群</li>
<li>移动间隙表格</li>
</ol>
<p>可以用下面的图表示:<br>首先执行完上面代码到<code>slide_objs_and_make_bt</code>之前:<br><img src="/assets/img/gc/gc_mc_tb_1.png" alt="间隙表格"><br>执行<code>slide_objs_and_make_bt</code>后, 移动了对象群，并且在空出来的空间里记录了间隙表格, 左值100表示对象群首地址B的地址，右值100表示B之前的空白块长度为100<br><img src="/assets/img/gc/gc_mc_tb_2.png" alt="间隙表格"><br>再次执行<code>slide_objs_and_make_bt</code>后，F开头的对象群也进行了移动，并且把两个活动对象群对应的间隙表格都放到了空白块中，第二个间隙表格的550表示F的起始地址，右值300表示第一次执行<code>slide_objs_and_make_bt</code>后，第一个活动对象群的末尾到第二个活动对象群的开始，正好是6块，也就是上图<code>$free</code>到<code>live</code>的size大小是300。执行完最终结果如下:<br><img src="/assets/img/gc/gc_mc_tb_3.png" alt="间隙表格"></p>
<p>第二步更新指针的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">adjust_ptr() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = new_address(*r)</span><br><span class="line">    </span><br><span class="line">    scan = $heap_start</span><br><span class="line">    <span class="comment"># 对活动对象更新指针</span></span><br><span class="line">    <span class="keyword">while</span>(scan &lt; $free)</span><br><span class="line">        scan.mark = FALSE</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            *child = new_address(*child)</span><br><span class="line">        scan += scan.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到活动对象对应的应该跟新到的指针地址</span></span><br><span class="line">new_address(obj) &#123;</span><br><span class="line">    best_entry = new_bt_entry(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(entry : break_table)</span><br><span class="line">        <span class="keyword">if</span>(entry.address &lt;= obj &amp;&amp; $best_entry.address &lt; entry.address)</span><br><span class="line">            best_entry = entry</span><br><span class="line">    <span class="keyword">return</span> obj - best_entry.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>new_address</code>函数比较难理解，就是需要从多个间隙表格中找到活动对象群所对应的，然后利用obj-best_entry.size 就返回节点对应的新地址。</p>
<p>优点: 首先内存利用率和Two-Finger一样，但是由于是保持了原来的顺序，所以可以利用缓存。<br>缺点: 每次移动都要进行表格的移动和更新，代价比较高。</p>
<h3 id="ImmixGC-算法"><a href="#ImmixGC-算法" class="headerlink" title="ImmixGC 算法"></a>ImmixGC 算法</h3><p>暂略……</p>
<h2 id="保守式GC"><a href="#保守式GC" class="headerlink" title="保守式GC"></a>保守式GC</h2><p>前面提到过GC是根据对象的指针指向去搜寻其他对象的。另一方面，GC对非指针不进行任何操作。另外可以认为调用栈、寄存器以及全局变量空间都是根。对于上面存在一个问题就是: <strong>如何识别一个变量是否是指针?</strong> 这里所说的<strong>保守式GC</strong>就是指”不能识别指针和非指针的GC”, 而<strong>准确式GC</strong>指的就是能够正确识别指针和非指针的GC。</p>
<h3 id="保守式GC-1"><a href="#保守式GC-1" class="headerlink" title="保守式GC"></a>保守式GC</h3><p>之前说的下面这些空间都是根:</p>
<ul>
<li>寄存器</li>
<li>调用栈</li>
<li>全局变量空间</li>
</ul>
<p>但是事实上他们都是不明确的根(ambiguous roots)。<br>保守式GC对检查不明确的根时，所进行的基本项目是:</p>
<ul>
<li>是不是被正确对齐的值? (32位CPU，为4的倍数；64位CPU为8的倍数; 其他情况被视为非指针)</li>
<li>是不是指着堆内? (分配了GC专用堆，对象就会被分配到堆里，指向对象的指针按道理肯定指向堆内，否则就是非指针)</li>
<li>是不是指着对象的开头?(如果把对象固定大小对齐，例如”BiBOP”法，如果对象的值不是固定大小的倍数，就是非指针)</li>
</ul>
<p>当不明确的根运行GC时，偶尔会出现非指针和堆里的对象的地址一样的情况，这时就无法识别这个值是非指针，这就是<strong>“貌似指针的非指针”(false pointer)</strong>, 保守式GC这种把”貌似指针的非指针”看成”指向对象的指针”叫做”指针的错误识别”。在采用GC标记-清除算法，这种非指针会被错误的识别为活动对象，不会被回收。这样采取的是一种保守的态度，这样处理也不会出现问题。</p>
<ul>
<li>优点: 容易编写语言处理程序</li>
<li>缺点: 识别指针和非指针需要付出成本;错误识别指针会压迫堆, 会占用堆空间;能够使用的GC算法有限，不能使用移动对象的GC算法，否则就会重新非指针，照成意想不到的BUG</li>
</ul>
<h3 id="准确式GC"><a href="#准确式GC" class="headerlink" title="准确式GC"></a>准确式GC</h3><p>准确式GC是基于正确识别指针和非指针的<strong>“正确的根”(exact roots)</strong>来执行GC的。要想创建正确的根，就需要”语言处理程序的支援”, 依赖语言处理程序的实现。常见的方法这里介绍两种：</p>
<ul>
<li>打标签: 通过打标签的方法把不明确的根里的所有非指针和指针都区别开来。</li>
<li><p>不把寄存器和栈当做根: 创建一个正确的根来管理，这个正确的根在处理程序里只集合了mutator可能到达的指针，然后以它为基础执行GC。 参考Rubinius语言处理程序的实现。</p>
</li>
<li><p>优点: 相对于保守式GC，能够正确识别指针和非指针，适用的GC方法也更广泛。</p>
</li>
<li>缺点: 需要语言处理程序的支援，给实现者带来负担。</li>
</ul>
<h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><p>保守式GC有一个缺点就是”不能使用GC复制算法等移动对象的算法”, 因为如果是非指针的对象发生移动，其值就会发生变化，使用这个对象就会出现问题。解决这个问题的方法就是使用”间接引用”<br>结合下图来说明:<br>复制前可以看到根和对象之间有句柄。每个对象都有一个句柄，它们分别持有指向这些对象的指针。并且局部变量和全局变量这些不明确的根里没有指向对象的指针，只装着指向句柄的指针(如图中的1，2，3), 下图中的1，2表示指针，3表示非指针。<br><img src="/assets/img/gc/gc_handle_1.png" alt="间接引用1"><br>复制之后移动了引用目标的对象，只修改了1，2是指针的值，非指针3的值并没有发生改变。<br><img src="/assets/img/gc/gc_handle_2.png" alt="间接引用2"></p>
<ul>
<li>优点: 可以适用于更多的GC算法</li>
<li>缺点: 所有对象都要经由句柄间接引用，回拉低访问对象内数据的速度。</li>
</ul>
<h3 id="MostlyCopyingGC"><a href="#MostlyCopyingGC" class="headerlink" title="MostlyCopyingGC"></a>MostlyCopyingGC</h3><p>又是一个为了能够执行GC复制算法的保守式GC, 这个算法的核心思想就是抛开那些不能移动的对象，将其他”大部分”的对象都进行复制的GC算法，目的是为了保证不能移动的对象一定不会移动，可以移动的对象大部分都移动了，保证不出现BUG。<br>这个算法执行的前提条件:</p>
<ol>
<li>根是不明确的根</li>
<li>没有不明确的数据结构</li>
<li>对象大小随意</li>
</ol>
<p>执行这个算法的要点是把堆分配成一定大小的页(page)组成，执行分配的时候从正在使用的页里分配，如果空间不够则使用空页，如果一个页放不下，则会跨页存储。<br>执行GC时把所有根直接引用的页升级为To空间，然后再把To页对象的子对象复制到空页。这个过程会保留根直接引用的对象，所以不会复制非指针对象。同时升级的页中也包含了垃圾对象吗，无法清除。</p>
<h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><p>保守式GC指针的错误识别所带来害处和这个对象的大小及其子对象的数量有关系，如果一个对象很大，或者子对象很多，却被识别为”还活着”, 那就会在占用很多的堆空间。<br>这里的黑名单记录的是”不明确的根内的非指针，其指向的是有可能被分配对象的地址”， 这里说的”有可能被分配对象的地址”指的是”堆内未使用的对象的地址”。mutator无法引用至今未使用过的对象。也就是说，如果根里存在有这种地址的指针，那它肯定就是”非指针”，就会被记入黑名单中。在分配对象过程中，如果要分配的地址在黑名单中，这个对象有可能被非指针值所引用。也就是说，及时分配后对象成了垃圾，也很有可能被错误识别为”还活着”。为此，对象分配到这种地址是要满足:</p>
<ul>
<li>小对象</li>
<li>没有子对象的对象</li>
</ul>
<p>这样及时错误识别了，对整个堆的影响也不大，把对堆的压迫控制在最低限度。</p>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p>分代垃圾回收(Generational GC)把对象按“年龄”进行分类，使用不同的GC算法, 提高垃圾回收的效率。<strong>年龄</strong>的概念就是指对象的生存时间，经历一次GC后活下来的对象年龄就是1，依次类推。 新生成的对象和年龄小于一定值得对象都称为<strong>新生代对象</strong>, 年龄大于一定值得对象则称为<strong>老年代对象</strong>, 这就是所谓的分代。新生代对象经历一定GC后会变成老年代对象，这个过程就叫<strong>晋升(promotion)</strong>。</p>
<h3 id="Ungar-的分代垃圾回收"><a href="#Ungar-的分代垃圾回收" class="headerlink" title="Ungar 的分代垃圾回收"></a>Ungar 的分代垃圾回收</h3><p>Ungar 的垃圾回收是针对新生代执行GC复制算法，针对老年代执行标记-清除算法。Ungar 将堆结构分为四个部分，分别是生成空间、2个大小相等的幸存空间以及老年代空间，并分别用<code>$new_start</code>、<code>$survivor1_start</code>、<code>$survivor2_start</code>、<code>$old_start</code>这4个变量引用它们的开头。将生成空间和幸存空间合称为新生代空间。<br>当生成空间满了的时候，新生代GC就会启动，将生成空间的所有活动对象复制，这根GC复制算法是一个道理。目标空间是幸存空间中空闲的一个。</p>
<pre>
      记 录 集
    +---+---+---+---+
$rs |   |   |   |   |
    +---------------+
    +------------------------+ $new_start
    |              +--------------+   $survivor1_start
    |              |     +-------------+ $survivor2_start
    |              |     |     +-----------+  $old_start
    |              |     |     |                           堆
    v--------------v-----v-----v-----------------------------+
    |              |     |     |                             |
    |              |     |     |                             |
    |              |     |     |                             |
    +--------------+-----+-----+-----------------------------+
     生 成 空 间     幸 存 空 间            老 年 代 空 间
           新 生 代 空 间
</pre>

<p>分代垃圾回收的优点是只将垃圾回收的重点放在新生代对象上，以此来缩减GC所需的时间。但是老年代有可能引用了新生代对象，所以还需要遍历老年代对象，这样就大大削减了分代垃圾回收的优势，所以为了解决这个问题，又增加了一个<strong>记录集</strong>。记录集里记录的是对新生代有引用的老年代对象。这样在新生代GC时，只需要再对记录集进行遍历就行了。<br>为了将老年代对象记录到记录集里，我们利用写入屏障(write barrier)。在mutator更新对象间的指针操作中，写入屏障是不可或缺的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, new_obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj &gt;= $old_start <span class="comment">#发出引用的对象在老年代里</span></span><br><span class="line">        &amp;&amp; new_obj &lt; $old_start <span class="comment">#新生成的对象在新生代里</span></span><br><span class="line">        &amp;&amp; obj.remembered == FALSE) <span class="comment">#老年代对象没有被记录</span></span><br><span class="line">        $rs[$rs_index] = obj <span class="comment">#老年代对象加入记录集</span></span><br><span class="line">        $rs_index++ </span><br><span class="line">        obj.remembered = TRUE <span class="comment">#表示已经被记录过</span></span><br><span class="line">    *field = new_obj <span class="comment">#field是obj的指针，更新指针new_obj成为引用目标的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分配是在生成空间进行的，执行分配的<code>new_obj()</code>函数伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size) &#123;</span><br><span class="line">    <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line">        <span class="comment"># 生成空间不够用，执行新生代GC</span></span><br><span class="line">        minor_gc()</span><br><span class="line">        <span class="keyword">if</span>($new_free + size &gt;= $survivor1_start)</span><br><span class="line">            <span class="comment"># 执行GC后仍然不够用，返回错误</span></span><br><span class="line">            allocation_fail()</span><br><span class="line">    </span><br><span class="line">    obj = $new_free <span class="comment">#$new_free 是指向生成空间的分块开头的指针</span></span><br><span class="line">    $new_free += size</span><br><span class="line">    obj.age = <span class="number">0</span> <span class="comment">#年龄默认值</span></span><br><span class="line">    obj.forwarded = FALSE <span class="comment">#防止重复复制相同对象的标志，跟GC复制算法和GC标记-压缩算法中的作用一样</span></span><br><span class="line">    obj.remembered = FALSE <span class="comment">#是否在记录集里，只用于老年代对象</span></span><br><span class="line">    obj.size = size</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新生代GC的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">minor_gc() &#123;</span><br><span class="line">    $to_survivor_free = $to_survivor_start</span><br><span class="line">    <span class="comment">#根在新生代的对象进行GC复制</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="keyword">if</span>(*r &lt; $old_start)</span><br><span class="line">            *r = copy(*r)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="comment">#对记录集里的对象的子节点进行GC复制</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; $rs_index)</span><br><span class="line">        has_new_obj = FALSE</span><br><span class="line">        <span class="keyword">for</span>(child : children($rs[i]))</span><br><span class="line">            <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">                *child = copy(*child)</span><br><span class="line">                <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">                    has_new_obj = TRUE</span><br><span class="line">        <span class="comment"># TRUE表示复制后的对象在新生代，FALSE表示复制后的对象在老年代</span></span><br><span class="line">        <span class="comment"># 复制后的对象在老年代，则需要把这个对象从记录集里去掉</span></span><br><span class="line">        <span class="keyword">if</span>(has_new_obj == FALSE)</span><br><span class="line">            $rs[i].remembered = FALSE</span><br><span class="line">            $rs_index--</span><br><span class="line">            <span class="comment">#最后一位与当前节点交换，交换后，最后一位无法在访问到，可以认为是从记录集里去掉了</span></span><br><span class="line">            swap($rs[i], $rs[$rs_index])</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++</span><br><span class="line">    <span class="comment">#交换From空间和To空间</span></span><br><span class="line">    swap($from_survivor_start, $to_survivor_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象的复制</span></span><br><span class="line">copy(obj) &#123;</span><br><span class="line">    <span class="comment">#没有被复制</span></span><br><span class="line">    <span class="keyword">if</span>(obj.forwarded == FALSE)</span><br><span class="line">        <span class="comment">#年龄没有达到</span></span><br><span class="line">        <span class="keyword">if</span>(obj.age &lt; AGE_MAX)</span><br><span class="line">            copy_data($to_survivor_free, obj, obj.size)</span><br><span class="line">            <span class="comment"># 标识已经被复制</span></span><br><span class="line">            obj.forwarded = TRUE</span><br><span class="line">            <span class="comment"># 被复制到的地址</span></span><br><span class="line">            obj.forwarding = $to_survivor_free</span><br><span class="line">            <span class="comment"># age++</span></span><br><span class="line">            $to_survivor_free.age++</span><br><span class="line">            $to_survivor_free += obj.size</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                *child = copy(*child)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># 年龄达到，晋升到老年代</span></span><br><span class="line">            promote(obj)</span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象从新生代晋升到老年代</span></span><br><span class="line">promote(obj) &#123;</span><br><span class="line">    <span class="comment">#从老年代找空间</span></span><br><span class="line">    new_obj = allocate_in_old(obj)</span><br><span class="line">    <span class="keyword">if</span>(new_obj == NULL)</span><br><span class="line">        <span class="comment">#空间不够执行老年代的GC，跟GC标记-清除法一样</span></span><br><span class="line">        major_gc()</span><br><span class="line">        new_obj = allocate_in_old(obj)</span><br><span class="line">        <span class="keyword">if</span>(new_obj == NULL)</span><br><span class="line">            allocation_fail()</span><br><span class="line">    obj.forwarding = new_obj</span><br><span class="line">    obj.forwarded = TRUE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(child : children(new_obj))</span><br><span class="line">        <span class="keyword">if</span>(*child &lt; $old_start)</span><br><span class="line">            $rs[$rs_index] = new_obj</span><br><span class="line">            $rs_index++</span><br><span class="line">            new_obj.remembered = TRUE</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分代垃圾回收是建立在”很多对象年纪轻轻就会死”的基础上的，所以满足这种条件时，可以改善GC所花费的时间，提高吞吐量。是但是因为老年代GC很费时，所以没办法缩短mutator的最大暂停时间。并且如果不满足上面的条件时，就没办法利用到分代垃圾回收的优势。</p>
<h3 id="记录各代之间的引用的方法"><a href="#记录各代之间的引用的方法" class="headerlink" title="记录各代之间的引用的方法"></a>记录各代之间的引用的方法</h3><p>Ungar 分代垃圾回收的记录集是不可少的，但是这个记录集会浪费很多空间，为了提高内存利用率，可以通过下面两种方法：</p>
<ul>
<li>卡片标记: 把老年代空间等分成N个卡片，每份假设129字节(1024位)，可以用表格表格中位图的一位表示一个卡片，这样能够有效提高内存空间(只需老年代的1/1024)。当标记表格设置很多位时，可能就会在搜索卡片上花费大量时间。</li>
<li>页面标记: 利用OS的页面管理，如果在卡片标记中奖卡片和页面设置为同样大小，我们就能得到OS的帮助。一旦mutator对堆内的某一个页面进行写入操作，OS就会设置跟这个页面对应的位，我们把这个位叫做页面重写标志位(dirty bit)。卡片标记中是搜索标记表格，而页面标记则是搜索这个页面的重写标志位。</li>
</ul>
<h3 id="多代垃圾回收"><a href="#多代垃圾回收" class="headerlink" title="多代垃圾回收"></a>多代垃圾回收</h3><p>分代垃圾回收是把对象分为新生代和老年代两个，也可以分成3个及更多个, 分代越多，对象变成垃圾的机会也就越大，所以这个方法确实能够减少活到最老代的对象。但是每代的空间也就相应的变小了，这样一来各代之间的引用就变多了，各代中垃圾回收花费的时间也就越来越长了。综合来看，少设置一些分代能得到更优秀的吞吐量，据说分为2代或3代是最好的。</p>
<h3 id="列车垃圾回收"><a href="#列车垃圾回收" class="headerlink" title="列车垃圾回收"></a>列车垃圾回收</h3><p>Ungar 分代垃圾回收的一个问题是不能够减少最大暂停时间，而列车垃圾回收(Train GC)就是为了控制老年代GC中暂停时间的增长而设计的。列车垃圾回收中将老年代空间按照一定的大小划分，每个划分出来的空间称为车厢，多个车厢有组成列车，多个列车一起组成了老年代空间。1次老年代GC不再是对整个老年代空间进行，而是以1个车厢作为GC对象。<br>下面这幅图反应的是列车垃圾回收的堆结构:<br><img src="/assets/img/gc/train_gc_1.png" alt="列车垃圾回收堆结构"><br>具体过程省略……</p>
<ul>
<li>优点: 缩减了老年代GC照成的mutator的最大暂停时间。还能回收循环的大型垃圾。</li>
<li>缺点: 执行写入屏障的额外负担要比Ungar的分代垃圾回收中执行时所产生的更大，因此吞吐量上要弱一些。</li>
</ul>
<h2 id="增量式垃圾回收"><a href="#增量式垃圾回收" class="headerlink" title="增量式垃圾回收"></a>增量式垃圾回收</h2><p>增量式垃圾回收(Incremental GC)是一种通过逐渐推进垃圾回收来控制mutator最大暂停时间的方法。之前介绍的GC算法，一旦GC开始执行，mutator就没有办法执行了，像这样的GC叫做听执行GC。为了改变这种方式，想出了一种GC和mutator交替运行的方式，这就是增量垃圾回收。</p>
<h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h3><p>这个算法将GC中的对象按照各自情况分成三种:</p>
<ul>
<li>白色: 还未搜索过的对象</li>
<li>灰色: 正在搜索的对象</li>
<li>黑色: 搜索完成的对象</li>
</ul>
<p>以GC标记-清除算为例，应用到三色标记算法中。默认对象都是白色，GC一旦运行，所有从根能够到达的对象都会被标记，然后放到栈里。放到栈里的对象被标记成灰色，然后栈里的对象依次弹出，搜索其子对象，子对象也被标记成灰色。当其所有的子对象都被标记成灰色时，该对象就被标记成黑色。当GC结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾对象则为白色。<br>增量式的GC标记-清除算法可以分为以下三个阶段:</p>
<ul>
<li>根查找阶段</li>
<li>标记阶段</li>
<li>清除阶段</li>
</ul>
<p>下面是过程的伪代码，所谓标记为灰色并不是真正的标记为灰色，而是标记位TRUE,并放到栈中；置为黑色则只是标记为TRUE; 标记位白色的就是obj.mark=FALSE</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">incremental_gc() &#123;</span><br><span class="line">    case $gc_phase</span><br><span class="line">    when GC_ROOT_SCAN</span><br><span class="line">        root_scan_phase() <span class="comment">#根查找阶段</span></span><br><span class="line">    when GC_MARK</span><br><span class="line">        incremental_mark_phase() <span class="comment">#增量标记阶段</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        incremental_sweep_phase() <span class="comment">#增量清除阶段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根查找函数</span></span><br><span class="line">root_scan_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        mark(*r)</span><br><span class="line">    $gc_phase = GC_MARK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        obj.mark = TRUE</span><br><span class="line">        push(obj, $mark_stack) <span class="comment">#灰色对象放到栈里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#增量标记</span></span><br><span class="line">incremental_mark_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX) <span class="comment"># MARK_MAX每次从栈中弹出对象的次数</span></span><br><span class="line">        <span class="keyword">if</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">            obj = pop($mark_stack) <span class="comment">#从栈中弹出灰色对象, 标记其子对象</span></span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                mark(*child)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#栈为空，重新从根开始查找</span></span><br><span class="line">            <span class="keyword">for</span>(r : $roots)</span><br><span class="line">                mark(*r)</span><br><span class="line">            <span class="comment">#从根查找完继续标记</span></span><br><span class="line">            <span class="keyword">while</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">                obj = pop($mark_stack)</span><br><span class="line">                <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                    mark(*child)</span><br><span class="line">        <span class="comment">#为清除阶段做准备</span></span><br><span class="line">        $gc_phase = GC_SWEEP</span><br><span class="line">        $sweeping = $heap_start</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#写入屏障，对于新节点，需要标记为灰色</span></span><br><span class="line"><span class="comment">#如果没有这一步，标记阶段进行到一半有可能不会对新的节点进行搜索</span></span><br><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(newobj.mark == FALSE)</span><br><span class="line">        newobj.mark = TRUE</span><br><span class="line">        push(newobj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除阶段</span></span><br><span class="line">incremental_sweep_phase() &#123;</span><br><span class="line">    swept_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(swept_count &lt; SWEEP_MAX) <span class="comment">#每次清除SWEEP_MAX个对象</span></span><br><span class="line">        <span class="keyword">if</span>($sweeping &lt; $heap_end)</span><br><span class="line">            <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line">                $sweeping.mark = FALSE</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">#mark=false表示白色，放入到空闲链表中</span></span><br><span class="line">                $sweeping.next = $free_list</span><br><span class="line">                $free_list = $sweeping</span><br><span class="line">                $free_size += $sweeping.size</span><br><span class="line"></span><br><span class="line">            $sweeping += $sweeping.size</span><br><span class="line">            swept_count++</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $gc_phase = GC_ROOT_SCAN</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#分配</span></span><br><span class="line">newobj(size) &#123;</span><br><span class="line">    <span class="comment">#$free_siz 小于一定量时就执行GC， 而不是等到空间枯竭</span></span><br><span class="line">    <span class="keyword">if</span>($free_size &lt; HEAP_SIZE * GC_THRESHOLD)</span><br><span class="line">        incremental_gc()</span><br><span class="line">    </span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        chunk.size = size</span><br><span class="line">        $free_size -= size</span><br><span class="line">        <span class="comment">#chunk如果在清除阶段在要清除的空间，需要涂黑，表示不可回收</span></span><br><span class="line">        <span class="keyword">if</span>($gc_phrase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面整个过程，分配和GC是交替进行的，而且GC的三个阶段也是按顺序循环进行的，每次执行incremental_gc()都会进入下一个阶段。</p>
<ul>
<li>优点: 增量式垃圾回收不是一口气运行GC,而是和mutator交替运行的，因此不会长时间妨碍到mutator的运行。</li>
<li>缺点: 牺牲了吞吐量。吞吐量和最大暂停时间是互相权衡的，一方面做的好另一方面就会变差。</li>
</ul>
<h3 id="Steele的算法"><a href="#Steele的算法" class="headerlink" title="Steele的算法"></a>Steele的算法</h3><p>这个算法中使用的写入屏障要比上面(Dijkstra)的写入屏障条件更严格，它能减少GC中错误的标记的对象。<br>这个算法的标记函数如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出在放入栈时并没有标记<code>obj.mark=TRUE</code>, 也就是说这个算法的<strong>灰色对象</strong>是指”堆在标记栈里的没有设置标志位的对象”, 黑色对象是”设置了标志位的对象”。<br>写入屏障的伪代码也不一样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    <span class="keyword">if</span>($gc_phase == GC_MARK &amp;&amp;</span><br><span class="line">        obj.mark == TRUE &amp;&amp;</span><br><span class="line">        newobj.mark == FALSE)</span><br><span class="line">        obj.makr = FALSE</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码主要是判断如果在标记过程中发出引用的对象是黑色对象，且新的引用的目标对象为灰色或白色，那么我们就把发出引用的对象涂成灰色。Steele的写入屏障通过限制标记对象来减少被标记的对象，从而防止了因疏忽而造成垃圾残留的后果。 (详情参见P175)</p>
<h3 id="汤浅的算法"><a href="#汤浅的算法" class="headerlink" title="汤浅的算法"></a>汤浅的算法</h3><p>汤浅的算法中标记阶段并没有在搜索根，遵循了”以GC开始时对象间的引用关系为基础执行GC”这项原则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">incremental_mark_phase() &#123;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">1.</span>.MARK_MAX)</span><br><span class="line">        <span class="keyword">if</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">            obj = pop($mark_stack)</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                mark(*child)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        $gc_phrase = GC_SWEEP</span><br><span class="line">        $sweeping = $heap_start</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面通过写入屏障防止产生从黑色对象指向白色对象的指针，而汤浅的算法中却允许黑色对象指向白色对象的指针。汤浅算法是基于在GC开始时保留活动对象这项原则，就没有必要在生成新指针时标记引用对象的目标了。及时出现了从黑色对象指向白色对象的指针，只要保留了GC开始时的指针，作为引用目标的白色对象早晚会被标记。但是在删除指针时无法保留指针，因此写入屏障要进行一些特殊处理:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj) &#123;</span><br><span class="line">    oldobj = *field</span><br><span class="line">    <span class="comment">#在标记阶段中如果指针更新前引用的oldobj是白色对象，就将其涂成灰色</span></span><br><span class="line">    <span class="keyword">if</span>(gc_phase == GC_MARK &amp;&amp; oldobj.mark == FALSE)</span><br><span class="line">        oldobj.mark = TRUE</span><br><span class="line">        push(oldobj, $mark_stack)</span><br><span class="line"></span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分配</span></span><br><span class="line">newobj(size) &#123;</span><br><span class="line">    <span class="keyword">if</span>($free_size &lt; HEAP_SIZE  * GC_THRESHOLD)</span><br><span class="line">        incremental_gc()</span><br><span class="line"></span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        chunk.size = size</span><br><span class="line">        $free_size -= size</span><br><span class="line">        <span class="comment">#这里跟之前不一样，分配后会设置obj为黑色</span></span><br><span class="line">        <span class="keyword">if</span>($gc_phase == GC_MARK)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>($gc_phase == GC_SWEEP &amp;&amp; $sweeping &lt;= chunk)</span><br><span class="line">            chunk.mark = TRUE</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RC-Immix算法"><a href="#RC-Immix算法" class="headerlink" title="RC Immix算法"></a>RC Immix算法</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gc/">gc</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/23/gc-base/"><span>垃圾回收基本算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/23/gc-base/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-23T06:24:36.000Z">
          2017-01-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本章介绍GC的基本算法:GC标记-清除法，引用计数法, GC复制算法。这三种我认为是GC的三个方向的基本思维。其他方法都是围绕这个些基本方法展开的。</p>
</blockquote>
<h2 id="GC标记-清除法"><a href="#GC标记-清除法" class="headerlink" title="GC标记-清除法"></a>GC标记-清除法</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>所谓的标记-清除法，依据其字面意思就是，先做标记，然后在清除。这个过程分为两个阶段，标记阶段就是把所有活动对象坐上标记，清除阶段就是把那些没有做标记的对象，也就是非活动对象回收的阶段。利用伪代码表示就是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mark_sweep() &#123;</span><br><span class="line">    mark_phase()</span><br><span class="line">    sweep_phase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>标记阶段: 这个阶段从<code>根</code>出发，利用深度优先遍历(不用广度优先是因为深度优先搜索比广度优先搜索更能压低内存使用量。), 对每个能到达的活动对象都做上标记(用一个位来表示)。这个阶段所花费的时间与”活动对象的总数”成正比。标记阶段伪代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mark_phase() &#123;</span><br><span class="line">    <span class="comment">#遍历根节点, 进行标记</span></span><br><span class="line">    <span class="keyword">for</span>(r: $roots)</span><br><span class="line">        mark(*r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#标记函数</span></span><br><span class="line">mark(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">        obj.mark = TRUE</span><br><span class="line">        <span class="comment">#深度优先遍历</span></span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            mark(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除阶段: 清除阶段主要工作是通过遍历整个堆，把未被标记的对象(非活动对象)回收再利用。回收对象就是把对象作为分块，连接到被称为”空闲链表”的单向链表。之后进行分配时遍历空闲链表就可以找到分块了。两个相邻的分块如果地址是连续的，就会对其进行<strong>合并</strong>, 合并操作可以减少碎片的发生。清除阶段的伪代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase() &#123;</span><br><span class="line">    sweeping = $heap_start</span><br><span class="line">    <span class="comment">#遍历堆</span></span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">            sweeping.mark == FALSE</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">#放入空闲链表</span></span><br><span class="line">            <span class="keyword">if</span>(sweeping.mark == $free_list + $free_list.size)</span><br><span class="line">                <span class="comment">#合并</span></span><br><span class="line">                $free_list.size += sweeping.size</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sweeping.next = $free_list</span><br><span class="line">                $free_list = sweeping</span><br><span class="line">            sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分配: 进行mutator申请分块时，搜索空闲链表并找到合适大小的分块，这个过程就叫做分配。找到合适的分块大小有三种策略:</p>
<ol>
<li>First-fit: 找到最初发现大于等于size的分块就立刻返回。考虑到分配所需的时间，标记清除法选择的就是这种方法。</li>
<li>Best-fit: 遍历空闲链表，找到大于等于size的最小分块返回。</li>
<li>Worst-fit: 找出最大的分块，把分块分割成size大小和剩余分块。<br>分配阶段的伪代码:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size) &#123;</span><br><span class="line">    chunk = pickup_chunk(size, $free_list)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="优点-缺点"><a href="#优点-缺点" class="headerlink" title="优点/缺点"></a>优点/缺点</h3><ul>
<li>优点:<ol>
<li>实现简单</li>
<li>与保守式GC算法兼容: 保守式算法就是不知道对象是否是指针，所以移动对象会造成错误(后面会讲到), 而标记清除算法是不会移动对象的，所以是兼容的。</li>
</ol>
</li>
<li>缺点:<ol>
<li>碎片化: 由于非活动对象分布不均匀，容易照成堆内的内存空间碎片化，不利于mutator的执行。</li>
<li>分配速度: 由于分配时需要遍历空闲链表，查找速度取决于要分配的块和空闲链表的分布。后面要讲到的复制算法和标记-压缩算法由于分块是连续内存分布的，所以速度要快。</li>
<li>与写时复制技术不兼容： 因为每次GC都要修改活动对象的标记位，导致写操作的发生，从而产生复制。</li>
</ol>
</li>
</ul>
<h3 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h3><p>为了提高<strong>分配速度</strong>，一个改进就是把分块按照大小分为多个空闲链表，这样在分配的时候就可以根据要分配的空间的大小去对应的空闲链表中寻找，大大减少了查找分块的时间。<br>下面是利用多个空闲链表的new_obj()函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#index 是一个要分配的字的大小</span></span><br><span class="line">    index = size / (WORD_LENGTH / BYTE_LENGTH)</span><br><span class="line">    <span class="comment">#空闲链表一共有101个，0-100都是按照字精确分配到对应的$free_list[index]中，</span></span><br><span class="line">    <span class="comment">#大于100的字都分配到$free_list[101]中</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span>($free_list[index] != NULL)</span><br><span class="line">            <span class="comment">#直接找到对应的空闲链表</span></span><br><span class="line">            chunk = $free_list[index]</span><br><span class="line">            $free_list[index] = $free_list[index].next</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">#大于100的需要遍历$free_list[101]找到合适大小的块</span></span><br><span class="line">        chunk = pickup_chunk(size, $free_list[<span class="number">101</span>])</span><br><span class="line">        <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line"></span><br><span class="line">    allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BiBOP法"><a href="#BiBOP法" class="headerlink" title="BiBOP法"></a>BiBOP法</h3><p>针对标记-清除算法的<strong>碎片化</strong>问题, 可以把堆先分割成大小固定的块，让每个块只能配置同样大小的对象，这就是BiBOP法。如果某个大小字的活动对象很少，其他的字活动对象很多的话，这种情况也不能提高堆的利用率，无法解决碎片化的问题。</p>
<h3 id="位图标记法"><a href="#位图标记法" class="headerlink" title="位图标记法"></a>位图标记法</h3><p>上面还说道标记-清除法不能够与写时复制技术兼容是因为修改标记位会引起复制发生，为了解决这个问题，位图标记法采用只收集各个对象的标志位并表格化，不跟对象一起管理。也就是把对象和标记位进行了分离。这样做有两个好处:</p>
<ol>
<li>与写时复制技术兼容: 因为GC的时候改变了标记位也不会引起对象的复制, 而位图表格非常小，所以即使被复制也不会有什么大的影响。</li>
<li>清除操作更高效: 在遍历堆的时候不需要取消标志位，可以最后在位图表格中设置。</li>
</ol>
<h3 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h3><p>延迟清除法(Lazy Sweep)是缩减因清除操作而导致的mutator最大暂停时间的方法。这个方法的伪代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#用延迟清除法找到对应的块</span></span><br><span class="line">    chunk = lazy_sweep(size)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">    <span class="comment">#没有找到合适的，进行一次标记操作</span></span><br><span class="line">    mark_phase()</span><br><span class="line">    <span class="comment">#再用延迟清除法找到对应的块 </span></span><br><span class="line">    chunk = lazy_sweep(size)</span><br><span class="line">    <span class="keyword">if</span>(chunk != NULL)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">     </span><br><span class="line">    allocation_fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_sweep(size)&#123;</span><br><span class="line">    <span class="keyword">while</span>($sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line">            $sweeping.mark == FALSE</span><br><span class="line">        <span class="comment">#找到和大小合适的块</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>($sweeping.size &gt; size)</span><br><span class="line">            chunk = $sweeping</span><br><span class="line">            $sweeping += $sweeping + $sweeping.size</span><br><span class="line">            <span class="keyword">return</span> chunk</span><br><span class="line">        <span class="comment">#没找到继续往下找</span></span><br><span class="line">        $sweeping += $sweeping + $sweeping.size</span><br><span class="line">    <span class="comment">#遍历完了也没找到，$sweeping置为从头开始</span></span><br><span class="line">    $sweeping = $heap_start</span><br><span class="line">    <span class="keyword">return</span> NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里跟之前不同的是$sweeping是一个全局变量，每次执行lazy_sweep的时候都会从当前$sweeping的位置往后查找。如果第一次没有找到，第二次就会从头开始查找，如果第二次也没有查到，那就是没有可以分配的块了。一般情况下第一次查找范围变小了，mutator的执行时间就短了。但是有一个问题是就是当数据分配不均，比如说后面的都是活动对象，前面的都是空的，反而会增加mutator的时间。如何改善这个问题，后面会再说到。</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>GC的目的是为了释放无法被引用的对象，自然就会想到让每个对象记录下自己被引用的个数，如果个数为0表示无法被引用，那就可以对其进行回收。这种思路就是引用计数法(Reference Counting)。</p>
<h3 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h3><p>引用计数法最重要的就是引入了一个计数器，用来记录被引用的个数。首先先看一下引用计数法的伪代码实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成新对象</span></span><br><span class="line">new_obj(size)&#123;</span><br><span class="line">    <span class="comment">#从空闲链表中找到合适的块</span></span><br><span class="line">    obj = pickup_chunk(size, $free_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">        allocation_fail()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">#对象有一个计数器，成功生成后计数器值是1</span></span><br><span class="line">        obj.ref_cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新ptr指针，使其指向新对象obj</span></span><br><span class="line">update_ptr(ptr, obj)&#123;</span><br><span class="line">    <span class="comment">#被指向的对象计数器+1</span></span><br><span class="line">    inc_ref_cnt(obj)</span><br><span class="line">    <span class="comment">#原来指向的对象计数器-1</span></span><br><span class="line">    dec_ref_cnt(*ptr)</span><br><span class="line">    <span class="comment">#指向新对象</span></span><br><span class="line">    *ptr = obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数器+1</span></span><br><span class="line">inc_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数器-1</span></span><br><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    <span class="comment">#obj计数器-1</span></span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="comment">#obj计数器为0，说明对象变成了"垃圾", 需要对其子对象计数器都-1， 因为这个对象不存在了。</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            dec_ref_cnt(*child)</span><br><span class="line">        <span class="comment">#将obj连接到空闲链表中</span></span><br><span class="line">        reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面需要注意的一点是执行<code>update_ptr</code>的时候先执行了<code>inc_ref_cnt</code>后执行了<code>dec_ref_cnt</code>, 这是因为当<code>update_ptr</code>的前后两个对象是同一个时，如果先指向了<code>dec_ref_cnt</code>就会把这个对象删除，再执行<code>inc_ref_cnt</code>时就会出错，而顺序反过来就不会存在这个问题了。还有一点是引用计数法和标记清除法不一样的地方:引用计数法会在指针变动时发现是否是垃圾，从而立即回收，而标记清除法则即使发现了也不会立即回收，而是标记完后一起回收。</p>
<h3 id="优点-缺点-1"><a href="#优点-缺点-1" class="headerlink" title="优点/缺点"></a>优点/缺点</h3><ul>
<li><p>优点</p>
<ol>
<li>可以即刻进行垃圾回收</li>
<li>最大暂停时间短: 只在发生引用关系变化时立即回收。</li>
<li>没有必要沿指针查找: 根据每个变量的引用计数来回收，不需要进行遍历。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>计数器值的增减处理繁重</li>
<li>计数器需要占用很多位: 计数器需要记录被引用的个数，这个记录位会占用不少的内存空间。</li>
<li>实现繁琐复杂</li>
<li>循环引用无法回收:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    string name</span><br><span class="line">    Person lover</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taro = <span class="keyword">new</span> Person(<span class="string">"太郎"</span>) <span class="comment">//执行后taro的引用计数为1</span></span><br><span class="line">hanako = <span class="keyword">new</span> Person(<span class="string">"花子"</span>) <span class="comment">//执行后hanako的引用计数为1</span></span><br><span class="line">taro.lover = hanako <span class="comment">//执行后hanako的引用计数为2</span></span><br><span class="line">hanako.lover = taro <span class="comment">//执行后taro的引用计数为2</span></span><br><span class="line">taro = <span class="keyword">null</span> <span class="comment">//taro指向null, hanako引用计数-1，变为1</span></span><br><span class="line">hanako = <span class="keyword">null</span> <span class="comment">//hanako指向null, taro引用计数-1， 变为1</span></span><br><span class="line"><span class="comment">//全部执行完后taro与hanako的引用计数都为1，不能被回收，但是又无法被引用, 照成了内存泄露的情况</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>用图来说请其中的过程如下：<br><img src="/assets/img/gc/rc_cr.png" alt="循环引用图解"></p>
<h3 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h3><p>上面说到引用计数法的计数器值得<strong>增减处理很繁重</strong>，为了改善这个缺点，引入了延迟引用计数法(Deferred Reference Counting)。延迟引用计数法利用ZCT(Zero Count Table)来记录计时器值在dec_ref_cnt()作用下变为0的对象, zct表内的值是指向这些对象的指针。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#update_ptr($ptr, obj)调用不变，只是dec_ref_cnt不会递每次都递归处理子节点的引用计数</span></span><br><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">#$zct满了就执行一次扫描</span></span><br><span class="line">        <span class="keyword">if</span>(is_full($zct) == TRUE)</span><br><span class="line">            scan_zct()</span><br><span class="line">        push($zct, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_obj(size)&#123;</span><br><span class="line">    obj = pickup_chunk(size, $free_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">        <span class="comment">#空间不够执行一次扫描, 释放空间</span></span><br><span class="line">        scan_zct()</span><br><span class="line">        obj = pickup_chunk(size, $free_list)</span><br><span class="line">        <span class="keyword">if</span>(obj == NULL)</span><br><span class="line">            allocation_fail()</span><br><span class="line"></span><br><span class="line">    obj.ref_cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#扫描zct</span></span><br><span class="line">scan_zct()&#123;</span><br><span class="line">    <span class="comment">#对根直接引用的对象都进行增量， 把根引用反映到计数器的值上</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        (*r).ref_cnt++</span><br><span class="line">    <span class="comment">#对子对象的计数器进行减量操作，回收 </span></span><br><span class="line">    <span class="keyword">for</span>(obj : $zct)</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">            remove($zct, obj)</span><br><span class="line">            delete(obj)</span><br><span class="line">    <span class="comment">#恢复根节点直接引用的对象计数器的值</span></span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        (*r).ref_cnt--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#减量操作和回收</span></span><br><span class="line">delete(obj)&#123;</span><br><span class="line">    <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">        (*child).ref_cnt--</span><br><span class="line">        <span class="keyword">if</span>((*child).ref_cnt == <span class="number">0</span>)</span><br><span class="line">            delete(*child)</span><br><span class="line"></span><br><span class="line">    reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>书举例说<code>update_ptr($ptr, obj)</code>改写成<code>*$ptr = obj</code>, 我理解这只是举了一个例子说明不需要增减计数器。实际后面的代码中可以看出，还是使用的<code>update_ptr($ptr, obj)</code>,否则就没有对<code>dec_ref_cnt(obj)</code>的调用了。变化比较大的是<code>dec_ref_cnt(obj</code>函数，它不再递归调用子节点的计数器减量，而是直接把它放到zct结构中，在必要时调用scan_zct, 这就大大减少了计数器值得增减。</p>
<ul>
<li>优点: 延迟了根引用的技术，将垃圾一并回收，减轻了因根引用频发发生的变化导致计数器增减所带来的额外负担。</li>
<li>缺点: 失去了引用计数法的一大优点–可即可回收垃圾。另外scan_zct()导致最大暂停时间延长了。</li>
</ul>
<h3 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h3><p>引用计数法有一个问题就是计数器要设置多大的位宽。如果设置的小了，有可能会出现存不下而溢出的情况；如果设置的大了，又会占用过多的空间。Sticky的思想就是设置一个固定大小的位数，这个位数要比较小，对于溢出的情况下面两种处理方式:</p>
<ul>
<li>什么都不做<br>当计数器出现溢出时，不对其进行任何操作，其值就是能存储的最大值，一般情况下这个值很难达到，如果达到了这个值，证明其非常重要，其成为垃圾的可能性也非常小，对其计数不增也不减，不会存在什么大的问题。</li>
<li>使用GC标记-清除算法进行管理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mark_sweep_for_counter_overflow()&#123;</span><br><span class="line">    <span class="comment">#所有计数器清零</span></span><br><span class="line">    reset_all_ref_cnt()</span><br><span class="line">    mark_phase()</span><br><span class="line">    sweep_phase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#对所有可以达到的节点进行标记，每个节点及其子节点只会进栈一次，所以引用计数的值最多为2， 不会出现溢出的情况</span></span><br><span class="line">mark_phase()&#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        <span class="comment">#所有根节点放到标记栈中</span></span><br><span class="line">        push(*r, $mark_stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(is_empty($mark_stack) == FALSE)</span><br><span class="line">        obj = pop($mark_stack)</span><br><span class="line">        <span class="comment">#弹出栈，引用计数+1</span></span><br><span class="line">        obj.ref_cnt++</span><br><span class="line">        <span class="comment">#只有引用计数为1才让其子节点进栈，已经进过的不会再进</span></span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                push(*child, $mark_stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除节点遍历堆，所有标记位为0的节点进行回收</span></span><br><span class="line">sweep_phase()&#123;</span><br><span class="line">    sweeping = $heap_top</span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $head_end)</span><br><span class="line">        <span class="keyword">if</span>(sweeping.ref_cnt == <span class="number">0</span>)</span><br><span class="line">            reclaim(sweeping)</span><br><span class="line">        sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这么做可以在溢出后依然回收，而且没有对循环引用页适用，但是需要重置计数器。查找对象时没有设置标记位，而只是增量计数器，会出现多次查找活动对象的问题。比起一般的GC标记-清除算法需要更多的时间，吞吐量也会变小。</p>
<h3 id="1位引用计数法"><a href="#1位引用计数法" class="headerlink" title="1位引用计数法"></a>1位引用计数法</h3><p>1位引用计数法(1 bit Reference Counting)是Sticky引用计数法的极端例子，计数器只有1位大小。这里的计数器不在表示引用的个数，而是表示有一个引用还是多个引用。</p>
<ol>
<li>当计数器值为0，表示对象引用数为1，这种状态称为<strong>UNIQUE</strong></li>
<li>当计数器值为1， 表示引用数为复数, 这种状态称为<strong>MULTIPLE</strong></li>
</ol>
<p>相关伪代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指针复制 </span></span><br><span class="line"><span class="comment">#dest_ptr: 目的指针 </span></span><br><span class="line"><span class="comment">#src_ptr: 源指针 </span></span><br><span class="line">copy_ptr(dest_ptr, src_ptr)&#123;</span><br><span class="line">    <span class="comment">#由于目的指针原来指向的内容不再指向，需要对目的指针指向删除操作 </span></span><br><span class="line">    delete_ptr(dest_ptr)</span><br><span class="line">    <span class="comment">#执行复制 </span></span><br><span class="line">    *dest_ptr = *src_ptr</span><br><span class="line">    <span class="comment">#目的指针由于和源指针指向了同一个对象，目的指针需要设置为MULTIPLE </span></span><br><span class="line">    set_multiple_tag(dest_ptr)</span><br><span class="line">    <span class="comment">#源指针如果原来是UNIQUE, 现在多了一个目的指针，需要设置为MULTIPLE </span></span><br><span class="line">    <span class="keyword">if</span>(tag(src_ptr) == UNIQUE)</span><br><span class="line">        set_multiple_tag(src_ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除目的指针原来的指向对象 </span></span><br><span class="line">delete_ptr(ptr)&#123;</span><br><span class="line">    <span class="comment">#如果原来是UNIQUE，说明对象只有一个指针，删除后需要回收 </span></span><br><span class="line">    <span class="keyword">if</span>(tag(ptr) == UNIQUE)</span><br><span class="line">        <span class="comment">#回收 </span></span><br><span class="line">        reclaim(ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其过程可以参考下图:<br><img src="/assets/img/gc/1bit_rc.png" alt="1bit_rc"></p>
<ul>
<li>优点: <ol>
<li>不容易出现高速缓存缺失， 如上图所示，在更新计数器的时候不需要读取元素的值到内存中（C,D完全没有读), 只需要更新指针的计数器，所以不会出现内存中离得远找出缓存缺失。</li>
<li>计数器所占空间很小，节省内存。</li>
</ol>
</li>
<li>缺点: 1位引用计数器是在大量计数器都不足2的前提下来做的，当出现大量大于2的计数器时，1位引用计数器方法就无法回收这些对象，给堆带来巨大负担。</li>
</ul>
<h3 id="部分标记-清除算法"><a href="#部分标记-清除算法" class="headerlink" title="部分标记-清除算法"></a>部分标记-清除算法</h3><p>部分标记清除法主要是针对之前的无法回收循环引用的缺点而产生的。之前讲的<strong>延迟引用计数法</strong>可以处理循环引用的情况，但是效率太低。部分-标记清除算法只针对有可能是循环引用的对象上执行，在一般的对象上还是执行引用计数法。下面结合代码图图示说明一下部分标记-清除算法的过程。</p>
<p>部分标记-清除算法中，对象被涂成四种颜色来管理。每个颜色的含义如下：</p>
<ol>
<li>黑(BLACK): 绝对不是垃圾的对象(对象产生时的初始颜色)</li>
<li>白(WHITE): 绝对是垃圾的对象</li>
<li>灰(GRAY): 搜索完毕的对象</li>
<li>阴影(HATCH): 可能是循环垃圾的对象</li>
</ol>
<p>首先我们假设有一个循环引用对象群，<strong>初始状态</strong>如下：<br><img src="/assets/img/gc/pms_rc_1.png" alt="初始状态"><br>图中A和D是由根引用。所有对象在初始状态下都为黑色。<br>对应的初始代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    obj = pickup_chunk(size)</span><br><span class="line">    <span class="keyword">if</span>(obj != NULL)</span><br><span class="line">        <span class="comment">#初始颜色会BLACK</span></span><br><span class="line">        obj.color = BLACK</span><br><span class="line">        obj.ref_cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_empty($hatch_queue) == FALSE)</span><br><span class="line">        <span class="comment">#当空间不够用时扫描可能是循环引用的对象，然后释放出新的空间, 再次调用new_obj</span></span><br><span class="line">        scan_hatch_queue()</span><br><span class="line">        <span class="keyword">return</span> new_obj(size)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当执行<code>dec_ref_cnt()</code>时, 引用计数为0， 则回收。不为0时都认为是<strong>可能存在循环引用</strong>的对象, 都标记成HATCH, 并且把这个对象放到<code>$hatch_queue</code>当中。代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dec_ref_cnt(obj)&#123;</span><br><span class="line">    obj.ref_cnt--</span><br><span class="line">    <span class="comment">#ref_cnt == 0, 回收对象</span></span><br><span class="line">    <span class="keyword">if</span>(obj.ref_cnt == <span class="number">0</span>)</span><br><span class="line">        delete(obj)</span><br><span class="line">    <span class="comment">#ref_cnt != 0 认为是可能存在循环引用的对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(obj.color != HATCH)</span><br><span class="line">        obj.color = HATCH</span><br><span class="line">    enqueue(obj, $hatch_queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对上面的图，如果A的引用被删除了，则执行<code>dec_ref_cnt()</code>之后的状态如下图:</p>
<p><img src="/assets/img/gc/pms_rc_2.png" alt="执行dec_ref_cnt"></p>
<p>这是对象群在调用<code>new_obj()</code>时已经没有心的内存空间可以使用，所以会触发<code>scan_hatch_queue()</code>函数的调用。对应代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scan_hatch_queue()&#123;</span><br><span class="line">    <span class="comment">#可能是循环引用的对象出队列</span></span><br><span class="line">    obj = dequeue($hatch_queue)</span><br><span class="line">    <span class="comment">#如果颜色为HATCH, 依次调用下面的函数</span></span><br><span class="line">    <span class="keyword">if</span>(obj.color == HATCH)</span><br><span class="line">        paint_gray(obj)</span><br><span class="line">        scan_gray(obj)</span><br><span class="line">        collect_white(obj)</span><br><span class="line">    <span class="comment">##如果颜色不为HATCH, 证明不是循环引用对象，继续下一个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_empty($hatch_queue) == FALSE)</span><br><span class="line">        scan_hatch_queue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面需要调用的<code>paint_gray(obj)</code>函数主要作用是深度遍历对象，搜索过的对象标记位GRAY:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">paint_gray()&#123;</span><br><span class="line">    <span class="comment">#对原来是BLACK或HATCH的对象标记为GRAY</span></span><br><span class="line">    <span class="keyword">if</span>(obj.color == (BLACK | HATCH))</span><br><span class="line">        obj.color = GRAY</span><br><span class="line">    <span class="comment">#深度遍历子节点，引用计数减量, 递归调用paint_gray记性标记</span></span><br><span class="line">    <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">        (*child).ref_cnt--</span><br><span class="line">        paint_gray(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完上面的函数后，对象的状态如下图:<br><img src="/assets/img/gc/pms_rc_3.png" alt="执行dec_ref_cnt"><br>下面<code>scan_gray(obj)</code>的目的是扫描刚才的GRAY节点，把其中的垃圾对象找出来，标记成WHITE:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scan_gray(obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == GRAY)</span><br><span class="line">        <span class="keyword">if</span>(obj.ref_cnt &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">#ref_cnt&gt;0, 不是垃圾，需要标记成BLACK</span></span><br><span class="line">            paint_black(obj)</span><br><span class="line">            <span class="comment">#ref_cnt == 0, 是垃圾对象，标记成WHITE</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            obj.color = WHITE</span><br><span class="line">            <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">                scan_gray(*child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">paint_black(obj)&#123;</span><br><span class="line">    obj.color = BLACK</span><br><span class="line">    <span class="keyword">for</span>(child : chidren(obj))</span><br><span class="line">        <span class="comment">#由于执行paint_gray的时候ref_cnt--, 这里要恢复ref_cnt</span></span><br><span class="line">        (*child).ref_cnt++</span><br><span class="line">        <span class="keyword">if</span>((*child).color != BLACK)</span><br><span class="line">            paint_black(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记后的对象如下:<br><img src="/assets/img/gc/pms_rc_4.png" alt="执行dec_ref_cnt"><br>到上面的步骤后，可以看出已经知道那些颜色为WHITE的对象就是垃圾对象，这些对象需要回收，回收代码入下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">collect_white()&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.color == WHITE)</span><br><span class="line">        obj.color = BLACK</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            collect_white(*child)</span><br><span class="line">        reclaim(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回收后的图如下:<br><img src="/assets/img/gc/pms_rc_5.png" alt="执行dec_ref_cnt"><br>上面就是部分标记-清除算法的过程。这个算法的优点就是，只搜索可能是循环垃圾的对象群，就是阴影部分，如何确定这个范围呢？首先产生垃圾循环的条件有两个:</p>
<ol>
<li>产生循环引用。</li>
<li>删除从外部到循环引用的引用。</li>
</ol>
<p>部分标记-清除算法就利用<code>dec_ref_cnt()</code>函数来判断，如果引用计数减值后不为0， 那这个对象有可能就是循环对象的一份子。<br>这个算法的缺点就是需要三次查找对象，而每次查找的数量不少，所以付出的成本比较大。</p>
<h2 id="GC复制算法"><a href="#GC复制算法" class="headerlink" title="GC复制算法"></a>GC复制算法</h2><p>GC复制算法把原来的内存空间分为两部分(From空间和To空间), 当From空间不够分配时，就会执行GC复制算法，把From空间的活动对象复制到To空间，复制完成后交换From和To空间，GC结束，分配时去心的From空间查找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">copying()&#123;</span><br><span class="line">    <span class="comment">#$to_start To空间的起始地址</span></span><br><span class="line">    <span class="comment">#$free 要copy到的起始地址</span></span><br><span class="line">    $free = $to_start</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = copy(*r)</span><br><span class="line">    <span class="comment">#交换From 和 To 空间</span></span><br><span class="line">    swap($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行From 到 To 的 copy</span></span><br><span class="line">copy(obj)&#123;</span><br><span class="line">    <span class="comment"># 如果obj.tag != COPIED, 此对象还没有被执行过COPY, 对其执行COPY</span></span><br><span class="line">    <span class="keyword">if</span>(obj.tag != COPIED)</span><br><span class="line">        copy_data($free, obj, obj.size)</span><br><span class="line">        <span class="comment">#执行完后改变tag值，下次不再对其执行COPY</span></span><br><span class="line">        obj.tag = COPIED</span><br><span class="line">        <span class="comment">#forwarding是原来对象指向复制后的对象的指针，便于新老节点对应起来，下面递归查询的时候好查找</span></span><br><span class="line">        obj.forwarding = $free</span><br><span class="line">        <span class="comment">#free是要复制到的起始地址，当复制完一个对象后，需要前进size, 到达新的地址(To空间空闲的起始地址)</span></span><br><span class="line">        $free += obj.size</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#对执行过的对象执行深度遍历，全部活动子节点都COPY到TO空间</span></span><br><span class="line">        <span class="keyword">for</span>(child : children(obj.forwarding))</span><br><span class="line">            *child = copy(*child)</span><br><span class="line">    <span class="comment">#注意，当对根节点的元素执行时，返回的是根节点执行的obj.forwarding, </span></span><br><span class="line">    <span class="comment">#所以全部执行完后，根节点结合就是原来的根节点集合的forwarding指针指向的元素</span></span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">new_obj()&#123;</span><br><span class="line">    <span class="comment">#这里FROM和TO等分，如果空间不够，执行GC</span></span><br><span class="line">    <span class="keyword">if</span>($free + size &gt; $from_start + HEAP_SIZE/<span class="number">2</span>)</span><br><span class="line">        copying()</span><br><span class="line">        <span class="comment">#执行完GC后空间还不够，返回失败</span></span><br><span class="line">        <span class="keyword">if</span>($free + size &gt; $from_start + HEAM_SIZE/<span class="number">2</span>)</span><br><span class="line">            allocation_fail()</span><br><span class="line"></span><br><span class="line">    obj = $free</span><br><span class="line">    obj.size = size</span><br><span class="line">    $free += size</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GC复制算法过程参考下面的图:<br><img src="/assets/img/gc/copy_1.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_2.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_3.png" alt="GC复制算法"><br><img src="/assets/img/gc/copy_4.png" alt="GC复制算法"></p>
<ul>
<li>优点:</li>
</ul>
<ol>
<li>优秀的吞吐量: 只需要搜索活动对象，不需要其他的搜索。</li>
<li>可实现高速分配: 不需要空闲链表，只移动$free指针，快速分配。</li>
<li>不会发生碎片化: 因为分配的都是连续的，GC之后也是连续的，对象都放在了堆的一端(叫做压缩)。</li>
<li>与缓存兼容: 深度优先遍历，关联的节点都被放到了相邻的位置。</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>堆使用效率低下: GC复制算法通常把堆分为二等分，只有一半可以来安排对象。</li>
<li>不兼容保守式GC算法: 会发生对象的移动。</li>
<li>递归调动函数: 递归复制，每次调用都会消耗栈，会有栈溢出的可能。</li>
</ol>
<h3 id="Cheney的GC复制算法"><a href="#Cheney的GC复制算法" class="headerlink" title="Cheney的GC复制算法"></a>Cheney的GC复制算法</h3><p>上面提到GC复制算法用递归复制，会有栈溢出的可能。Cheney的GC复制算法则采用广度优先的方式，用循环代替递归，解决栈溢出的问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">copying()&#123;</span><br><span class="line">    scan = $free = $to_start</span><br><span class="line">    <span class="keyword">for</span>(r : $roots)</span><br><span class="line">        *r = copy(r)</span><br><span class="line">    <span class="comment">#广度优先遍历需要一个队列保，scan 到 $free 就是这个隐藏的队列</span></span><br><span class="line">    <span class="keyword">while</span>(scan != $free)</span><br><span class="line">        <span class="keyword">for</span>(child : children(scan))</span><br><span class="line">            *child = copy(*child)</span><br><span class="line">        scan += scan.size</span><br><span class="line">        </span><br><span class="line">    swap($from_start, $to_start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy()&#123;</span><br><span class="line">    <span class="comment">#如果obj.forwarding是指向To空间指针则返回TRUE, 如果不是则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span>(is_pointer_to_heap(obj.forwarding, $to_start) == FALSE)</span><br><span class="line">        copy_data($free, obj, obj.size)</span><br><span class="line">        obj.forwarding = $free</span><br><span class="line">        $free += obj.size</span><br><span class="line">    <span class="keyword">return</span> obj.forwarding</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/assets/img/gc/gc_copy_cheney_1.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_2.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_3.png" alt="Cheney复制算法"><br><img src="/assets/img/gc/gc_copy_cheney_4.png" alt="Cheney复制算法"></p>
<p>这个算法的缺点是不能利用局部缓存，因为有关系的节点不是相邻的。</p>
<h3 id="近似深度优先搜索方法"><a href="#近似深度优先搜索方法" class="headerlink" title="近似深度优先搜索方法"></a>近似深度优先搜索方法</h3><p>为了解决Cheney算法不能利用局部缓存，这里进行了一个改进，对于每个“页面”内部都是广度优先搜索。下面通过一个例子，看一下Cheney与近似深度优先搜索的方法对比:<br>图1，原始的引用关系:<br><img src="/assets/img/gc/gc_cp_df_1.png" alt="近似深度优先搜索方法"><br>图2，假设每三个节点占用一个”页面”的空间，下面就是Cheney方法，广度优先遍历后的ji结果:<br><img src="/assets/img/gc/gc_cp_df_2.png" alt="近似深度优先搜索方法"><br>可以看出，上图中相互引用的节点之间存储的比较分散，不容里利用局部缓存。<br>图3是利用近似深度优先搜索方法后的结果，可以看出分布比较集中，可以很好利用局部缓存。<br><img src="/assets/img/gc/gc_cp_df_3.png" alt="近似深度优先搜索方法"></p>
<h3 id="多空间复制算法"><a href="#多空间复制算法" class="headerlink" title="多空间复制算法"></a>多空间复制算法</h3><p>上面降到复制算法的一个明显的特征就是堆的利用率低。为了改善这个问题，多空间复制的算法的思想就是把一个堆N等分，只对其中2块空间执行GC复制算法，对剩下的(N-2)块空间执行GC标记-清除算法，也就是把这两种算法组合起来使用。具体细节不再展开。这个方法的优点是可以更有效的利用堆，但是缺点也很明显，就是标记-清除算法的缺点:分配耗费时间，分块碎片化等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本算法是进行GC的基本思想，每个算法都有其缺点和优点，没有算法能够完美解决所有问题。所以后面的算法利用这几种基本算法的组合和变形，更好的提高GC的性能。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gc/">gc</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/22/gc/"><span>垃圾回收算法总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/22/gc/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-22T06:56:28.000Z">
          2017-01-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>最近研读了《垃圾回收的算法与实现》这本书， 对来垃圾回收(<code>GC</code>)的来龙去脉及理论和实践有了一个概括性，深入性的了解，这里分多篇进行总结。首先本文先对GC的理论来一个总览性的回顾.</p>
</blockquote>
<h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>我们知道一台服务器的内存是有限的，而程序的运行需要占用内存空间，一个程序内部可能有些内存空间使用后不再使用，这部分不再使用的内从空间就被视为<code>垃圾</code>。而GC就是要</p>
<ol>
<li>找到内存空间里的垃圾</li>
<li>回收垃圾，让程序员能够再次利用这部分空间</li>
</ol>
<p>如果没有GC的情况下需要程序员自己手动管理内存，例如C/C++等程序。这个过程将会非常麻烦，如果管理不当就会照成内存泄露引起系统崩溃，引发各种恶性bug和安全问题。有了GC就会省去很大一部分精力，降低了开发的难度。</p>
<h2 id="垃圾回收基本概念"><a href="#垃圾回收基本概念" class="headerlink" title="垃圾回收基本概念"></a>垃圾回收基本概念</h2><p>要深入了解垃圾回收的理论知识，下面这些关键件信息比必要掌握:</p>
<ul>
<li>对象/头/域: 这里对象是由头(heder)和域(field)构成的。头是指保持对象本身信息的部分，主要包括<strong>对象的大小</strong>和<strong>对象的种类</strong>;域是对象使用者可以访问的部分，域的数据类型主要分为指针和非指针两种。</li>
<li>指针: GC根据对象的指针指向去搜寻其他对象，对于非指针不进行任何操作。</li>
<li>mutator: 程序运行过程中关系的改变，主要包括<strong>生成对象</strong>和<strong>更新指针</strong>等操作。</li>
<li>堆: 用于动态存放对象的内存空间。当mutator申请存放对象时，所需的内从空间就是从这个堆中被分配给mutator的。</li>
<li>活动对象/非活动对象: 内存空间中可以通过mutator引用的对象是”活动对象”, 不能通过程序引用的称为”非活动对象”。非活动对象无法重新被引用，所以就是”垃圾”。</li>
<li>分配: 内存空间中分配(allocatio)对象。当mutator需要新对象时，就会向分配器(allocator)申请一个大小合适的空间。</li>
<li>分块: 未利用对象而事先准备的空间。初始状态堆就是一个大分块，根据mutator的需求而分割成合适的大小。</li>
<li>根: 跟是指向对象的指针的起点，通过mutator可以直接调用的调用栈(call stack),寄存器和全局变量都是根。但是调用栈和寄存器中的值是不是指针，需要再做判断。</li>
<li>评价标准: GC算法的性能评价标准主要有<ol>
<li>吞吐量: 单位时间内的处理能力。</li>
<li>最大暂停时间: 因执行GC和停止mutator的最长时间。</li>
<li>堆使用效率</li>
<li>访问的局部性: 局部性原理，数据离得越近越好处理。</li>
</ol>
</li>
</ul>
<h2 id="垃圾回收算法总览"><a href="#垃圾回收算法总览" class="headerlink" title="垃圾回收算法总览"></a>垃圾回收算法总览</h2><p>首先先上一张垃圾回收算法的总概括图:<br><img src="/assets/img/gc/GC.png" alt="垃圾回收算法总览"><br>上面列举和好多算法及对应的细节。其实GC最基本的思想就是三种算法(GC标记-清除法, 引用计数法, GC复制算法), 其他算法都算是这几个算法的延伸和组合。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/gc/">gc</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/3/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 sean chen
    
  </p>
</footer>
    
  </div>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>